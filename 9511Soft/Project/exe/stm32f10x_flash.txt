; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\stm32f10x_flash.o --depend=.\exe\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\stm32f10x_flash.crf ..\Source\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000004  4afa              LDR      r2,|L1.1008|
000006  6810              LDR      r0,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;137      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000012  49f7              LDR      r1,|L1.1008|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000014  6809              LDR      r1,[r1,#0]
000016  f0210108          BIC      r1,r1,#8
00001a  4af5              LDR      r2,|L1.1008|
00001c  6011              STR      r1,[r2,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00001e  4611              MOV      r1,r2
000020  6809              LDR      r1,[r1,#0]
000022  4301              ORRS     r1,r1,r0
000024  6011              STR      r1,[r2,#0]
;;;159    }
000026  4770              BX       lr
;;;160    
                          ENDP

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000028  49f1              LDR      r1,|L1.1008|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
00002a  6809              LDR      r1,[r1,#0]
00002c  f0210110          BIC      r1,r1,#0x10
000030  4aef              LDR      r2,|L1.1008|
000032  6011              STR      r1,[r2,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
000034  4611              MOV      r1,r2
000036  6809              LDR      r1,[r1,#0]
000038  4301              ORRS     r1,r1,r0
00003a  6011              STR      r1,[r2,#0]
;;;177    }
00003c  4770              BX       lr
;;;178    
                          ENDP

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
00003e  48ed              LDR      r0,|L1.1012|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000040  49eb              LDR      r1,|L1.1008|
000042  6048              STR      r0,[r1,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000044  48ec              LDR      r0,|L1.1016|
000046  6048              STR      r0,[r1,#4]
;;;189    }
000048  4770              BX       lr
;;;190    
                          ENDP

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
00004a  48e9              LDR      r0,|L1.1008|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
00004c  6900              LDR      r0,[r0,#0x10]
00004e  f0400080          ORR      r0,r0,#0x80
000052  49e7              LDR      r1,|L1.1008|
000054  6108              STR      r0,[r1,#0x10]
;;;200    }
000056  4770              BX       lr
;;;201    
                          ENDP

                  FLASH_GetStatus PROC
;;;795      */
;;;796    FLASH_Status FLASH_GetStatus(void)
000058  2004              MOVS     r0,#4
;;;797    {
;;;798      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;799      
;;;800      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
00005a  49e5              LDR      r1,|L1.1008|
00005c  68c9              LDR      r1,[r1,#0xc]
00005e  f0010101          AND      r1,r1,#1
000062  2901              CMP      r1,#1
000064  d101              BNE      |L1.106|
;;;801      {
;;;802        flashstatus = FLASH_BUSY;
000066  2001              MOVS     r0,#1
000068  e00e              B        |L1.136|
                  |L1.106|
;;;803      }
;;;804      else 
;;;805      {  
;;;806        if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
00006a  49e1              LDR      r1,|L1.1008|
00006c  68c9              LDR      r1,[r1,#0xc]
00006e  f0110f04          TST      r1,#4
000072  d001              BEQ      |L1.120|
;;;807        { 
;;;808          flashstatus = FLASH_ERROR_PG;
000074  2002              MOVS     r0,#2
000076  e007              B        |L1.136|
                  |L1.120|
;;;809        }
;;;810        else 
;;;811        {
;;;812          if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
000078  49dd              LDR      r1,|L1.1008|
00007a  68c9              LDR      r1,[r1,#0xc]
00007c  f0110f10          TST      r1,#0x10
000080  d001              BEQ      |L1.134|
;;;813          {
;;;814            flashstatus = FLASH_ERROR_WRP;
000082  2003              MOVS     r0,#3
000084  e000              B        |L1.136|
                  |L1.134|
;;;815          }
;;;816          else
;;;817          {
;;;818            flashstatus = FLASH_COMPLETE;
000086  2004              MOVS     r0,#4
                  |L1.136|
;;;819          }
;;;820        }
;;;821      }
;;;822      /* Return the Flash Status */
;;;823      return flashstatus;
;;;824    }
000088  4770              BX       lr
;;;825    
                          ENDP

                  delay PROC
;;;857      */
;;;858    static void delay(void)
00008a  2000              MOVS     r0,#0
;;;859    {
;;;860      __IO uint32_t i = 0;
;;;861      for(i = 0xFF; i != 0; i--)
00008c  20ff              MOVS     r0,#0xff
00008e  e000              B        |L1.146|
                  |L1.144|
000090  1e40              SUBS     r0,r0,#1
                  |L1.146|
000092  2800              CMP      r0,#0
000094  d1fc              BNE      |L1.144|
;;;862      {
;;;863      }
;;;864    }
000096  4770              BX       lr
;;;865    
                          ENDP

                  FLASH_WaitForLastOperation PROC
;;;831      */
;;;832    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000098  b570              PUSH     {r4-r6,lr}
;;;833    { 
00009a  4604              MOV      r4,r0
;;;834      FLASH_Status status = FLASH_COMPLETE;
00009c  2504              MOVS     r5,#4
;;;835       
;;;836      /* Check for the Flash Status */
;;;837      status = FLASH_GetStatus();
00009e  f7fffffe          BL       FLASH_GetStatus
0000a2  4605              MOV      r5,r0
;;;838      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;839      while((status == FLASH_BUSY) && (Timeout != 0x00))
0000a4  e005              B        |L1.178|
                  |L1.166|
;;;840      {
;;;841        delay();
0000a6  f7fffffe          BL       delay
;;;842        status = FLASH_GetStatus();
0000aa  f7fffffe          BL       FLASH_GetStatus
0000ae  4605              MOV      r5,r0
;;;843        Timeout--;
0000b0  1e64              SUBS     r4,r4,#1
                  |L1.178|
0000b2  2d01              CMP      r5,#1                 ;839
0000b4  d101              BNE      |L1.186|
0000b6  2c00              CMP      r4,#0                 ;839
0000b8  d1f5              BNE      |L1.166|
                  |L1.186|
;;;844      }
;;;845      if(Timeout == 0x00 )
0000ba  b904              CBNZ     r4,|L1.190|
;;;846      {
;;;847        status = FLASH_TIMEOUT;
0000bc  2505              MOVS     r5,#5
                  |L1.190|
;;;848      }
;;;849      /* Return the operation status */
;;;850      return status;
0000be  4628              MOV      r0,r5
;;;851    }
0000c0  bd70              POP      {r4-r6,pc}
;;;852    
                          ENDP

                  FLASH_ErasePage PROC
;;;207      */
;;;208    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
0000c2  b570              PUSH     {r4-r6,lr}
;;;209    {
0000c4  4605              MOV      r5,r0
;;;210      FLASH_Status status = FLASH_COMPLETE;
0000c6  2404              MOVS     r4,#4
;;;211      /* Check the parameters */
;;;212      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;213      /* Wait for last operation to be completed */
;;;214      status = FLASH_WaitForLastOperation(EraseTimeout);
0000c8  f64070ff          MOV      r0,#0xfff
0000cc  f7fffffe          BL       FLASH_WaitForLastOperation
0000d0  4604              MOV      r4,r0
;;;215      
;;;216      if(status == FLASH_COMPLETE)
0000d2  2c04              CMP      r4,#4
0000d4  d119              BNE      |L1.266|
;;;217      { 
;;;218        /* if the previous operation is completed, proceed to erase the page */
;;;219        FLASH->CR|= CR_PER_Set;
0000d6  48c6              LDR      r0,|L1.1008|
0000d8  6900              LDR      r0,[r0,#0x10]
0000da  f0400002          ORR      r0,r0,#2
0000de  49c4              LDR      r1,|L1.1008|
0000e0  6108              STR      r0,[r1,#0x10]
;;;220        FLASH->AR = Page_Address; 
0000e2  4608              MOV      r0,r1
0000e4  6145              STR      r5,[r0,#0x14]
;;;221        FLASH->CR|= CR_STRT_Set;
0000e6  6900              LDR      r0,[r0,#0x10]
0000e8  f0400040          ORR      r0,r0,#0x40
0000ec  6108              STR      r0,[r1,#0x10]
;;;222        
;;;223        /* Wait for last operation to be completed */
;;;224        status = FLASH_WaitForLastOperation(EraseTimeout);
0000ee  f64070ff          MOV      r0,#0xfff
0000f2  f7fffffe          BL       FLASH_WaitForLastOperation
0000f6  4604              MOV      r4,r0
;;;225        if(status != FLASH_TIMEOUT)
0000f8  2c05              CMP      r4,#5
0000fa  d006              BEQ      |L1.266|
;;;226        {
;;;227          /* if the erase operation is completed, disable the PER Bit */
;;;228          FLASH->CR &= CR_PER_Reset;
0000fc  48bc              LDR      r0,|L1.1008|
0000fe  6900              LDR      r0,[r0,#0x10]
000100  f64171fd          MOV      r1,#0x1ffd
000104  4008              ANDS     r0,r0,r1
000106  49ba              LDR      r1,|L1.1008|
000108  6108              STR      r0,[r1,#0x10]
                  |L1.266|
;;;229        }
;;;230      }
;;;231      /* Return the Erase Status */
;;;232      return status;
00010a  4620              MOV      r0,r4
;;;233    }
00010c  bd70              POP      {r4-r6,pc}
;;;234    
                          ENDP

                  FLASH_EraseAllPages PROC
;;;240      */
;;;241    FLASH_Status FLASH_EraseAllPages(void)
00010e  b510              PUSH     {r4,lr}
;;;242    {
;;;243      FLASH_Status status = FLASH_COMPLETE;
000110  2404              MOVS     r4,#4
;;;244      /* Wait for last operation to be completed */
;;;245      status = FLASH_WaitForLastOperation(EraseTimeout);
000112  f64070ff          MOV      r0,#0xfff
000116  f7fffffe          BL       FLASH_WaitForLastOperation
00011a  4604              MOV      r4,r0
;;;246      
;;;247      if(status == FLASH_COMPLETE)
00011c  2c04              CMP      r4,#4
00011e  d118              BNE      |L1.338|
;;;248      {
;;;249        /* if the previous operation is completed, proceed to erase all pages */
;;;250         FLASH->CR |= CR_MER_Set;
000120  48b3              LDR      r0,|L1.1008|
000122  6900              LDR      r0,[r0,#0x10]
000124  f0400004          ORR      r0,r0,#4
000128  49b1              LDR      r1,|L1.1008|
00012a  6108              STR      r0,[r1,#0x10]
;;;251         FLASH->CR |= CR_STRT_Set;
00012c  4608              MOV      r0,r1
00012e  6900              LDR      r0,[r0,#0x10]
000130  f0400040          ORR      r0,r0,#0x40
000134  6108              STR      r0,[r1,#0x10]
;;;252        
;;;253        /* Wait for last operation to be completed */
;;;254        status = FLASH_WaitForLastOperation(EraseTimeout);
000136  f64070ff          MOV      r0,#0xfff
00013a  f7fffffe          BL       FLASH_WaitForLastOperation
00013e  4604              MOV      r4,r0
;;;255        if(status != FLASH_TIMEOUT)
000140  2c05              CMP      r4,#5
000142  d006              BEQ      |L1.338|
;;;256        {
;;;257          /* if the erase operation is completed, disable the MER Bit */
;;;258          FLASH->CR &= CR_MER_Reset;
000144  48aa              LDR      r0,|L1.1008|
000146  6900              LDR      r0,[r0,#0x10]
000148  f64171fb          MOV      r1,#0x1ffb
00014c  4008              ANDS     r0,r0,r1
00014e  49a8              LDR      r1,|L1.1008|
000150  6108              STR      r0,[r1,#0x10]
                  |L1.338|
;;;259        }
;;;260      }	   
;;;261      /* Return the Erase Status */
;;;262      return status;
000152  4620              MOV      r0,r4
;;;263    }
000154  bd10              POP      {r4,pc}
;;;264    
                          ENDP

                  FLASH_EraseOptionBytes PROC
;;;274      */
;;;275    FLASH_Status FLASH_EraseOptionBytes(void)
000156  b510              PUSH     {r4,lr}
;;;276    {
;;;277      FLASH_Status status = FLASH_COMPLETE;
000158  2404              MOVS     r4,#4
;;;278      
;;;279      /* Wait for last operation to be completed */
;;;280      status = FLASH_WaitForLastOperation(EraseTimeout);
00015a  f64070ff          MOV      r0,#0xfff
00015e  f7fffffe          BL       FLASH_WaitForLastOperation
000162  4604              MOV      r4,r0
;;;281      if(status == FLASH_COMPLETE)
000164  2c04              CMP      r4,#4
000166  d13c              BNE      |L1.482|
;;;282      {
;;;283        /* Authorize the small information block programming */
;;;284        FLASH->OPTKEYR = FLASH_KEY1;
000168  48a2              LDR      r0,|L1.1012|
00016a  49a1              LDR      r1,|L1.1008|
00016c  6088              STR      r0,[r1,#8]
;;;285        FLASH->OPTKEYR = FLASH_KEY2;
00016e  48a2              LDR      r0,|L1.1016|
000170  6088              STR      r0,[r1,#8]
;;;286        
;;;287        /* if the previous operation is completed, proceed to erase the option bytes */
;;;288        FLASH->CR |= CR_OPTER_Set;
000172  4608              MOV      r0,r1
000174  6900              LDR      r0,[r0,#0x10]
000176  f0400020          ORR      r0,r0,#0x20
00017a  6108              STR      r0,[r1,#0x10]
;;;289        FLASH->CR |= CR_STRT_Set;
00017c  4608              MOV      r0,r1
00017e  6900              LDR      r0,[r0,#0x10]
000180  f0400040          ORR      r0,r0,#0x40
000184  6108              STR      r0,[r1,#0x10]
;;;290        /* Wait for last operation to be completed */
;;;291        status = FLASH_WaitForLastOperation(EraseTimeout);
000186  f64070ff          MOV      r0,#0xfff
00018a  f7fffffe          BL       FLASH_WaitForLastOperation
00018e  4604              MOV      r4,r0
;;;292        
;;;293        if(status == FLASH_COMPLETE)
000190  2c04              CMP      r4,#4
000192  d11d              BNE      |L1.464|
;;;294        {
;;;295          /* if the erase operation is completed, disable the OPTER Bit */
;;;296          FLASH->CR &= CR_OPTER_Reset;
000194  4896              LDR      r0,|L1.1008|
000196  6900              LDR      r0,[r0,#0x10]
000198  f64171df          MOV      r1,#0x1fdf
00019c  4008              ANDS     r0,r0,r1
00019e  4994              LDR      r1,|L1.1008|
0001a0  6108              STR      r0,[r1,#0x10]
;;;297           
;;;298          /* Enable the Option Bytes Programming operation */
;;;299          FLASH->CR |= CR_OPTPG_Set;
0001a2  4608              MOV      r0,r1
0001a4  6900              LDR      r0,[r0,#0x10]
0001a6  f0400010          ORR      r0,r0,#0x10
0001aa  6108              STR      r0,[r1,#0x10]
;;;300          /* Disable the Read protection */
;;;301          OB->RDP= RDP_Key; 
0001ac  20a5              MOVS     r0,#0xa5
0001ae  4993              LDR      r1,|L1.1020|
0001b0  8008              STRH     r0,[r1,#0]
;;;302          /* Wait for last operation to be completed */
;;;303          status = FLASH_WaitForLastOperation(ProgramTimeout);
0001b2  f04f000f          MOV      r0,#0xf
0001b6  f7fffffe          BL       FLASH_WaitForLastOperation
0001ba  4604              MOV      r4,r0
;;;304     
;;;305          if(status != FLASH_TIMEOUT)
0001bc  2c05              CMP      r4,#5
0001be  d010              BEQ      |L1.482|
;;;306          {
;;;307            /* if the program operation is completed, disable the OPTPG Bit */
;;;308            FLASH->CR &= CR_OPTPG_Reset;
0001c0  488b              LDR      r0,|L1.1008|
0001c2  6900              LDR      r0,[r0,#0x10]
0001c4  f64171ef          MOV      r1,#0x1fef
0001c8  4008              ANDS     r0,r0,r1
0001ca  4989              LDR      r1,|L1.1008|
0001cc  6108              STR      r0,[r1,#0x10]
0001ce  e008              B        |L1.482|
                  |L1.464|
;;;309          }
;;;310        }
;;;311        else
;;;312        {
;;;313          if (status != FLASH_TIMEOUT)
0001d0  2c05              CMP      r4,#5
0001d2  d006              BEQ      |L1.482|
;;;314          {
;;;315            /* Disable the OPTPG Bit */
;;;316            FLASH->CR &= CR_OPTPG_Reset;
0001d4  4886              LDR      r0,|L1.1008|
0001d6  6900              LDR      r0,[r0,#0x10]
0001d8  f64171ef          MOV      r1,#0x1fef
0001dc  4008              ANDS     r0,r0,r1
0001de  4984              LDR      r1,|L1.1008|
0001e0  6108              STR      r0,[r1,#0x10]
                  |L1.482|
;;;317          }
;;;318        }  
;;;319      }
;;;320      /* Return the erase status */
;;;321      return status;
0001e2  4620              MOV      r0,r4
;;;322    }
0001e4  bd10              POP      {r4,pc}
;;;323    
                          ENDP

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
0001e6  e92d41f0          PUSH     {r4-r8,lr}
;;;332    {
0001ea  4605              MOV      r5,r0
0001ec  460e              MOV      r6,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
0001ee  2404              MOVS     r4,#4
;;;334      __IO uint32_t tmp = 0;
0001f0  2700              MOVS     r7,#0
;;;335    
;;;336      /* Check the parameters */
;;;337      assert_param(IS_FLASH_ADDRESS(Address));
;;;338      /* Wait for last operation to be completed */
;;;339      status = FLASH_WaitForLastOperation(ProgramTimeout);
0001f2  200f              MOVS     r0,#0xf
0001f4  f7fffffe          BL       FLASH_WaitForLastOperation
0001f8  4604              MOV      r4,r0
;;;340      
;;;341      if(status == FLASH_COMPLETE)
0001fa  2c04              CMP      r4,#4
0001fc  d126              BNE      |L1.588|
;;;342      {
;;;343        /* if the previous operation is completed, proceed to program the new first 
;;;344        half word */
;;;345        FLASH->CR |= CR_PG_Set;
0001fe  487c              LDR      r0,|L1.1008|
000200  6900              LDR      r0,[r0,#0x10]
000202  f0400001          ORR      r0,r0,#1
000206  497a              LDR      r1,|L1.1008|
000208  6108              STR      r0,[r1,#0x10]
;;;346      
;;;347        *(__IO uint16_t*)Address = (uint16_t)Data;
00020a  802e              STRH     r6,[r5,#0]
;;;348        /* Wait for last operation to be completed */
;;;349        status = FLASH_WaitForLastOperation(ProgramTimeout);
00020c  200f              MOVS     r0,#0xf
00020e  f7fffffe          BL       FLASH_WaitForLastOperation
000212  4604              MOV      r4,r0
;;;350     
;;;351        if(status == FLASH_COMPLETE)
000214  2c04              CMP      r4,#4
000216  d110              BNE      |L1.570|
;;;352        {
;;;353          /* if the previous operation is completed, proceed to program the new second 
;;;354          half word */
;;;355          tmp = Address + 2;
000218  1caf              ADDS     r7,r5,#2
;;;356    
;;;357          *(__IO uint16_t*) tmp = Data >> 16;
00021a  0c30              LSRS     r0,r6,#16
00021c  8038              STRH     r0,[r7,#0]
;;;358        
;;;359          /* Wait for last operation to be completed */
;;;360          status = FLASH_WaitForLastOperation(ProgramTimeout);
00021e  200f              MOVS     r0,#0xf
000220  f7fffffe          BL       FLASH_WaitForLastOperation
000224  4604              MOV      r4,r0
;;;361            
;;;362          if(status != FLASH_TIMEOUT)
000226  2c05              CMP      r4,#5
000228  d010              BEQ      |L1.588|
;;;363          {
;;;364            /* Disable the PG Bit */
;;;365            FLASH->CR &= CR_PG_Reset;
00022a  4871              LDR      r0,|L1.1008|
00022c  6900              LDR      r0,[r0,#0x10]
00022e  f64171fe          MOV      r1,#0x1ffe
000232  4008              ANDS     r0,r0,r1
000234  496e              LDR      r1,|L1.1008|
000236  6108              STR      r0,[r1,#0x10]
000238  e008              B        |L1.588|
                  |L1.570|
;;;366          }
;;;367        }
;;;368        else
;;;369        {
;;;370          if (status != FLASH_TIMEOUT)
00023a  2c05              CMP      r4,#5
00023c  d006              BEQ      |L1.588|
;;;371          {
;;;372            /* Disable the PG Bit */
;;;373            FLASH->CR &= CR_PG_Reset;
00023e  486c              LDR      r0,|L1.1008|
000240  6900              LDR      r0,[r0,#0x10]
000242  f64171fe          MOV      r1,#0x1ffe
000246  4008              ANDS     r0,r0,r1
000248  4969              LDR      r1,|L1.1008|
00024a  6108              STR      r0,[r1,#0x10]
                  |L1.588|
;;;374          }
;;;375         }
;;;376      }
;;;377      /* Return the Program Status */
;;;378      return status;
00024c  4620              MOV      r0,r4
;;;379    }
00024e  e8bd81f0          POP      {r4-r8,pc}
;;;380    
                          ENDP

                  FLASH_ProgramHalfWord PROC
;;;387      */
;;;388    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000252  b570              PUSH     {r4-r6,lr}
;;;389    {
000254  4605              MOV      r5,r0
000256  460e              MOV      r6,r1
;;;390      FLASH_Status status = FLASH_COMPLETE;
000258  2404              MOVS     r4,#4
;;;391      /* Check the parameters */
;;;392      assert_param(IS_FLASH_ADDRESS(Address));
;;;393      /* Wait for last operation to be completed */
;;;394      status = FLASH_WaitForLastOperation(ProgramTimeout);
00025a  200f              MOVS     r0,#0xf
00025c  f7fffffe          BL       FLASH_WaitForLastOperation
000260  4604              MOV      r4,r0
;;;395      
;;;396      if(status == FLASH_COMPLETE)
000262  2c04              CMP      r4,#4
000264  d113              BNE      |L1.654|
;;;397      {
;;;398        /* if the previous operation is completed, proceed to program the new data */
;;;399        FLASH->CR |= CR_PG_Set;
000266  4862              LDR      r0,|L1.1008|
000268  6900              LDR      r0,[r0,#0x10]
00026a  f0400001          ORR      r0,r0,#1
00026e  4960              LDR      r1,|L1.1008|
000270  6108              STR      r0,[r1,#0x10]
;;;400      
;;;401        *(__IO uint16_t*)Address = Data;
000272  802e              STRH     r6,[r5,#0]
;;;402        /* Wait for last operation to be completed */
;;;403        status = FLASH_WaitForLastOperation(ProgramTimeout);
000274  200f              MOVS     r0,#0xf
000276  f7fffffe          BL       FLASH_WaitForLastOperation
00027a  4604              MOV      r4,r0
;;;404        if(status != FLASH_TIMEOUT)
00027c  2c05              CMP      r4,#5
00027e  d006              BEQ      |L1.654|
;;;405        {
;;;406          /* if the program operation is completed, disable the PG Bit */
;;;407          FLASH->CR &= CR_PG_Reset;
000280  485b              LDR      r0,|L1.1008|
000282  6900              LDR      r0,[r0,#0x10]
000284  f64171fe          MOV      r1,#0x1ffe
000288  4008              ANDS     r0,r0,r1
00028a  4959              LDR      r1,|L1.1008|
00028c  6108              STR      r0,[r1,#0x10]
                  |L1.654|
;;;408        }
;;;409      } 
;;;410      /* Return the Program Status */
;;;411      return status;
00028e  4620              MOV      r0,r4
;;;412    }
000290  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  FLASH_ProgramOptionByteData PROC
;;;421      */
;;;422    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000292  b570              PUSH     {r4-r6,lr}
;;;423    {
000294  4605              MOV      r5,r0
000296  460e              MOV      r6,r1
;;;424      FLASH_Status status = FLASH_COMPLETE;
000298  2404              MOVS     r4,#4
;;;425      /* Check the parameters */
;;;426      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;427      status = FLASH_WaitForLastOperation(ProgramTimeout);
00029a  200f              MOVS     r0,#0xf
00029c  f7fffffe          BL       FLASH_WaitForLastOperation
0002a0  4604              MOV      r4,r0
;;;428      if(status == FLASH_COMPLETE)
0002a2  2c04              CMP      r4,#4
0002a4  d117              BNE      |L1.726|
;;;429      {
;;;430        /* Authorize the small information block programming */
;;;431        FLASH->OPTKEYR = FLASH_KEY1;
0002a6  4853              LDR      r0,|L1.1012|
0002a8  4951              LDR      r1,|L1.1008|
0002aa  6088              STR      r0,[r1,#8]
;;;432        FLASH->OPTKEYR = FLASH_KEY2;
0002ac  4852              LDR      r0,|L1.1016|
0002ae  6088              STR      r0,[r1,#8]
;;;433        /* Enables the Option Bytes Programming operation */
;;;434        FLASH->CR |= CR_OPTPG_Set; 
0002b0  4608              MOV      r0,r1
0002b2  6900              LDR      r0,[r0,#0x10]
0002b4  f0400010          ORR      r0,r0,#0x10
0002b8  6108              STR      r0,[r1,#0x10]
;;;435        *(__IO uint16_t*)Address = Data;
0002ba  802e              STRH     r6,[r5,#0]
;;;436        
;;;437        /* Wait for last operation to be completed */
;;;438        status = FLASH_WaitForLastOperation(ProgramTimeout);
0002bc  200f              MOVS     r0,#0xf
0002be  f7fffffe          BL       FLASH_WaitForLastOperation
0002c2  4604              MOV      r4,r0
;;;439        if(status != FLASH_TIMEOUT)
0002c4  2c05              CMP      r4,#5
0002c6  d006              BEQ      |L1.726|
;;;440        {
;;;441          /* if the program operation is completed, disable the OPTPG Bit */
;;;442          FLASH->CR &= CR_OPTPG_Reset;
0002c8  4849              LDR      r0,|L1.1008|
0002ca  6900              LDR      r0,[r0,#0x10]
0002cc  f64171ef          MOV      r1,#0x1fef
0002d0  4008              ANDS     r0,r0,r1
0002d2  4947              LDR      r1,|L1.1008|
0002d4  6108              STR      r0,[r1,#0x10]
                  |L1.726|
;;;443        }
;;;444      }    
;;;445      /* Return the Option Byte Data Program Status */
;;;446      return status;
0002d6  4620              MOV      r0,r4
;;;447    }
0002d8  bd70              POP      {r4-r6,pc}
;;;448    
                          ENDP

                  FLASH_EnableWriteProtection PROC
;;;463      */
;;;464    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
0002da  e92d47f0          PUSH     {r4-r10,lr}
;;;465    {
0002de  4604              MOV      r4,r0
;;;466      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
0002e0  f64f76ff          MOV      r6,#0xffff
0002e4  4637              MOV      r7,r6
0002e6  46b0              MOV      r8,r6
0002e8  46b1              MOV      r9,r6
;;;467      
;;;468      FLASH_Status status = FLASH_COMPLETE;
0002ea  2504              MOVS     r5,#4
;;;469      
;;;470      /* Check the parameters */
;;;471      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;472      
;;;473      FLASH_Pages = (uint32_t)(~FLASH_Pages);
0002ec  43e4              MVNS     r4,r4
;;;474      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
0002ee  b2e6              UXTB     r6,r4
;;;475      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
0002f0  f3c42707          UBFX     r7,r4,#8,#8
;;;476      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
0002f4  f3c44807          UBFX     r8,r4,#16,#8
;;;477      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
0002f8  ea4f6914          LSR      r9,r4,#24
;;;478      
;;;479      /* Wait for last operation to be completed */
;;;480      status = FLASH_WaitForLastOperation(ProgramTimeout);
0002fc  200f              MOVS     r0,#0xf
0002fe  f7fffffe          BL       FLASH_WaitForLastOperation
000302  4605              MOV      r5,r0
;;;481      
;;;482      if(status == FLASH_COMPLETE)
000304  2d04              CMP      r5,#4
000306  d13e              BNE      |L1.902|
;;;483      {
;;;484        /* Authorizes the small information block programming */
;;;485        FLASH->OPTKEYR = FLASH_KEY1;
000308  483a              LDR      r0,|L1.1012|
00030a  4939              LDR      r1,|L1.1008|
00030c  6088              STR      r0,[r1,#8]
;;;486        FLASH->OPTKEYR = FLASH_KEY2;
00030e  483a              LDR      r0,|L1.1016|
000310  6088              STR      r0,[r1,#8]
;;;487        FLASH->CR |= CR_OPTPG_Set;
000312  4608              MOV      r0,r1
000314  6900              LDR      r0,[r0,#0x10]
000316  f0400010          ORR      r0,r0,#0x10
00031a  6108              STR      r0,[r1,#0x10]
;;;488        if(WRP0_Data != 0xFF)
00031c  2eff              CMP      r6,#0xff
00031e  d006              BEQ      |L1.814|
;;;489        {
;;;490          OB->WRP0 = WRP0_Data;
000320  4837              LDR      r0,|L1.1024|
000322  8006              STRH     r6,[r0,#0]
;;;491          
;;;492          /* Wait for last operation to be completed */
;;;493          status = FLASH_WaitForLastOperation(ProgramTimeout);
000324  f04f000f          MOV      r0,#0xf
000328  f7fffffe          BL       FLASH_WaitForLastOperation
00032c  4605              MOV      r5,r0
                  |L1.814|
;;;494        }
;;;495        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
00032e  2d04              CMP      r5,#4
000330  d108              BNE      |L1.836|
000332  2fff              CMP      r7,#0xff
000334  d006              BEQ      |L1.836|
;;;496        {
;;;497          OB->WRP1 = WRP1_Data;
000336  4833              LDR      r0,|L1.1028|
000338  8007              STRH     r7,[r0,#0]
;;;498          
;;;499          /* Wait for last operation to be completed */
;;;500          status = FLASH_WaitForLastOperation(ProgramTimeout);
00033a  f04f000f          MOV      r0,#0xf
00033e  f7fffffe          BL       FLASH_WaitForLastOperation
000342  4605              MOV      r5,r0
                  |L1.836|
;;;501        }
;;;502        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000344  2d04              CMP      r5,#4
000346  d109              BNE      |L1.860|
000348  f1b80fff          CMP      r8,#0xff
00034c  d006              BEQ      |L1.860|
;;;503        {
;;;504          OB->WRP2 = WRP2_Data;
00034e  482e              LDR      r0,|L1.1032|
000350  f8a0880c          STRH     r8,[r0,#0x80c]
;;;505          
;;;506          /* Wait for last operation to be completed */
;;;507          status = FLASH_WaitForLastOperation(ProgramTimeout);
000354  200f              MOVS     r0,#0xf
000356  f7fffffe          BL       FLASH_WaitForLastOperation
00035a  4605              MOV      r5,r0
                  |L1.860|
;;;508        }
;;;509        
;;;510        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
00035c  2d04              CMP      r5,#4
00035e  d109              BNE      |L1.884|
000360  f1b90fff          CMP      r9,#0xff
000364  d006              BEQ      |L1.884|
;;;511        {
;;;512          OB->WRP3 = WRP3_Data;
000366  4828              LDR      r0,|L1.1032|
000368  f8a0980e          STRH     r9,[r0,#0x80e]
;;;513         
;;;514          /* Wait for last operation to be completed */
;;;515          status = FLASH_WaitForLastOperation(ProgramTimeout);
00036c  200f              MOVS     r0,#0xf
00036e  f7fffffe          BL       FLASH_WaitForLastOperation
000372  4605              MOV      r5,r0
                  |L1.884|
;;;516        }
;;;517              
;;;518        if(status != FLASH_TIMEOUT)
000374  2d05              CMP      r5,#5
000376  d006              BEQ      |L1.902|
;;;519        {
;;;520          /* if the program operation is completed, disable the OPTPG Bit */
;;;521          FLASH->CR &= CR_OPTPG_Reset;
000378  481d              LDR      r0,|L1.1008|
00037a  6900              LDR      r0,[r0,#0x10]
00037c  f64171ef          MOV      r1,#0x1fef
000380  4008              ANDS     r0,r0,r1
000382  491b              LDR      r1,|L1.1008|
000384  6108              STR      r0,[r1,#0x10]
                  |L1.902|
;;;522        }
;;;523      } 
;;;524      /* Return the write protection operation Status */
;;;525      return status;       
000386  4628              MOV      r0,r5
;;;526    }
000388  e8bd87f0          POP      {r4-r10,pc}
;;;527    
                          ENDP

                  FLASH_ReadOutProtection PROC
;;;536      */
;;;537    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
00038c  b570              PUSH     {r4-r6,lr}
;;;538    {
00038e  4605              MOV      r5,r0
;;;539      FLASH_Status status = FLASH_COMPLETE;
000390  2404              MOVS     r4,#4
;;;540      /* Check the parameters */
;;;541      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;542      status = FLASH_WaitForLastOperation(EraseTimeout);
000392  f64070ff          MOV      r0,#0xfff
000396  f7fffffe          BL       FLASH_WaitForLastOperation
00039a  4604              MOV      r4,r0
;;;543      if(status == FLASH_COMPLETE)
00039c  2c04              CMP      r4,#4
00039e  d150              BNE      |L1.1090|
;;;544      {
;;;545        /* Authorizes the small information block programming */
;;;546        FLASH->OPTKEYR = FLASH_KEY1;
0003a0  4814              LDR      r0,|L1.1012|
0003a2  4913              LDR      r1,|L1.1008|
0003a4  6088              STR      r0,[r1,#8]
;;;547        FLASH->OPTKEYR = FLASH_KEY2;
0003a6  4814              LDR      r0,|L1.1016|
0003a8  6088              STR      r0,[r1,#8]
;;;548        FLASH->CR |= CR_OPTER_Set;
0003aa  4608              MOV      r0,r1
0003ac  6900              LDR      r0,[r0,#0x10]
0003ae  f0400020          ORR      r0,r0,#0x20
0003b2  6108              STR      r0,[r1,#0x10]
;;;549        FLASH->CR |= CR_STRT_Set;
0003b4  4608              MOV      r0,r1
0003b6  6900              LDR      r0,[r0,#0x10]
0003b8  f0400040          ORR      r0,r0,#0x40
0003bc  6108              STR      r0,[r1,#0x10]
;;;550        /* Wait for last operation to be completed */
;;;551        status = FLASH_WaitForLastOperation(EraseTimeout);
0003be  f64070ff          MOV      r0,#0xfff
0003c2  f7fffffe          BL       FLASH_WaitForLastOperation
0003c6  4604              MOV      r4,r0
;;;552        if(status == FLASH_COMPLETE)
0003c8  2c04              CMP      r4,#4
0003ca  d131              BNE      |L1.1072|
;;;553        {
;;;554          /* if the erase operation is completed, disable the OPTER Bit */
;;;555          FLASH->CR &= CR_OPTER_Reset;
0003cc  4808              LDR      r0,|L1.1008|
0003ce  6900              LDR      r0,[r0,#0x10]
0003d0  f64171df          MOV      r1,#0x1fdf
0003d4  4008              ANDS     r0,r0,r1
0003d6  4906              LDR      r1,|L1.1008|
0003d8  6108              STR      r0,[r1,#0x10]
;;;556          /* Enable the Option Bytes Programming operation */
;;;557          FLASH->CR |= CR_OPTPG_Set; 
0003da  4608              MOV      r0,r1
0003dc  6900              LDR      r0,[r0,#0x10]
0003de  f0400010          ORR      r0,r0,#0x10
0003e2  6108              STR      r0,[r1,#0x10]
;;;558          if(NewState != DISABLE)
0003e4  b195              CBZ      r5,|L1.1036|
;;;559          {
;;;560            OB->RDP = 0x00;
0003e6  2000              MOVS     r0,#0
0003e8  4904              LDR      r1,|L1.1020|
0003ea  8008              STRH     r0,[r1,#0]
0003ec  e011              B        |L1.1042|
0003ee  0000              DCW      0x0000
                  |L1.1008|
                          DCD      0x40022000
                  |L1.1012|
                          DCD      0x45670123
                  |L1.1016|
                          DCD      0xcdef89ab
                  |L1.1020|
                          DCD      0x1ffff800
                  |L1.1024|
                          DCD      0x1ffff808
                  |L1.1028|
                          DCD      0x1ffff80a
                  |L1.1032|
                          DCD      0x1ffff000
                  |L1.1036|
;;;561          }
;;;562          else
;;;563          {
;;;564            OB->RDP = RDP_Key;  
00040c  20a5              MOVS     r0,#0xa5
00040e  4945              LDR      r1,|L1.1316|
000410  8008              STRH     r0,[r1,#0]
                  |L1.1042|
;;;565          }
;;;566          /* Wait for last operation to be completed */
;;;567          status = FLASH_WaitForLastOperation(EraseTimeout); 
000412  f64070ff          MOV      r0,#0xfff
000416  f7fffffe          BL       FLASH_WaitForLastOperation
00041a  4604              MOV      r4,r0
;;;568        
;;;569          if(status != FLASH_TIMEOUT)
00041c  2c05              CMP      r4,#5
00041e  d010              BEQ      |L1.1090|
;;;570          {
;;;571            /* if the program operation is completed, disable the OPTPG Bit */
;;;572            FLASH->CR &= CR_OPTPG_Reset;
000420  4841              LDR      r0,|L1.1320|
000422  6900              LDR      r0,[r0,#0x10]
000424  f64171ef          MOV      r1,#0x1fef
000428  4008              ANDS     r0,r0,r1
00042a  493f              LDR      r1,|L1.1320|
00042c  6108              STR      r0,[r1,#0x10]
00042e  e008              B        |L1.1090|
                  |L1.1072|
;;;573          }
;;;574        }
;;;575        else 
;;;576        {
;;;577          if(status != FLASH_TIMEOUT)
000430  2c05              CMP      r4,#5
000432  d006              BEQ      |L1.1090|
;;;578          {
;;;579            /* Disable the OPTER Bit */
;;;580            FLASH->CR &= CR_OPTER_Reset;
000434  483c              LDR      r0,|L1.1320|
000436  6900              LDR      r0,[r0,#0x10]
000438  f64171df          MOV      r1,#0x1fdf
00043c  4008              ANDS     r0,r0,r1
00043e  493a              LDR      r1,|L1.1320|
000440  6108              STR      r0,[r1,#0x10]
                  |L1.1090|
;;;581          }
;;;582        }
;;;583      }
;;;584      /* Return the protection operation Status */
;;;585      return status;      
000442  4620              MOV      r0,r4
;;;586    }
000444  bd70              POP      {r4-r6,pc}
;;;587    
                          ENDP

                  FLASH_UserOptionByteConfig PROC
;;;604      */
;;;605    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000446  e92d41f0          PUSH     {r4-r8,lr}
;;;606    {
00044a  4605              MOV      r5,r0
00044c  460e              MOV      r6,r1
00044e  4617              MOV      r7,r2
;;;607      FLASH_Status status = FLASH_COMPLETE; 
000450  2404              MOVS     r4,#4
;;;608    
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613    
;;;614      /* Authorize the small information block programming */
;;;615      FLASH->OPTKEYR = FLASH_KEY1;
000452  4836              LDR      r0,|L1.1324|
000454  4934              LDR      r1,|L1.1320|
000456  6088              STR      r0,[r1,#8]
;;;616      FLASH->OPTKEYR = FLASH_KEY2;
000458  4835              LDR      r0,|L1.1328|
00045a  6088              STR      r0,[r1,#8]
;;;617      
;;;618      /* Wait for last operation to be completed */
;;;619      status = FLASH_WaitForLastOperation(ProgramTimeout);
00045c  200f              MOVS     r0,#0xf
00045e  f7fffffe          BL       FLASH_WaitForLastOperation
000462  4604              MOV      r4,r0
;;;620      
;;;621      if(status == FLASH_COMPLETE)
000464  2c04              CMP      r4,#4
000466  d119              BNE      |L1.1180|
;;;622      {  
;;;623        /* Enable the Option Bytes Programming operation */
;;;624        FLASH->CR |= CR_OPTPG_Set; 
000468  482f              LDR      r0,|L1.1320|
00046a  6900              LDR      r0,[r0,#0x10]
00046c  f0400010          ORR      r0,r0,#0x10
000470  492d              LDR      r1,|L1.1320|
000472  6108              STR      r0,[r1,#0x10]
;;;625               
;;;626        OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
000474  f04700f8          ORR      r0,r7,#0xf8
000478  4330              ORRS     r0,r0,r6
00047a  4328              ORRS     r0,r0,r5
00047c  492d              LDR      r1,|L1.1332|
00047e  8008              STRH     r0,[r1,#0]
;;;627      
;;;628        /* Wait for last operation to be completed */
;;;629        status = FLASH_WaitForLastOperation(ProgramTimeout);
000480  f04f000f          MOV      r0,#0xf
000484  f7fffffe          BL       FLASH_WaitForLastOperation
000488  4604              MOV      r4,r0
;;;630        if(status != FLASH_TIMEOUT)
00048a  2c05              CMP      r4,#5
00048c  d006              BEQ      |L1.1180|
;;;631        {
;;;632          /* if the program operation is completed, disable the OPTPG Bit */
;;;633          FLASH->CR &= CR_OPTPG_Reset;
00048e  4826              LDR      r0,|L1.1320|
000490  6900              LDR      r0,[r0,#0x10]
000492  f64171ef          MOV      r1,#0x1fef
000496  4008              ANDS     r0,r0,r1
000498  4923              LDR      r1,|L1.1320|
00049a  6108              STR      r0,[r1,#0x10]
                  |L1.1180|
;;;634        }
;;;635      }    
;;;636      /* Return the Option Byte program Status */
;;;637      return status;
00049c  4620              MOV      r0,r4
;;;638    }
00049e  e8bd81f0          POP      {r4-r8,pc}
;;;639    
                          ENDP

                  FLASH_GetUserOptionByte PROC
;;;645      */
;;;646    uint32_t FLASH_GetUserOptionByte(void)
0004a2  4821              LDR      r0,|L1.1320|
;;;647    {
;;;648      /* Return the User Option Byte */
;;;649      return (uint32_t)(FLASH->OBR >> 2);
0004a4  69c0              LDR      r0,[r0,#0x1c]
0004a6  0880              LSRS     r0,r0,#2
;;;650    }
0004a8  4770              BX       lr
;;;651    
                          ENDP

                  FLASH_GetWriteProtectionOptionByte PROC
;;;656      */
;;;657    uint32_t FLASH_GetWriteProtectionOptionByte(void)
0004aa  481f              LDR      r0,|L1.1320|
;;;658    {
;;;659      /* Return the Falsh write protection Register value */
;;;660      return (uint32_t)(FLASH->WRPR);
0004ac  6a00              LDR      r0,[r0,#0x20]
;;;661    }
0004ae  4770              BX       lr
;;;662    
                          ENDP

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
0004b0  2000              MOVS     r0,#0
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
0004b2  491d              LDR      r1,|L1.1320|
0004b4  69c9              LDR      r1,[r1,#0x1c]
0004b6  f0110f02          TST      r1,#2
0004ba  d001              BEQ      |L1.1216|
;;;672      {
;;;673        readoutstatus = SET;
0004bc  2001              MOVS     r0,#1
0004be  e000              B        |L1.1218|
                  |L1.1216|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
0004c0  2000              MOVS     r0,#0
                  |L1.1218|
;;;678      }
;;;679      return readoutstatus;
;;;680    }
0004c2  4770              BX       lr
;;;681    
                          ENDP

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
0004c4  2000              MOVS     r0,#0
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
0004c6  4918              LDR      r1,|L1.1320|
0004c8  6809              LDR      r1,[r1,#0]
0004ca  f0110f20          TST      r1,#0x20
0004ce  d001              BEQ      |L1.1236|
;;;692      {
;;;693        bitstatus = SET;
0004d0  2001              MOVS     r0,#1
0004d2  e000              B        |L1.1238|
                  |L1.1236|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
0004d4  2000              MOVS     r0,#0
                  |L1.1238|
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
0004d6  4770              BX       lr
;;;702    
                          ENDP

                  FLASH_ITConfig PROC
;;;712      */
;;;713    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
0004d8  b129              CBZ      r1,|L1.1254|
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;717      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;718      if(NewState != DISABLE)
;;;719      {
;;;720        /* Enable the interrupt sources */
;;;721        FLASH->CR |= FLASH_IT;
0004da  4a13              LDR      r2,|L1.1320|
0004dc  6912              LDR      r2,[r2,#0x10]
0004de  4302              ORRS     r2,r2,r0
0004e0  4b11              LDR      r3,|L1.1320|
0004e2  611a              STR      r2,[r3,#0x10]
0004e4  e004              B        |L1.1264|
                  |L1.1254|
;;;722      }
;;;723      else
;;;724      {
;;;725        /* Disable the interrupt sources */
;;;726        FLASH->CR &= ~(uint32_t)FLASH_IT;
0004e6  4a10              LDR      r2,|L1.1320|
0004e8  6912              LDR      r2,[r2,#0x10]
0004ea  4382              BICS     r2,r2,r0
0004ec  4b0e              LDR      r3,|L1.1320|
0004ee  611a              STR      r2,[r3,#0x10]
                  |L1.1264|
;;;727      }
;;;728    }
0004f0  4770              BX       lr
;;;729    
                          ENDP

                  FLASH_GetFlagStatus PROC
;;;740      */
;;;741    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
0004f2  4601              MOV      r1,r0
;;;742    {
;;;743      FlagStatus bitstatus = RESET;
0004f4  2000              MOVS     r0,#0
;;;744      /* Check the parameters */
;;;745      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;746      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
0004f6  2901              CMP      r1,#1
0004f8  d108              BNE      |L1.1292|
;;;747      {
;;;748        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
0004fa  4a0b              LDR      r2,|L1.1320|
0004fc  69d2              LDR      r2,[r2,#0x1c]
0004fe  f0120f01          TST      r2,#1
000502  d001              BEQ      |L1.1288|
;;;749        {
;;;750          bitstatus = SET;
000504  2001              MOVS     r0,#1
000506  e008              B        |L1.1306|
                  |L1.1288|
;;;751        }
;;;752        else
;;;753        {
;;;754          bitstatus = RESET;
000508  2000              MOVS     r0,#0
00050a  e006              B        |L1.1306|
                  |L1.1292|
;;;755        }
;;;756      }
;;;757      else
;;;758      {
;;;759       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
00050c  4a06              LDR      r2,|L1.1320|
00050e  68d2              LDR      r2,[r2,#0xc]
000510  420a              TST      r2,r1
000512  d001              BEQ      |L1.1304|
;;;760        {
;;;761          bitstatus = SET;
000514  2001              MOVS     r0,#1
000516  e000              B        |L1.1306|
                  |L1.1304|
;;;762        }
;;;763        else
;;;764        {
;;;765          bitstatus = RESET;
000518  2000              MOVS     r0,#0
                  |L1.1306|
;;;766        }
;;;767      }
;;;768      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;769      return bitstatus;
;;;770    }
00051a  4770              BX       lr
;;;771    
                          ENDP

                  FLASH_ClearFlag PROC
;;;780      */
;;;781    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
00051c  4902              LDR      r1,|L1.1320|
;;;782    {
;;;783      /* Check the parameters */
;;;784      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;785      
;;;786      /* Clear the flags */
;;;787      FLASH->SR = FLASH_FLAG;
00051e  60c8              STR      r0,[r1,#0xc]
;;;788    }
000520  4770              BX       lr
;;;789    
                          ENDP

000522  0000              DCW      0x0000
                  |L1.1316|
                          DCD      0x1ffff800
                  |L1.1320|
                          DCD      0x40022000
                  |L1.1324|
                          DCD      0x45670123
                  |L1.1328|
                          DCD      0xcdef89ab
                  |L1.1332|
                          DCD      0x1ffff802
