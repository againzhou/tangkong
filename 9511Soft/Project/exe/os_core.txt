; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\os_core.o --depend=.\exe\os_core.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\os_core.crf ..\Source\OS\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  OS_StrCopy PROC
;;;1707   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1708   INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
000000  4602              MOV      r2,r0
;;;1709   {
;;;1710       INT8U  len;
;;;1711   
;;;1712   
;;;1713       len = 0;
000002  2000              MOVS     r0,#0
;;;1714       while (*psrc != OS_ASCII_NUL) {
000004  e005              B        |L1.18|
                  |L1.6|
;;;1715           *pdest++ = *psrc++;
000006  f8113b01          LDRB     r3,[r1],#1
00000a  f8023b01          STRB     r3,[r2],#1
;;;1716           len++;
00000e  1c43              ADDS     r3,r0,#1
000010  b2d8              UXTB     r0,r3
                  |L1.18|
000012  780b              LDRB     r3,[r1,#0]            ;1714
000014  2b00              CMP      r3,#0                 ;1714
000016  d1f6              BNE      |L1.6|
;;;1717       }
;;;1718       *pdest = OS_ASCII_NUL;
000018  7013              STRB     r3,[r2,#0]
;;;1719       return (len);
;;;1720   }
00001a  4770              BX       lr
;;;1721   #endif
                          ENDP

                  OSEventNameGet PROC
;;;108    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;109    INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
00001c  e92d41f0          PUSH     {r4-r8,lr}
;;;110    {
000020  4605              MOV      r5,r0
000022  460e              MOV      r6,r1
000024  4614              MOV      r4,r2
;;;111        INT8U      len;
;;;112    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;113        OS_CPU_SR  cpu_sr = 0;
000026  2700              MOVS     r7,#0
;;;114    #endif
;;;115    
;;;116    
;;;117    
;;;118    #if OS_ARG_CHK_EN > 0
;;;119        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
000028  b914              CBNZ     r4,|L1.48|
;;;120            return (0);
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;121        }
;;;122        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;123            *perr = OS_ERR_PEVENT_NULL;
;;;124            return (0);
;;;125        }
;;;126        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;127            *perr = OS_ERR_PNAME_NULL;
;;;128            return (0);
;;;129        }
;;;130    #endif
;;;131        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;132            *perr  = OS_ERR_NAME_GET_ISR;
;;;133            return (0);
;;;134        }
;;;135        switch (pevent->OSEventType) {
;;;136            case OS_EVENT_TYPE_SEM:
;;;137            case OS_EVENT_TYPE_MUTEX:
;;;138            case OS_EVENT_TYPE_MBOX:
;;;139            case OS_EVENT_TYPE_Q:
;;;140                 break;
;;;141    
;;;142            default:
;;;143                 *perr = OS_ERR_EVENT_TYPE;
;;;144                 return (0);
;;;145        }
;;;146        OS_ENTER_CRITICAL();
;;;147        len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
;;;148        OS_EXIT_CRITICAL();
;;;149        *perr = OS_ERR_NONE;
;;;150        return (len);
;;;151    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.48|
000030  b91d              CBNZ     r5,|L1.58|
000032  2004              MOVS     r0,#4                 ;123
000034  7020              STRB     r0,[r4,#0]            ;123
000036  2000              MOVS     r0,#0                 ;124
000038  e7f8              B        |L1.44|
                  |L1.58|
00003a  b91e              CBNZ     r6,|L1.68|
00003c  200c              MOVS     r0,#0xc               ;127
00003e  7020              STRB     r0,[r4,#0]            ;127
000040  2000              MOVS     r0,#0                 ;128
000042  e7f3              B        |L1.44|
                  |L1.68|
000044  48ff              LDR      r0,|L1.1092|
000046  7800              LDRB     r0,[r0,#0]            ;131  ; OSIntNesting
000048  2800              CMP      r0,#0                 ;131
00004a  dd03              BLE      |L1.84|
00004c  2011              MOVS     r0,#0x11              ;132
00004e  7020              STRB     r0,[r4,#0]            ;132
000050  2000              MOVS     r0,#0                 ;133
000052  e7eb              B        |L1.44|
                  |L1.84|
000054  7828              LDRB     r0,[r5,#0]            ;135
000056  2801              CMP      r0,#1                 ;135
000058  d008              BEQ      |L1.108|
00005a  2802              CMP      r0,#2                 ;135
00005c  d007              BEQ      |L1.110|
00005e  2803              CMP      r0,#3                 ;135
000060  d002              BEQ      |L1.104|
000062  2804              CMP      r0,#4                 ;135
000064  d104              BNE      |L1.112|
000066  e000              B        |L1.106|
                  |L1.104|
000068  bf00              NOP                            ;137
                  |L1.106|
00006a  bf00              NOP                            ;138
                  |L1.108|
00006c  bf00              NOP                            ;139
                  |L1.110|
00006e  e003              B        |L1.120|
                  |L1.112|
000070  2001              MOVS     r0,#1                 ;143
000072  7020              STRB     r0,[r4,#0]            ;143
000074  2000              MOVS     r0,#0                 ;144
000076  e7d9              B        |L1.44|
                  |L1.120|
000078  bf00              NOP                            ;140
00007a  f7fffffe          BL       OS_CPU_SR_Save
00007e  4607              MOV      r7,r0                 ;146
000080  f105010f          ADD      r1,r5,#0xf            ;147
000084  4630              MOV      r0,r6                 ;147
000086  f7fffffe          BL       OS_StrCopy
00008a  4680              MOV      r8,r0                 ;147
00008c  4638              MOV      r0,r7                 ;148
00008e  f7fffffe          BL       OS_CPU_SR_Restore
000092  2000              MOVS     r0,#0                 ;149
000094  7020              STRB     r0,[r4,#0]            ;149
000096  4640              MOV      r0,r8                 ;150
000098  e7c8              B        |L1.44|
;;;152    #endif
                          ENDP

                  OS_StrLen PROC
;;;1739   #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
;;;1740   INT8U  OS_StrLen (INT8U *psrc)
00009a  4601              MOV      r1,r0
;;;1741   {
;;;1742       INT8U  len;
;;;1743   
;;;1744   
;;;1745       len = 0;
00009c  2000              MOVS     r0,#0
;;;1746       while (*psrc != OS_ASCII_NUL) {
00009e  e002              B        |L1.166|
                  |L1.160|
;;;1747           psrc++;
0000a0  1c49              ADDS     r1,r1,#1
;;;1748           len++;
0000a2  1c42              ADDS     r2,r0,#1
0000a4  b2d0              UXTB     r0,r2
                  |L1.166|
0000a6  780a              LDRB     r2,[r1,#0]            ;1746
0000a8  2a00              CMP      r2,#0                 ;1746
0000aa  d1f9              BNE      |L1.160|
;;;1749       }
;;;1750       return (len);
;;;1751   }
0000ac  4770              BX       lr
;;;1752   #endif
                          ENDP

                  OSEventNameSet PROC
;;;182    #if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
;;;183    void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
0000ae  e92d41f0          PUSH     {r4-r8,lr}
;;;184    {
0000b2  4605              MOV      r5,r0
0000b4  460e              MOV      r6,r1
0000b6  4614              MOV      r4,r2
;;;185        INT8U      len;
;;;186    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;187        OS_CPU_SR  cpu_sr = 0;
0000b8  f04f0800          MOV      r8,#0
;;;188    #endif
;;;189    
;;;190    
;;;191    
;;;192    #if OS_ARG_CHK_EN > 0
;;;193        if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
0000bc  b90c              CBNZ     r4,|L1.194|
                  |L1.190|
;;;194            return;
;;;195        }
;;;196        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
;;;197            *perr = OS_ERR_PEVENT_NULL;
;;;198            return;
;;;199        }
;;;200        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
;;;201            *perr = OS_ERR_PNAME_NULL;
;;;202            return;
;;;203        }
;;;204    #endif
;;;205        if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
;;;206            *perr = OS_ERR_NAME_SET_ISR;
;;;207            return;
;;;208        }
;;;209        switch (pevent->OSEventType) {
;;;210            case OS_EVENT_TYPE_SEM:
;;;211            case OS_EVENT_TYPE_MUTEX:
;;;212            case OS_EVENT_TYPE_MBOX:
;;;213            case OS_EVENT_TYPE_Q:
;;;214                 break;
;;;215    
;;;216            default:
;;;217                 *perr = OS_ERR_EVENT_TYPE;
;;;218                 return;
;;;219        }
;;;220        OS_ENTER_CRITICAL();
;;;221        len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
;;;222        if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
;;;223            OS_EXIT_CRITICAL();
;;;224            *perr = OS_ERR_EVENT_NAME_TOO_LONG;
;;;225            return;
;;;226        }
;;;227        (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
;;;228        OS_EXIT_CRITICAL();
;;;229        *perr = OS_ERR_NONE;
;;;230    }
0000be  e8bd81f0          POP      {r4-r8,pc}
                  |L1.194|
0000c2  b915              CBNZ     r5,|L1.202|
0000c4  2004              MOVS     r0,#4                 ;197
0000c6  7020              STRB     r0,[r4,#0]            ;197
0000c8  e7f9              B        |L1.190|
                  |L1.202|
0000ca  b916              CBNZ     r6,|L1.210|
0000cc  200c              MOVS     r0,#0xc               ;201
0000ce  7020              STRB     r0,[r4,#0]            ;201
0000d0  e7f5              B        |L1.190|
                  |L1.210|
0000d2  48dc              LDR      r0,|L1.1092|
0000d4  7800              LDRB     r0,[r0,#0]            ;205  ; OSIntNesting
0000d6  2800              CMP      r0,#0                 ;205
0000d8  dd02              BLE      |L1.224|
0000da  2012              MOVS     r0,#0x12              ;206
0000dc  7020              STRB     r0,[r4,#0]            ;206
0000de  e7ee              B        |L1.190|
                  |L1.224|
0000e0  7828              LDRB     r0,[r5,#0]            ;209
0000e2  2801              CMP      r0,#1                 ;209
0000e4  d008              BEQ      |L1.248|
0000e6  2802              CMP      r0,#2                 ;209
0000e8  d007              BEQ      |L1.250|
0000ea  2803              CMP      r0,#3                 ;209
0000ec  d002              BEQ      |L1.244|
0000ee  2804              CMP      r0,#4                 ;209
0000f0  d104              BNE      |L1.252|
0000f2  e000              B        |L1.246|
                  |L1.244|
0000f4  bf00              NOP                            ;211
                  |L1.246|
0000f6  bf00              NOP                            ;212
                  |L1.248|
0000f8  bf00              NOP                            ;213
                  |L1.250|
0000fa  e002              B        |L1.258|
                  |L1.252|
0000fc  2001              MOVS     r0,#1                 ;217
0000fe  7020              STRB     r0,[r4,#0]            ;217
000100  e7dd              B        |L1.190|
                  |L1.258|
000102  bf00              NOP                            ;214
000104  f7fffffe          BL       OS_CPU_SR_Save
000108  4680              MOV      r8,r0                 ;220
00010a  4630              MOV      r0,r6                 ;221
00010c  f7fffffe          BL       OS_StrLen
000110  4607              MOV      r7,r0                 ;221
000112  2f0f              CMP      r7,#0xf               ;222
000114  dd05              BLE      |L1.290|
000116  4640              MOV      r0,r8                 ;223
000118  f7fffffe          BL       OS_CPU_SR_Restore
00011c  200b              MOVS     r0,#0xb               ;224
00011e  7020              STRB     r0,[r4,#0]            ;224
000120  e7cd              B        |L1.190|
                  |L1.290|
000122  4631              MOV      r1,r6                 ;227
000124  f105000f          ADD      r0,r5,#0xf            ;227
000128  f7fffffe          BL       OS_StrCopy
00012c  4640              MOV      r0,r8                 ;228
00012e  f7fffffe          BL       OS_CPU_SR_Restore
000132  2000              MOVS     r0,#0                 ;229
000134  7020              STRB     r0,[r4,#0]            ;229
000136  bf00              NOP      
000138  e7c1              B        |L1.190|
;;;231    #endif
                          ENDP

                  OS_EventTaskRemoveMulti PROC
;;;1169   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1170   void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
00013a  b5f0              PUSH     {r4-r7,lr}
;;;1171                                  OS_EVENT **pevents_multi)
;;;1172   {
00013c  4602              MOV      r2,r0
;;;1173       OS_EVENT **pevents;
;;;1174       OS_EVENT  *pevent;
;;;1175       INT8U      y;
;;;1176   #if (OS_LOWEST_PRIO <= 63)
;;;1177       INT8U      bity;
;;;1178       INT8U      bitx;
;;;1179   #else
;;;1180       INT16U     bity;
;;;1181       INT16U     bitx;
;;;1182   #endif
;;;1183   
;;;1184   
;;;1185       y       =  ptcb->OSTCBY;
00013e  f8124f34          LDRB     r4,[r2,#0x34]!
;;;1186       bity    =  ptcb->OSTCBBitY;
000142  7895              LDRB     r5,[r2,#2]
;;;1187       bitx    =  ptcb->OSTCBBitX;
000144  7856              LDRB     r6,[r2,#1]
000146  f1a20234          SUB      r2,r2,#0x34
;;;1188       pevents =  pevents_multi;
00014a  460b              MOV      r3,r1
;;;1189       pevent  = *pevents;
00014c  6818              LDR      r0,[r3,#0]
;;;1190       while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
00014e  e00f              B        |L1.368|
                  |L1.336|
;;;1191           pevent->OSEventTbl[y]  &= ~bitx;
000150  f100070b          ADD      r7,r0,#0xb
000154  5d3f              LDRB     r7,[r7,r4]
000156  43b7              BICS     r7,r7,r6
000158  f1000c0b          ADD      r12,r0,#0xb
00015c  f80c7004          STRB     r7,[r12,r4]
;;;1192           if (pevent->OSEventTbl[y] == 0) {
000160  4667              MOV      r7,r12
000162  5d3f              LDRB     r7,[r7,r4]
000164  b917              CBNZ     r7,|L1.364|
;;;1193               pevent->OSEventGrp &= ~bity;
000166  7a87              LDRB     r7,[r0,#0xa]
000168  43af              BICS     r7,r7,r5
00016a  7287              STRB     r7,[r0,#0xa]
                  |L1.364|
;;;1194           }
;;;1195           pevents++;
00016c  1d1b              ADDS     r3,r3,#4
;;;1196           pevent = *pevents;
00016e  6818              LDR      r0,[r3,#0]
                  |L1.368|
000170  2800              CMP      r0,#0                 ;1190
000172  d1ed              BNE      |L1.336|
;;;1197       }
;;;1198   }
000174  bdf0              POP      {r4-r7,pc}
;;;1199   #endif
                          ENDP

                  OS_SchedNew PROC
;;;1659   
;;;1660   static  void  OS_SchedNew (void)
000176  49b4              LDR      r1,|L1.1096|
;;;1661   {
;;;1662   #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
;;;1663       INT8U   y;
;;;1664   
;;;1665   
;;;1666       y             = OSUnMapTbl[OSRdyGrp];
000178  4ab4              LDR      r2,|L1.1100|
00017a  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
00017c  5c88              LDRB     r0,[r1,r2]
;;;1667       OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
00017e  49b4              LDR      r1,|L1.1104|
000180  5c09              LDRB     r1,[r1,r0]
000182  4ab1              LDR      r2,|L1.1096|
000184  5c51              LDRB     r1,[r2,r1]
000186  eb0101c0          ADD      r1,r1,r0,LSL #3
00018a  4ab2              LDR      r2,|L1.1108|
00018c  7011              STRB     r1,[r2,#0]
;;;1668   #else                                            /* We support up to 256 tasks                         */
;;;1669       INT8U   y;
;;;1670       INT16U *ptbl;
;;;1671   
;;;1672   
;;;1673       if ((OSRdyGrp & 0xFF) != 0) {
;;;1674           y = OSUnMapTbl[OSRdyGrp & 0xFF];
;;;1675       } else {
;;;1676           y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
;;;1677       }
;;;1678       ptbl = &OSRdyTbl[y];
;;;1679       if ((*ptbl & 0xFF) != 0) {
;;;1680           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
;;;1681       } else {
;;;1682           OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
;;;1683       }
;;;1684   #endif
;;;1685   }
00018e  4770              BX       lr
;;;1686   
                          ENDP

                  OS_Sched PROC
;;;1611   
;;;1612   void  OS_Sched (void)
000190  b510              PUSH     {r4,lr}
;;;1613   {
;;;1614   #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
;;;1615       OS_CPU_SR  cpu_sr = 0;
000192  2400              MOVS     r4,#0
;;;1616   #endif
;;;1617   
;;;1618   
;;;1619   
;;;1620       OS_ENTER_CRITICAL();
000194  f7fffffe          BL       OS_CPU_SR_Save
000198  4604              MOV      r4,r0
;;;1621       if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
00019a  48aa              LDR      r0,|L1.1092|
00019c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00019e  b9f8              CBNZ     r0,|L1.480|
;;;1622           if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
0001a0  48ad              LDR      r0,|L1.1112|
0001a2  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
0001a4  b9e0              CBNZ     r0,|L1.480|
;;;1623               OS_SchedNew();
0001a6  f7fffffe          BL       OS_SchedNew
;;;1624               
;;;1625   /// ------- cy 101007   debug to V2.88  -------
;;;1626   //            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
;;;1627   //                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
;;;1628               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
0001aa  48ac              LDR      r0,|L1.1116|
0001ac  49a9              LDR      r1,|L1.1108|
0001ae  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
0001b0  f8500021          LDR      r0,[r0,r1,LSL #2]
0001b4  49aa              LDR      r1,|L1.1120|
0001b6  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;1629               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
0001b8  48a6              LDR      r0,|L1.1108|
0001ba  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
0001bc  49a9              LDR      r1,|L1.1124|
0001be  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
0001c0  4288              CMP      r0,r1
0001c2  d00d              BEQ      |L1.480|
;;;1630   /// ------- cy 101007   debug to V2.88  -------
;;;1631                   
;;;1632   #if OS_TASK_PROFILE_EN > 0
;;;1633                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
0001c4  48a6              LDR      r0,|L1.1120|
0001c6  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
0001c8  6b80              LDR      r0,[r0,#0x38]
0001ca  1c40              ADDS     r0,r0,#1
0001cc  49a4              LDR      r1,|L1.1120|
0001ce  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
0001d0  6388              STR      r0,[r1,#0x38]
;;;1634   #endif
;;;1635                   OSCtxSwCtr++;                          /* Increment context switch counter             */
0001d2  48a5              LDR      r0,|L1.1128|
0001d4  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
0001d6  1c40              ADDS     r0,r0,#1
0001d8  49a3              LDR      r1,|L1.1128|
0001da  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1636                   OS_TASK_SW();                          /* Perform a context switch                     */
0001dc  f7fffffe          BL       OSCtxSw
                  |L1.480|
;;;1637               }
;;;1638           }
;;;1639       }
;;;1640       OS_EXIT_CRITICAL();
0001e0  4620              MOV      r0,r4
0001e2  f7fffffe          BL       OS_CPU_SR_Restore
;;;1641   }
0001e6  bd10              POP      {r4,pc}
;;;1642   
                          ENDP

                  OS_EventTaskWaitMulti PROC
;;;1096   #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;1097   void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
0001e8  b570              PUSH     {r4-r6,lr}
;;;1098   {
0001ea  4601              MOV      r1,r0
;;;1099       OS_EVENT **pevents;
;;;1100       OS_EVENT  *pevent;
;;;1101       INT8U      y;
;;;1102   
;;;1103   
;;;1104       OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
0001ec  2400              MOVS     r4,#0
0001ee  4d9f              LDR      r5,|L1.1132|
0001f0  682d              LDR      r5,[r5,#0]  ; OSTCBCur
0001f2  61ec              STR      r4,[r5,#0x1c]
;;;1105       OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
0001f4  4c9d              LDR      r4,|L1.1132|
0001f6  6824              LDR      r4,[r4,#0]  ; OSTCBCur
0001f8  6221              STR      r1,[r4,#0x20]
;;;1106   
;;;1107       pevents =  pevents_wait;
0001fa  460b              MOV      r3,r1
;;;1108       pevent  = *pevents;
0001fc  6818              LDR      r0,[r3,#0]
;;;1109       while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
0001fe  e01b              B        |L1.568|
                  |L1.512|
;;;1110           pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
000200  4c9a              LDR      r4,|L1.1132|
000202  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000204  f8945034          LDRB     r5,[r4,#0x34]
000208  f100040b          ADD      r4,r0,#0xb
00020c  5d64              LDRB     r4,[r4,r5]
00020e  4d97              LDR      r5,|L1.1132|
000210  682d              LDR      r5,[r5,#0]  ; OSTCBCur
000212  f8955035          LDRB     r5,[r5,#0x35]
000216  432c              ORRS     r4,r4,r5
000218  4d94              LDR      r5,|L1.1132|
00021a  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00021c  f8956034          LDRB     r6,[r5,#0x34]
000220  f100050b          ADD      r5,r0,#0xb
000224  55ac              STRB     r4,[r5,r6]
;;;1111           pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000226  7a84              LDRB     r4,[r0,#0xa]
000228  4d90              LDR      r5,|L1.1132|
00022a  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00022c  f8955036          LDRB     r5,[r5,#0x36]
000230  432c              ORRS     r4,r4,r5
000232  7284              STRB     r4,[r0,#0xa]
;;;1112           pevents++;
000234  1d1b              ADDS     r3,r3,#4
;;;1113           pevent = *pevents;
000236  6818              LDR      r0,[r3,#0]
                  |L1.568|
000238  2800              CMP      r0,#0                 ;1109
00023a  d1e1              BNE      |L1.512|
;;;1114       }
;;;1115   
;;;1116       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00023c  4c8b              LDR      r4,|L1.1132|
00023e  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000240  f8942034          LDRB     r2,[r4,#0x34]
;;;1117       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
000244  4c82              LDR      r4,|L1.1104|
000246  5ca4              LDRB     r4,[r4,r2]
000248  4d88              LDR      r5,|L1.1132|
00024a  682d              LDR      r5,[r5,#0]  ; OSTCBCur
00024c  f8955035          LDRB     r5,[r5,#0x35]
000250  43ac              BICS     r4,r4,r5
000252  4d7f              LDR      r5,|L1.1104|
000254  54ac              STRB     r4,[r5,r2]
;;;1118       if (OSRdyTbl[y] == 0) {
000256  462c              MOV      r4,r5
000258  5ca4              LDRB     r4,[r4,r2]
00025a  b944              CBNZ     r4,|L1.622|
;;;1119           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
00025c  4c83              LDR      r4,|L1.1132|
00025e  6824              LDR      r4,[r4,#0]  ; OSTCBCur
000260  f8945036          LDRB     r5,[r4,#0x36]
000264  4c79              LDR      r4,|L1.1100|
000266  7824              LDRB     r4,[r4,#0]  ; OSRdyGrp
000268  43ac              BICS     r4,r4,r5
00026a  4d78              LDR      r5,|L1.1100|
00026c  702c              STRB     r4,[r5,#0]
                  |L1.622|
;;;1120       }
;;;1121   }
00026e  bd70              POP      {r4-r6,pc}
;;;1122   #endif
                          ENDP

                  OSEventPendMulti PROC
;;;305    #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
;;;306    INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
000270  e92d4fff          PUSH     {r0-r11,lr}
;;;307    {
000274  b083              SUB      sp,sp,#0xc
000276  4681              MOV      r9,r0
000278  460e              MOV      r6,r1
00027a  4615              MOV      r5,r2
00027c  9f10              LDR      r7,[sp,#0x40]
;;;308        OS_EVENT  **pevents;
;;;309        OS_EVENT   *pevent;
;;;310    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;311        OS_Q       *pq;
;;;312    #endif
;;;313        BOOLEAN     events_rdy;
;;;314        INT16U      events_rdy_nbr;
;;;315        INT8U       events_stat;
;;;316    #if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
;;;317        OS_CPU_SR   cpu_sr = 0;
00027e  2000              MOVS     r0,#0
000280  9000              STR      r0,[sp,#0]
;;;318    #endif
;;;319    
;;;320    
;;;321    
;;;322    #if (OS_ARG_CHK_EN > 0)
;;;323        if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
000282  b917              CBNZ     r7,|L1.650|
                  |L1.644|
;;;324            return (0);
;;;325        }
;;;326        if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
;;;327           *perr =  OS_ERR_PEVENT_NULL;
;;;328            return (0);
;;;329        }
;;;330        if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
;;;331           *perr =  OS_ERR_PEVENT_NULL;
;;;332            return (0);
;;;333        }
;;;334        if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
;;;335           *perr =  OS_ERR_PEVENT_NULL;
;;;336            return (0);
;;;337        }
;;;338    #endif
;;;339    
;;;340       *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
;;;341    
;;;342        pevents     =  pevents_pend;
;;;343        pevent      = *pevents;
;;;344        while  (pevent != (OS_EVENT *)0) {
;;;345            switch (pevent->OSEventType) {                  /* Validate event block types                  */
;;;346    #if (OS_SEM_EN  > 0)
;;;347                case OS_EVENT_TYPE_SEM:
;;;348                     break;
;;;349    #endif
;;;350    #if (OS_MBOX_EN > 0)
;;;351                case OS_EVENT_TYPE_MBOX:
;;;352                     break;
;;;353    #endif
;;;354    #if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
;;;355                case OS_EVENT_TYPE_Q:
;;;356                     break;
;;;357    #endif
;;;358    
;;;359                case OS_EVENT_TYPE_MUTEX:                                            
;;;360                case OS_EVENT_TYPE_FLAG:
;;;361                default:           
;;;362                    *perr = OS_ERR_EVENT_TYPE;
;;;363                     return (0);
;;;364            }
;;;365            pevents++;
;;;366            pevent = *pevents;
;;;367        }
;;;368    
;;;369        if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
;;;370           *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
;;;371            return (0);
;;;372        }
;;;373        if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
;;;374           *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
;;;375            return (0);
;;;376        }
;;;377    
;;;378    /*$PAGE*/
;;;379        OS_ENTER_CRITICAL();
;;;380        events_rdy     =  OS_FALSE;
;;;381        events_rdy_nbr =  0;
;;;382        events_stat    =  OS_STAT_RDY;
;;;383        pevents        =  pevents_pend;
;;;384        pevent         = *pevents;
;;;385        while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
;;;386            switch (pevent->OSEventType) {
;;;387    #if (OS_SEM_EN > 0)
;;;388                case OS_EVENT_TYPE_SEM:
;;;389                     if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
;;;390                         pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
;;;391                        *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
;;;392                          events_rdy   =  OS_TRUE;
;;;393                        *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
;;;394                          events_rdy_nbr++;
;;;395    
;;;396                     } else {
;;;397                          events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
;;;398                     }
;;;399                     break;
;;;400    #endif
;;;401    
;;;402    #if (OS_MBOX_EN > 0)
;;;403                case OS_EVENT_TYPE_MBOX:
;;;404                     if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
;;;405                                                            /* ... return available message,           ... */
;;;406                        *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
;;;407                         pevent->OSEventPtr  = (void *)0;
;;;408                        *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
;;;409                          events_rdy         =  OS_TRUE;
;;;410                          events_rdy_nbr++;
;;;411    
;;;412                     } else {
;;;413                          events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
;;;414                     }
;;;415                     break;
;;;416    #endif
;;;417    
;;;418    #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;419                case OS_EVENT_TYPE_Q:
;;;420                     pq = (OS_Q *)pevent->OSEventPtr;
;;;421                     if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
;;;422                                                            /* ... return available message,           ... */
;;;423                        *pmsgs_rdy++ = (void *)*pq->OSQOut++;
;;;424                         if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
;;;425                             pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
;;;426                         }
;;;427                         pq->OSQEntries--;                  /* Update number of queue entries              */
;;;428                        *pevents_rdy++ = pevent;            /* ... and return available queue event        */
;;;429                          events_rdy   = OS_TRUE;
;;;430                          events_rdy_nbr++;
;;;431    
;;;432                     } else {
;;;433                          events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
;;;434                     }
;;;435                     break;
;;;436    #endif
;;;437    
;;;438                case OS_EVENT_TYPE_MUTEX:                                            
;;;439                case OS_EVENT_TYPE_FLAG:
;;;440                default:           
;;;441                     OS_EXIT_CRITICAL();
;;;442                    *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
;;;443                    *perr        =  OS_ERR_EVENT_TYPE;
;;;444                     return (events_rdy_nbr);
;;;445            }
;;;446            pevents++;
;;;447            pevent = *pevents;
;;;448        }
;;;449    
;;;450        if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
;;;451           *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
;;;452            OS_EXIT_CRITICAL();
;;;453           *perr        =  OS_ERR_NONE;
;;;454            return (events_rdy_nbr);
;;;455        }
;;;456    /*$PAGE*/
;;;457                                                            /* Otherwise, must wait until any event occurs */
;;;458        OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
;;;459                                   OS_STAT_MULTI;           /* ... pend on multiple events                 */
;;;460        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;461        OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
;;;462        OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
;;;463    
;;;464        OS_EXIT_CRITICAL();
;;;465        OS_Sched();                                         /* Find next highest priority task ready       */
;;;466        OS_ENTER_CRITICAL();
;;;467    
;;;468        switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
;;;469            case OS_STAT_PEND_OK:
;;;470            case OS_STAT_PEND_ABORT:
;;;471                 pevent = OSTCBCur->OSTCBEventPtr;
;;;472                 if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
;;;473                    *pevents_rdy++ =  pevent;               /* ... return available event ...              */
;;;474                    *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
;;;475                      events_rdy_nbr++;
;;;476    
;;;477                 } else {                                   /* Else NO event available, handle as timeout  */
;;;478                     OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
;;;479                     OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;480                 }
;;;481    			 break;
;;;482    
;;;483            case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
;;;484            default:                                        /* ... remove task from events' wait lists     */
;;;485                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
;;;486                 break;
;;;487        }
;;;488    
;;;489        switch (OSTCBCur->OSTCBStatPend) {
;;;490            case OS_STAT_PEND_OK:
;;;491                 switch (pevent->OSEventType) {             /* Return event's message                      */
;;;492    #if (OS_SEM_EN > 0)
;;;493                     case OS_EVENT_TYPE_SEM:
;;;494                         *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
;;;495                          break;
;;;496    #endif
;;;497    
;;;498    #if ((OS_MBOX_EN > 0) ||                 \
;;;499        ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
;;;500                     case OS_EVENT_TYPE_MBOX:
;;;501                     case OS_EVENT_TYPE_Q:
;;;502                         *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
;;;503                          break;
;;;504    #endif
;;;505    
;;;506                     case OS_EVENT_TYPE_MUTEX:                                       
;;;507                     case OS_EVENT_TYPE_FLAG:
;;;508                     default:           
;;;509                          OS_EXIT_CRITICAL();
;;;510                         *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
;;;511                         *perr        =  OS_ERR_EVENT_TYPE;
;;;512                          return (events_rdy_nbr);
;;;513                 }
;;;514                *perr = OS_ERR_NONE;
;;;515                 break;
;;;516    
;;;517            case OS_STAT_PEND_ABORT:
;;;518                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
;;;519                *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
;;;520                 break;
;;;521                                                            
;;;522            case OS_STAT_PEND_TO:                                                
;;;523            default:        
;;;524                *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
;;;525                *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
;;;526                 break;
;;;527        }
;;;528    
;;;529        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
;;;530        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
;;;531        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
;;;532        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;533        OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
;;;534        OS_EXIT_CRITICAL();
;;;535    
;;;536        return (events_rdy_nbr);
;;;537    }
000284  b007              ADD      sp,sp,#0x1c
000286  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.650|
00028a  f1b90f00          CMP      r9,#0                 ;326
00028e  d103              BNE      |L1.664|
000290  2004              MOVS     r0,#4                 ;327
000292  7038              STRB     r0,[r7,#0]            ;327
000294  2000              MOVS     r0,#0                 ;328
000296  e7f5              B        |L1.644|
                  |L1.664|
000298  b91e              CBNZ     r6,|L1.674|
00029a  2004              MOVS     r0,#4                 ;331
00029c  7038              STRB     r0,[r7,#0]            ;331
00029e  2000              MOVS     r0,#0                 ;332
0002a0  e7f0              B        |L1.644|
                  |L1.674|
0002a2  b91d              CBNZ     r5,|L1.684|
0002a4  2004              MOVS     r0,#4                 ;335
0002a6  7038              STRB     r0,[r7,#0]            ;335
0002a8  2000              MOVS     r0,#0                 ;336
0002aa  e7eb              B        |L1.644|
                  |L1.684|
0002ac  2000              MOVS     r0,#0                 ;340
0002ae  6030              STR      r0,[r6,#0]            ;340
0002b0  46ca              MOV      r10,r9                ;342
0002b2  f8da4000          LDR      r4,[r10,#0]           ;343
0002b6  e015              B        |L1.740|
                  |L1.696|
0002b8  7820              LDRB     r0,[r4,#0]            ;345
0002ba  2806              CMP      r0,#6                 ;345
0002bc  d207              BCS      |L1.718|
0002be  e8dff000          TBB      [pc,r0]               ;345
0002c2  0604              DCB      0x06,0x04
0002c4  05030708          DCB      0x05,0x03,0x07,0x08
0002c8  e007              B        |L1.730|
0002ca  e006              B        |L1.730|
0002cc  e005              B        |L1.730|
                  |L1.718|
0002ce  bf00              NOP                            ;359
0002d0  bf00              NOP                            ;360
0002d2  2001              MOVS     r0,#1                 ;362
0002d4  7038              STRB     r0,[r7,#0]            ;362
0002d6  2000              MOVS     r0,#0                 ;363
0002d8  e7d4              B        |L1.644|
                  |L1.730|
0002da  bf00              NOP                            ;348
0002dc  f10a0a04          ADD      r10,r10,#4            ;365
0002e0  f8da4000          LDR      r4,[r10,#0]           ;366
                  |L1.740|
0002e4  2c00              CMP      r4,#0                 ;344
0002e6  d1e7              BNE      |L1.696|
0002e8  4856              LDR      r0,|L1.1092|
0002ea  7800              LDRB     r0,[r0,#0]            ;369  ; OSIntNesting
0002ec  2800              CMP      r0,#0                 ;369
0002ee  dd03              BLE      |L1.760|
0002f0  2002              MOVS     r0,#2                 ;370
0002f2  7038              STRB     r0,[r7,#0]            ;370
0002f4  2000              MOVS     r0,#0                 ;371
0002f6  e7c5              B        |L1.644|
                  |L1.760|
0002f8  4857              LDR      r0,|L1.1112|
0002fa  7800              LDRB     r0,[r0,#0]            ;373  ; OSLockNesting
0002fc  2800              CMP      r0,#0                 ;373
0002fe  dd03              BLE      |L1.776|
000300  200d              MOVS     r0,#0xd               ;374
000302  7038              STRB     r0,[r7,#0]            ;374
000304  2000              MOVS     r0,#0                 ;375
000306  e7bd              B        |L1.644|
                  |L1.776|
000308  f7fffffe          BL       OS_CPU_SR_Save
00030c  9000              STR      r0,[sp,#0]            ;379
00030e  2000              MOVS     r0,#0                 ;380
000310  9002              STR      r0,[sp,#8]            ;380
000312  4683              MOV      r11,r0                ;381
000314  9001              STR      r0,[sp,#4]            ;382
000316  46ca              MOV      r10,r9                ;383
000318  f8da4000          LDR      r4,[r10,#0]           ;384
00031c  e068              B        |L1.1008|
                  |L1.798|
00031e  7820              LDRB     r0,[r4,#0]            ;386
000320  2806              CMP      r0,#6                 ;386
000322  d255              BCS      |L1.976|
000324  e8dff000          TBB      [pc,r0]               ;386
000328  54182b03          DCB      0x54,0x18,0x2b,0x03
00032c  5556              DCB      0x55,0x56
00032e  8920              LDRH     r0,[r4,#8]            ;389
000330  2800              CMP      r0,#0                 ;389
000332  dd0c              BLE      |L1.846|
000334  8920              LDRH     r0,[r4,#8]            ;390
000336  1e40              SUBS     r0,r0,#1              ;390
000338  8120              STRH     r0,[r4,#8]            ;390
00033a  c610              STM      r6!,{r4}              ;391
00033c  2001              MOVS     r0,#1                 ;392
00033e  9002              STR      r0,[sp,#8]            ;392
000340  2000              MOVS     r0,#0                 ;393
000342  c501              STM      r5!,{r0}              ;393
000344  f10b0001          ADD      r0,r11,#1             ;394
000348  fa1ffb80          UXTH     r11,r0                ;394
00034c  e003              B        |L1.854|
                  |L1.846|
00034e  9801              LDR      r0,[sp,#4]            ;397
000350  f0400001          ORR      r0,r0,#1              ;397
000354  9001              STR      r0,[sp,#4]            ;397
                  |L1.854|
000356  e046              B        |L1.998|
000358  6860              LDR      r0,[r4,#4]            ;404
00035a  b158              CBZ      r0,|L1.884|
00035c  6860              LDR      r0,[r4,#4]            ;406
00035e  c501              STM      r5!,{r0}              ;406
000360  2000              MOVS     r0,#0                 ;407
000362  6060              STR      r0,[r4,#4]            ;407
000364  c610              STM      r6!,{r4}              ;408
000366  2001              MOVS     r0,#1                 ;409
000368  9002              STR      r0,[sp,#8]            ;409
00036a  f10b0001          ADD      r0,r11,#1             ;410
00036e  fa1ffb80          UXTH     r11,r0                ;410
000372  e003              B        |L1.892|
                  |L1.884|
000374  9801              LDR      r0,[sp,#4]            ;413
000376  f0400002          ORR      r0,r0,#2              ;413
00037a  9001              STR      r0,[sp,#4]            ;413
                  |L1.892|
00037c  e033              B        |L1.998|
00037e  f8d48004          LDR      r8,[r4,#4]            ;420
000382  f8b80016          LDRH     r0,[r8,#0x16]         ;421
000386  2800              CMP      r0,#0                 ;421
000388  dd1d              BLE      |L1.966|
00038a  f8d81010          LDR      r1,[r8,#0x10]         ;423
00038e  1d08              ADDS     r0,r1,#4              ;423
000390  f8c80010          STR      r0,[r8,#0x10]         ;423
000394  6808              LDR      r0,[r1,#0]            ;423
000396  c501              STM      r5!,{r0}              ;423
000398  f8d81008          LDR      r1,[r8,#8]            ;424
00039c  f8d80010          LDR      r0,[r8,#0x10]         ;424
0003a0  4288              CMP      r0,r1                 ;424
0003a2  d103              BNE      |L1.940|
0003a4  f8d80004          LDR      r0,[r8,#4]            ;425
0003a8  f8c80010          STR      r0,[r8,#0x10]         ;425
                  |L1.940|
0003ac  f8b80016          LDRH     r0,[r8,#0x16]         ;427
0003b0  1e40              SUBS     r0,r0,#1              ;427
0003b2  f8a80016          STRH     r0,[r8,#0x16]         ;427
0003b6  c610              STM      r6!,{r4}              ;428
0003b8  2001              MOVS     r0,#1                 ;429
0003ba  9002              STR      r0,[sp,#8]            ;429
0003bc  f10b0001          ADD      r0,r11,#1             ;430
0003c0  fa1ffb80          UXTH     r11,r0                ;430
0003c4  e003              B        |L1.974|
                  |L1.966|
0003c6  9801              LDR      r0,[sp,#4]            ;433
0003c8  f0400004          ORR      r0,r0,#4              ;433
0003cc  9001              STR      r0,[sp,#4]            ;433
                  |L1.974|
0003ce  e00a              B        |L1.998|
                  |L1.976|
0003d0  bf00              NOP                            ;438
0003d2  bf00              NOP                            ;439
0003d4  9800              LDR      r0,[sp,#0]            ;441
0003d6  f7fffffe          BL       OS_CPU_SR_Restore
0003da  2000              MOVS     r0,#0                 ;442
0003dc  6030              STR      r0,[r6,#0]            ;442
0003de  2001              MOVS     r0,#1                 ;443
0003e0  7038              STRB     r0,[r7,#0]            ;443
0003e2  4658              MOV      r0,r11                ;444
0003e4  e74e              B        |L1.644|
                  |L1.998|
0003e6  bf00              NOP                            ;399
0003e8  f10a0a04          ADD      r10,r10,#4            ;446
0003ec  f8da4000          LDR      r4,[r10,#0]           ;447
                  |L1.1008|
0003f0  2c00              CMP      r4,#0                 ;385
0003f2  d194              BNE      |L1.798|
0003f4  9802              LDR      r0,[sp,#8]            ;450
0003f6  2801              CMP      r0,#1                 ;450
0003f8  d108              BNE      |L1.1036|
0003fa  2000              MOVS     r0,#0                 ;451
0003fc  6030              STR      r0,[r6,#0]            ;451
0003fe  9800              LDR      r0,[sp,#0]            ;452
000400  f7fffffe          BL       OS_CPU_SR_Restore
000404  2000              MOVS     r0,#0                 ;453
000406  7038              STRB     r0,[r7,#0]            ;453
000408  4658              MOV      r0,r11                ;454
00040a  e73b              B        |L1.644|
                  |L1.1036|
00040c  4817              LDR      r0,|L1.1132|
00040e  6800              LDR      r0,[r0,#0]            ;458  ; OSTCBCur
000410  f8900030          LDRB     r0,[r0,#0x30]         ;458
000414  9901              LDR      r1,[sp,#4]            ;458
000416  f0410180          ORR      r1,r1,#0x80           ;458
00041a  4308              ORRS     r0,r0,r1              ;458
00041c  4913              LDR      r1,|L1.1132|
00041e  6809              LDR      r1,[r1,#0]            ;458  ; OSTCBCur
000420  f8810030          STRB     r0,[r1,#0x30]         ;458
000424  2000              MOVS     r0,#0                 ;460
000426  4911              LDR      r1,|L1.1132|
000428  6809              LDR      r1,[r1,#0]            ;460  ; OSTCBCur
00042a  f8810031          STRB     r0,[r1,#0x31]         ;460
00042e  490f              LDR      r1,|L1.1132|
000430  9806              LDR      r0,[sp,#0x18]         ;461
000432  6809              LDR      r1,[r1,#0]            ;461  ; OSTCBCur
000434  85c8              STRH     r0,[r1,#0x2e]         ;461
000436  4648              MOV      r0,r9                 ;462
000438  f7fffffe          BL       OS_EventTaskWaitMulti
00043c  9800              LDR      r0,[sp,#0]            ;464
00043e  f7fffffe          BL       OS_CPU_SR_Restore
000442  e015              B        |L1.1136|
                  |L1.1092|
                          DCD      OSIntNesting
                  |L1.1096|
                          DCD      OSUnMapTbl
                  |L1.1100|
                          DCD      OSRdyGrp
                  |L1.1104|
                          DCD      OSRdyTbl
                  |L1.1108|
                          DCD      OSPrioHighRdy
                  |L1.1112|
                          DCD      OSLockNesting
                  |L1.1116|
                          DCD      OSTCBPrioTbl
                  |L1.1120|
                          DCD      OSTCBHighRdy
                  |L1.1124|
                          DCD      OSPrioCur
                  |L1.1128|
                          DCD      OSCtxSwCtr
                  |L1.1132|
                          DCD      OSTCBCur
                  |L1.1136|
000470  f7fffffe          BL       OS_Sched
000474  f7fffffe          BL       OS_CPU_SR_Save
000478  9000              STR      r0,[sp,#0]            ;466
00047a  48fc              LDR      r0,|L1.2156|
00047c  6800              LDR      r0,[r0,#0]            ;468  ; OSTCBCur
00047e  f8900031          LDRB     r0,[r0,#0x31]         ;468
000482  b120              CBZ      r0,|L1.1166|
000484  2801              CMP      r0,#1                 ;468
000486  d01b              BEQ      |L1.1216|
000488  2802              CMP      r0,#2                 ;468
00048a  d118              BNE      |L1.1214|
00048c  e000              B        |L1.1168|
                  |L1.1166|
00048e  bf00              NOP                            ;470
                  |L1.1168|
000490  48f6              LDR      r0,|L1.2156|
000492  6800              LDR      r0,[r0,#0]            ;471  ; OSTCBCur
000494  69c4              LDR      r4,[r0,#0x1c]         ;471
000496  b13c              CBZ      r4,|L1.1192|
000498  c610              STM      r6!,{r4}              ;473
00049a  2000              MOVS     r0,#0                 ;474
00049c  6030              STR      r0,[r6,#0]            ;474
00049e  f10b0001          ADD      r0,r11,#1             ;475
0004a2  fa1ffb80          UXTH     r11,r0                ;475
0004a6  e009              B        |L1.1212|
                  |L1.1192|
0004a8  2001              MOVS     r0,#1                 ;478
0004aa  49f0              LDR      r1,|L1.2156|
0004ac  6809              LDR      r1,[r1,#0]            ;478  ; OSTCBCur
0004ae  f8810031          STRB     r0,[r1,#0x31]         ;478
0004b2  4649              MOV      r1,r9                 ;479
0004b4  48ed              LDR      r0,|L1.2156|
0004b6  6800              LDR      r0,[r0,#0]            ;479  ; OSTCBCur
0004b8  f7fffffe          BL       OS_EventTaskRemoveMulti
                  |L1.1212|
0004bc  e006              B        |L1.1228|
                  |L1.1214|
0004be  bf00              NOP                            ;483
                  |L1.1216|
0004c0  4649              MOV      r1,r9                 ;485
0004c2  48ea              LDR      r0,|L1.2156|
0004c4  6800              LDR      r0,[r0,#0]            ;485  ; OSTCBCur
0004c6  f7fffffe          BL       OS_EventTaskRemoveMulti
0004ca  bf00              NOP                            ;486
                  |L1.1228|
0004cc  bf00              NOP                            ;481
0004ce  48e7              LDR      r0,|L1.2156|
0004d0  6800              LDR      r0,[r0,#0]            ;489  ; OSTCBCur
0004d2  f8900031          LDRB     r0,[r0,#0x31]         ;489
0004d6  b120              CBZ      r0,|L1.1250|
0004d8  2801              CMP      r0,#1                 ;489
0004da  d028              BEQ      |L1.1326|
0004dc  2802              CMP      r0,#2                 ;489
0004de  d125              BNE      |L1.1324|
0004e0  e01f              B        |L1.1314|
                  |L1.1250|
0004e2  7820              LDRB     r0,[r4,#0]            ;491
0004e4  2806              CMP      r0,#6                 ;491
0004e6  d20d              BCS      |L1.1284|
0004e8  e8dff000          TBB      [pc,r0]               ;491
0004ec  0c060703          DCB      0x0c,0x06,0x07,0x03
0004f0  0d0e              DCB      0x0d,0x0e
0004f2  2000              MOVS     r0,#0                 ;494
0004f4  c501              STM      r5!,{r0}              ;494
0004f6  e010              B        |L1.1306|
0004f8  bf00              NOP                            ;501
0004fa  48dc              LDR      r0,|L1.2156|
0004fc  6800              LDR      r0,[r0,#0]            ;502  ; OSTCBCur
0004fe  6a40              LDR      r0,[r0,#0x24]         ;502
000500  c501              STM      r5!,{r0}              ;502
000502  e00a              B        |L1.1306|
                  |L1.1284|
000504  bf00              NOP                            ;506
000506  bf00              NOP                            ;507
000508  9800              LDR      r0,[sp,#0]            ;509
00050a  f7fffffe          BL       OS_CPU_SR_Restore
00050e  2000              MOVS     r0,#0                 ;510
000510  6030              STR      r0,[r6,#0]            ;510
000512  2001              MOVS     r0,#1                 ;511
000514  7038              STRB     r0,[r7,#0]            ;511
000516  4658              MOV      r0,r11                ;512
000518  e6b4              B        |L1.644|
                  |L1.1306|
00051a  bf00              NOP                            ;495
00051c  2000              MOVS     r0,#0                 ;514
00051e  7038              STRB     r0,[r7,#0]            ;514
000520  e00a              B        |L1.1336|
                  |L1.1314|
000522  2000              MOVS     r0,#0                 ;518
000524  c501              STM      r5!,{r0}              ;518
000526  200e              MOVS     r0,#0xe               ;519
000528  7038              STRB     r0,[r7,#0]            ;519
00052a  e005              B        |L1.1336|
                  |L1.1324|
00052c  bf00              NOP                            ;522
                  |L1.1326|
00052e  2000              MOVS     r0,#0                 ;524
000530  c501              STM      r5!,{r0}              ;524
000532  200a              MOVS     r0,#0xa               ;525
000534  7038              STRB     r0,[r7,#0]            ;525
000536  bf00              NOP                            ;526
                  |L1.1336|
000538  bf00              NOP                            ;515
00053a  2000              MOVS     r0,#0                 ;529
00053c  49cb              LDR      r1,|L1.2156|
00053e  6809              LDR      r1,[r1,#0]            ;529  ; OSTCBCur
000540  f8810030          STRB     r0,[r1,#0x30]         ;529
000544  49c9              LDR      r1,|L1.2156|
000546  6809              LDR      r1,[r1,#0]            ;530  ; OSTCBCur
000548  f8810031          STRB     r0,[r1,#0x31]         ;530
00054c  49c7              LDR      r1,|L1.2156|
00054e  6809              LDR      r1,[r1,#0]            ;531  ; OSTCBCur
000550  61c8              STR      r0,[r1,#0x1c]         ;531
000552  49c6              LDR      r1,|L1.2156|
000554  6809              LDR      r1,[r1,#0]            ;532  ; OSTCBCur
000556  6208              STR      r0,[r1,#0x20]         ;532
000558  49c4              LDR      r1,|L1.2156|
00055a  6809              LDR      r1,[r1,#0]            ;533  ; OSTCBCur
00055c  6248              STR      r0,[r1,#0x24]         ;533
00055e  9800              LDR      r0,[sp,#0]            ;534
000560  f7fffffe          BL       OS_CPU_SR_Restore
000564  4658              MOV      r0,r11                ;536
000566  e68d              B        |L1.644|
;;;538    #endif
                          ENDP

                  OS_TaskStatStkChk PROC
;;;1861   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1862   void  OS_TaskStatStkChk (void)
000568  b57c              PUSH     {r2-r6,lr}
;;;1863   {
;;;1864       OS_TCB      *ptcb;
;;;1865       OS_STK_DATA  stk_data;
;;;1866       INT8U        err;
;;;1867       INT8U        prio;
;;;1868   
;;;1869   
;;;1870       for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
00056a  2500              MOVS     r5,#0
00056c  e014              B        |L1.1432|
                  |L1.1390|
;;;1871           err = OSTaskStkChk(prio, &stk_data);
00056e  4669              MOV      r1,sp
000570  4628              MOV      r0,r5
000572  f7fffffe          BL       OSTaskStkChk
000576  4606              MOV      r6,r0
;;;1872           if (err == OS_ERR_NONE) {
000578  b966              CBNZ     r6,|L1.1428|
;;;1873               ptcb = OSTCBPrioTbl[prio];
00057a  48bd              LDR      r0,|L1.2160|
00057c  f8504025          LDR      r4,[r0,r5,LSL #2]
;;;1874               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000580  b144              CBZ      r4,|L1.1428|
;;;1875                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000582  2c01              CMP      r4,#1
000584  d006              BEQ      |L1.1428|
;;;1876   #if OS_TASK_PROFILE_EN > 0
;;;1877                       #if OS_STK_GROWTH == 1
;;;1878                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000586  e9d40102          LDRD     r0,r1,[r4,#8]
00058a  eb000081          ADD      r0,r0,r1,LSL #2
00058e  6460              STR      r0,[r4,#0x44]
;;;1879                       #else
;;;1880                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1881                       #endif
;;;1882                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000590  9801              LDR      r0,[sp,#4]
000592  64a0              STR      r0,[r4,#0x48]
                  |L1.1428|
000594  1c68              ADDS     r0,r5,#1              ;1870
000596  b2c5              UXTB     r5,r0                 ;1870
                  |L1.1432|
000598  2d1f              CMP      r5,#0x1f              ;1870
00059a  dde8              BLE      |L1.1390|
;;;1883   #endif
;;;1884                   }
;;;1885               }
;;;1886           }
;;;1887       }
;;;1888   }
00059c  bd7c              POP      {r2-r6,pc}
;;;1889   #endif
                          ENDP

                  OS_TaskStat PROC
;;;1816   #if OS_TASK_STAT_EN > 0
;;;1817   void  OS_TaskStat (void *p_arg)
00059e  2400              MOVS     r4,#0
;;;1818   {
;;;1819   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1820       OS_CPU_SR  cpu_sr = 0;
;;;1821   #endif
;;;1822   
;;;1823   
;;;1824   
;;;1825       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1826       while (OSStatRdy == OS_FALSE) {
0005a0  e002              B        |L1.1448|
                  |L1.1442|
;;;1827           OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
0005a2  20c8              MOVS     r0,#0xc8
0005a4  f7fffffe          BL       OSTimeDly
                  |L1.1448|
0005a8  48b2              LDR      r0,|L1.2164|
0005aa  7800              LDRB     r0,[r0,#0]            ;1826  ; OSStatRdy
0005ac  2800              CMP      r0,#0                 ;1826
0005ae  d0f8              BEQ      |L1.1442|
;;;1828       }
;;;1829       OSIdleCtrMax /= 100L;
0005b0  48b1              LDR      r0,|L1.2168|
0005b2  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
0005b4  2164              MOVS     r1,#0x64
0005b6  fbb0f0f1          UDIV     r0,r0,r1
0005ba  49af              LDR      r1,|L1.2168|
0005bc  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1830       if (OSIdleCtrMax == 0L) {
0005be  4608              MOV      r0,r1
0005c0  6800              LDR      r0,[r0,#0]  ; OSIdleCtrMax
0005c2  b928              CBNZ     r0,|L1.1488|
;;;1831           OSCPUUsage = 0;
0005c4  2000              MOVS     r0,#0
0005c6  49ad              LDR      r1,|L1.2172|
0005c8  7008              STRB     r0,[r1,#0]
;;;1832           (void)OSTaskSuspend(OS_PRIO_SELF);
0005ca  20ff              MOVS     r0,#0xff
0005cc  f7fffffe          BL       OSTaskSuspend
                  |L1.1488|
;;;1833       }
;;;1834       for (;;) {
0005d0  bf00              NOP      
                  |L1.1490|
;;;1835           OS_ENTER_CRITICAL();
0005d2  f7fffffe          BL       OS_CPU_SR_Save
0005d6  4604              MOV      r4,r0
;;;1836           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0005d8  48a9              LDR      r0,|L1.2176|
0005da  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
0005dc  49a9              LDR      r1,|L1.2180|
0005de  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1837           OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
0005e0  2000              MOVS     r0,#0
0005e2  49a7              LDR      r1,|L1.2176|
0005e4  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1838           OS_EXIT_CRITICAL();
0005e6  4620              MOV      r0,r4
0005e8  f7fffffe          BL       OS_CPU_SR_Restore
;;;1839           OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
0005ec  48a5              LDR      r0,|L1.2180|
0005ee  6800              LDR      r0,[r0,#0]  ; OSIdleCtrRun
0005f0  49a1              LDR      r1,|L1.2168|
0005f2  6809              LDR      r1,[r1,#0]  ; OSIdleCtrMax
0005f4  fbb0f0f1          UDIV     r0,r0,r1
0005f8  f1c00064          RSB      r0,r0,#0x64
0005fc  499f              LDR      r1,|L1.2172|
0005fe  7008              STRB     r0,[r1,#0]
;;;1840           OSTaskStatHook();                        /* Invoke user definable hook                         */
000600  f7fffffe          BL       OSTaskStatHook
;;;1841   #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
;;;1842           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000604  f7fffffe          BL       OS_TaskStatStkChk
;;;1843   #endif
;;;1844           OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
000608  2064              MOVS     r0,#0x64
00060a  f7fffffe          BL       OSTimeDly
00060e  e7e0              B        |L1.1490|
;;;1845       }
;;;1846   }
;;;1847   #endif
                          ENDP

                  OS_InitTaskStat PROC
;;;1439   #if OS_TASK_STAT_EN > 0
;;;1440   static  void  OS_InitTaskStat (void)
000610  b500              PUSH     {lr}
;;;1441   {
000612  b087              SUB      sp,sp,#0x1c
;;;1442   #if OS_TASK_NAME_SIZE > 7
;;;1443       INT8U  err;
;;;1444   #endif
;;;1445   
;;;1446   
;;;1447   #if OS_TASK_CREATE_EXT_EN > 0
;;;1448       #if OS_STK_GROWTH == 1
;;;1449       (void)OSTaskCreateExt(OS_TaskStat,
000614  2303              MOVS     r3,#3
000616  2200              MOVS     r2,#0
000618  2180              MOVS     r1,#0x80
00061a  489b              LDR      r0,|L1.2184|
00061c  e9cd2303          STRD     r2,r3,[sp,#0xc]
000620  e9cd0101          STRD     r0,r1,[sp,#4]
000624  f64f73fe          MOV      r3,#0xfffe
000628  9300              STR      r3,[sp,#0]
00062a  231e              MOVS     r3,#0x1e
00062c  f50072fe          ADD      r2,r0,#0x1fc
000630  2100              MOVS     r1,#0
000632  f2af0095          ADR      r0,OS_TaskStat + 1
000636  f7fffffe          BL       OSTaskCreateExt
;;;1450                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1451                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
;;;1452                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1453                             OS_TASK_STAT_ID,
;;;1454                             &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
;;;1455                             OS_TASK_STAT_STK_SIZE,
;;;1456                             (void *)0,                                   /* No TCB extension               */
;;;1457                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1458       #else
;;;1459       (void)OSTaskCreateExt(OS_TaskStat,
;;;1460                             (void *)0,                                   /* No args passed to OS_TaskStat()*/
;;;1461                             &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
;;;1462                             OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
;;;1463                             OS_TASK_STAT_ID,
;;;1464                             &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
;;;1465                             OS_TASK_STAT_STK_SIZE,
;;;1466                             (void *)0,                                   /* No TCB extension               */
;;;1467                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
;;;1468       #endif
;;;1469   #else
;;;1470       #if OS_STK_GROWTH == 1
;;;1471       (void)OSTaskCreate(OS_TaskStat,
;;;1472                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1473                          &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
;;;1474                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1475       #else
;;;1476       (void)OSTaskCreate(OS_TaskStat,
;;;1477                          (void *)0,                                      /* No args passed to OS_TaskStat()*/
;;;1478                          &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
;;;1479                          OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
;;;1480       #endif
;;;1481   #endif
;;;1482   
;;;1483   #if OS_TASK_NAME_SIZE > 14
;;;1484       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
00063a  aa06              ADD      r2,sp,#0x18
00063c  a193              ADR      r1,|L1.2188|
00063e  201e              MOVS     r0,#0x1e
000640  f7fffffe          BL       OSTaskNameSet
;;;1485   #else
;;;1486   #if OS_TASK_NAME_SIZE > 7
;;;1487       OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
;;;1488   #endif
;;;1489   #endif
;;;1490   }
000644  b007              ADD      sp,sp,#0x1c
000646  bd00              POP      {pc}
;;;1491   #endif
                          ENDP

                  OS_TaskIdle PROC
;;;1774   
;;;1775   void  OS_TaskIdle (void *p_arg)
000648  2400              MOVS     r4,#0
;;;1776   {
;;;1777   #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;1778       OS_CPU_SR  cpu_sr = 0;
;;;1779   #endif
;;;1780   
;;;1781   
;;;1782   
;;;1783       (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
;;;1784       for (;;) {
00064a  bf00              NOP      
                  |L1.1612|
;;;1785           OS_ENTER_CRITICAL();
00064c  f7fffffe          BL       OS_CPU_SR_Save
000650  4604              MOV      r4,r0
;;;1786           OSIdleCtr++;
000652  488b              LDR      r0,|L1.2176|
000654  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
000656  1c40              ADDS     r0,r0,#1
000658  4989              LDR      r1,|L1.2176|
00065a  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1787           OS_EXIT_CRITICAL();
00065c  4620              MOV      r0,r4
00065e  f7fffffe          BL       OS_CPU_SR_Restore
;;;1788           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000662  f7fffffe          BL       OSTaskIdleHook
000666  e7f1              B        |L1.1612|
;;;1789       }
;;;1790   }
;;;1791   /*$PAGE*/
                          ENDP

                  OS_InitTaskIdle PROC
;;;1373   
;;;1374   static  void  OS_InitTaskIdle (void)
000668  b500              PUSH     {lr}
;;;1375   {
00066a  b087              SUB      sp,sp,#0x1c
;;;1376   #if OS_TASK_NAME_SIZE > 7
;;;1377       INT8U  err;
;;;1378   #endif
;;;1379   
;;;1380   
;;;1381   #if OS_TASK_CREATE_EXT_EN > 0
;;;1382       #if OS_STK_GROWTH == 1
;;;1383       (void)OSTaskCreateExt(OS_TaskIdle,
00066c  2303              MOVS     r3,#3
00066e  2200              MOVS     r2,#0
000670  2180              MOVS     r1,#0x80
000672  488a              LDR      r0,|L1.2204|
000674  e9cd2303          STRD     r2,r3,[sp,#0xc]
000678  e9cd0101          STRD     r0,r1,[sp,#4]
00067c  f64f73ff          MOV      r3,#0xffff
000680  9300              STR      r3,[sp,#0]
000682  231f              MOVS     r3,#0x1f
000684  f50072fe          ADD      r2,r0,#0x1fc
000688  2100              MOVS     r1,#0
00068a  f2af0043          ADR      r0,OS_TaskIdle + 1
00068e  f7fffffe          BL       OSTaskCreateExt
;;;1384                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1385                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
;;;1386                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1387                             OS_TASK_IDLE_ID,
;;;1388                             &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
;;;1389                             OS_TASK_IDLE_STK_SIZE,
;;;1390                             (void *)0,                                 /* No TCB extension                     */
;;;1391                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1392       #else
;;;1393       (void)OSTaskCreateExt(OS_TaskIdle,
;;;1394                             (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
;;;1395                             &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
;;;1396                             OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
;;;1397                             OS_TASK_IDLE_ID,
;;;1398                             &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
;;;1399                             OS_TASK_IDLE_STK_SIZE,
;;;1400                             (void *)0,                                 /* No TCB extension                     */
;;;1401                             OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
;;;1402       #endif
;;;1403   #else
;;;1404       #if OS_STK_GROWTH == 1
;;;1405       (void)OSTaskCreate(OS_TaskIdle,
;;;1406                          (void *)0,
;;;1407                          &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
;;;1408                          OS_TASK_IDLE_PRIO);
;;;1409       #else
;;;1410       (void)OSTaskCreate(OS_TaskIdle,
;;;1411                          (void *)0,
;;;1412                          &OSTaskIdleStk[0],
;;;1413                          OS_TASK_IDLE_PRIO);
;;;1414       #endif
;;;1415   #endif
;;;1416   
;;;1417   #if OS_TASK_NAME_SIZE > 14
;;;1418       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
000692  aa06              ADD      r2,sp,#0x18
000694  a182              ADR      r1,|L1.2208|
000696  201f              MOVS     r0,#0x1f
000698  f7fffffe          BL       OSTaskNameSet
;;;1419   #else
;;;1420   #if OS_TASK_NAME_SIZE > 7
;;;1421       OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
;;;1422   #endif
;;;1423   #endif
;;;1424   }
00069c  b007              ADD      sp,sp,#0x1c
00069e  bd00              POP      {pc}
;;;1425   /*$PAGE*/
                          ENDP

                  OS_MemClr PROC
;;;1554   
;;;1555   void  OS_MemClr (INT8U *pdest, INT16U size)
0006a0  e004              B        |L1.1708|
                  |L1.1698|
;;;1556   {
;;;1557       while (size > 0) {
;;;1558           *pdest++ = (INT8U)0;
0006a2  2200              MOVS     r2,#0
0006a4  f8002b01          STRB     r2,[r0],#1
;;;1559           size--;
0006a8  1e4a              SUBS     r2,r1,#1
0006aa  b291              UXTH     r1,r2
                  |L1.1708|
0006ac  2900              CMP      r1,#0                 ;1557
0006ae  dcf8              BGT      |L1.1698|
;;;1560       }
;;;1561   }
0006b0  4770              BX       lr
;;;1562   /*$PAGE*/
                          ENDP

                  OS_InitEventList PROC
;;;1246   
;;;1247   static  void  OS_InitEventList (void)
0006b2  b530              PUSH     {r4,r5,lr}
;;;1248   {
;;;1249   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
;;;1250   #if (OS_MAX_EVENTS > 1)
;;;1251       INT16U     i;
;;;1252       OS_EVENT  *pevent1;
;;;1253       OS_EVENT  *pevent2;
;;;1254   
;;;1255   
;;;1256       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0006b4  f44f7120          MOV      r1,#0x280
0006b8  487d              LDR      r0,|L1.2224|
0006ba  f7fffffe          BL       OS_MemClr
;;;1257       pevent1 = &OSEventTbl[0];
0006be  4b7c              LDR      r3,|L1.2224|
;;;1258       pevent2 = &OSEventTbl[1];
0006c0  f1030520          ADD      r5,r3,#0x20
;;;1259       for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
0006c4  2400              MOVS     r4,#0
0006c6  e00a              B        |L1.1758|
                  |L1.1736|
;;;1260           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
0006c8  2000              MOVS     r0,#0
0006ca  7018              STRB     r0,[r3,#0]
;;;1261           pevent1->OSEventPtr     = pevent2;
0006cc  605d              STR      r5,[r3,#4]
;;;1262   #if OS_EVENT_NAME_SIZE > 1
;;;1263           pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
0006ce  203f              MOVS     r0,#0x3f
0006d0  73d8              STRB     r0,[r3,#0xf]
;;;1264           pevent1->OSEventName[1] = OS_ASCII_NUL;
0006d2  2100              MOVS     r1,#0
0006d4  7419              STRB     r1,[r3,#0x10]
;;;1265   #endif
;;;1266           pevent1++;
0006d6  3320              ADDS     r3,r3,#0x20
;;;1267           pevent2++;
0006d8  3520              ADDS     r5,r5,#0x20
0006da  1c60              ADDS     r0,r4,#1              ;1259
0006dc  b284              UXTH     r4,r0                 ;1259
                  |L1.1758|
0006de  2c13              CMP      r4,#0x13              ;1259
0006e0  dbf2              BLT      |L1.1736|
;;;1268       }
;;;1269       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
0006e2  2000              MOVS     r0,#0
0006e4  7018              STRB     r0,[r3,#0]
;;;1270       pevent1->OSEventPtr             = (OS_EVENT *)0;
0006e6  6058              STR      r0,[r3,#4]
;;;1271   #if OS_EVENT_NAME_SIZE > 1
;;;1272       pevent1->OSEventName[0]         = '?';
0006e8  203f              MOVS     r0,#0x3f
0006ea  73d8              STRB     r0,[r3,#0xf]
;;;1273       pevent1->OSEventName[1]         = OS_ASCII_NUL;
0006ec  2100              MOVS     r1,#0
0006ee  7419              STRB     r1,[r3,#0x10]
;;;1274   #endif
;;;1275       OSEventFreeList                 = &OSEventTbl[0];
0006f0  486f              LDR      r0,|L1.2224|
0006f2  4970              LDR      r1,|L1.2228|
0006f4  6008              STR      r0,[r1,#0]  ; OSEventFreeList
;;;1276   #else
;;;1277       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1278       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1279       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1280   #if OS_EVENT_NAME_SIZE > 1
;;;1281       OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
;;;1282       OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
;;;1283   #endif
;;;1284   #endif
;;;1285   #endif
;;;1286   }
0006f6  bd30              POP      {r4,r5,pc}
;;;1287   /*$PAGE*/
                          ENDP

                  OS_InitTCBList PROC
;;;1505   
;;;1506   static  void  OS_InitTCBList (void)
0006f8  b530              PUSH     {r4,r5,lr}
;;;1507   {
;;;1508       INT8U    i;
;;;1509       OS_TCB  *ptcb1;
;;;1510       OS_TCB  *ptcb2;
;;;1511   
;;;1512   
;;;1513       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
0006fa  f44f61fd          MOV      r1,#0x7e8
0006fe  486e              LDR      r0,|L1.2232|
000700  f7fffffe          BL       OS_MemClr
;;;1514       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
000704  2180              MOVS     r1,#0x80
000706  485a              LDR      r0,|L1.2160|
000708  f7fffffe          BL       OS_MemClr
;;;1515       ptcb1 = &OSTCBTbl[0];
00070c  4b6a              LDR      r3,|L1.2232|
;;;1516       ptcb2 = &OSTCBTbl[1];
00070e  f103055c          ADD      r5,r3,#0x5c
;;;1517       for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
000712  2400              MOVS     r4,#0
000714  e00a              B        |L1.1836|
                  |L1.1814|
;;;1518           ptcb1->OSTCBNext = ptcb2;
000716  615d              STR      r5,[r3,#0x14]
;;;1519   #if OS_TASK_NAME_SIZE > 1
;;;1520           ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
000718  203f              MOVS     r0,#0x3f
00071a  f883004c          STRB     r0,[r3,#0x4c]
;;;1521           ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
00071e  2100              MOVS     r1,#0
000720  204d              MOVS     r0,#0x4d
000722  54c1              STRB     r1,[r0,r3]
;;;1522   #endif
;;;1523           ptcb1++;
000724  335c              ADDS     r3,r3,#0x5c
;;;1524           ptcb2++;
000726  355c              ADDS     r5,r5,#0x5c
000728  1c60              ADDS     r0,r4,#1              ;1517
00072a  b2c4              UXTB     r4,r0                 ;1517
                  |L1.1836|
00072c  2c15              CMP      r4,#0x15              ;1517
00072e  d3f2              BCC      |L1.1814|
;;;1525       }
;;;1526       ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
000730  2000              MOVS     r0,#0
000732  6158              STR      r0,[r3,#0x14]
;;;1527   #if OS_TASK_NAME_SIZE > 1
;;;1528       ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
000734  203f              MOVS     r0,#0x3f
000736  f883004c          STRB     r0,[r3,#0x4c]
;;;1529       ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
00073a  2100              MOVS     r1,#0
00073c  204d              MOVS     r0,#0x4d
00073e  54c1              STRB     r1,[r0,r3]
;;;1530   #endif
;;;1531       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000740  2000              MOVS     r0,#0
000742  495e              LDR      r1,|L1.2236|
000744  6008              STR      r0,[r1,#0]  ; OSTCBList
;;;1532       OSTCBFreeList           = &OSTCBTbl[0];
000746  485c              LDR      r0,|L1.2232|
000748  495d              LDR      r1,|L1.2240|
00074a  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1533   }
00074c  bd30              POP      {r4,r5,pc}
;;;1534   /*$PAGE*/
                          ENDP

                  OS_InitRdyList PROC
;;;1336   
;;;1337   static  void  OS_InitRdyList (void)
00074e  2200              MOVS     r2,#0
;;;1338   {
;;;1339       INT8U    i;
;;;1340   #if OS_LOWEST_PRIO <= 63
;;;1341       INT8U   *prdytbl;
;;;1342   #else
;;;1343       INT16U  *prdytbl;
;;;1344   #endif
;;;1345   
;;;1346   
;;;1347       OSRdyGrp      = 0;                                     /* Clear the ready list                     */
000750  4b5c              LDR      r3,|L1.2244|
000752  701a              STRB     r2,[r3,#0]
;;;1348       prdytbl       = &OSRdyTbl[0];
000754  495c              LDR      r1,|L1.2248|
;;;1349       for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
000756  2000              MOVS     r0,#0
000758  e004              B        |L1.1892|
                  |L1.1882|
;;;1350           *prdytbl++ = 0;
00075a  2200              MOVS     r2,#0
00075c  f8012b01          STRB     r2,[r1],#1
000760  1c42              ADDS     r2,r0,#1              ;1349
000762  b2d0              UXTB     r0,r2                 ;1349
                  |L1.1892|
000764  2804              CMP      r0,#4                 ;1349
000766  dbf8              BLT      |L1.1882|
;;;1351       }
;;;1352   
;;;1353       OSPrioCur     = 0;
000768  2200              MOVS     r2,#0
00076a  4b58              LDR      r3,|L1.2252|
00076c  701a              STRB     r2,[r3,#0]
;;;1354       OSPrioHighRdy = 0;
00076e  4b58              LDR      r3,|L1.2256|
000770  701a              STRB     r2,[r3,#0]
;;;1355   
;;;1356       OSTCBHighRdy  = (OS_TCB *)0;
000772  4b58              LDR      r3,|L1.2260|
000774  601a              STR      r2,[r3,#0]  ; OSTCBHighRdy
;;;1357       OSTCBCur      = (OS_TCB *)0;
000776  4b3d              LDR      r3,|L1.2156|
000778  601a              STR      r2,[r3,#0]  ; OSTCBCur
;;;1358   }
00077a  4770              BX       lr
;;;1359   
                          ENDP

                  OS_InitMisc PROC
;;;1300   
;;;1301   static  void  OS_InitMisc (void)
00077c  2000              MOVS     r0,#0
;;;1302   {
;;;1303   #if OS_TIME_GET_SET_EN > 0
;;;1304       OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
00077e  4956              LDR      r1,|L1.2264|
000780  6008              STR      r0,[r1,#0]  ; OSTime
;;;1305   #endif
;;;1306   
;;;1307       OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
000782  4956              LDR      r1,|L1.2268|
000784  7008              STRB     r0,[r1,#0]
;;;1308       OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
000786  4956              LDR      r1,|L1.2272|
000788  7008              STRB     r0,[r1,#0]
;;;1309   
;;;1310       OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
00078a  4956              LDR      r1,|L1.2276|
00078c  7008              STRB     r0,[r1,#0]
;;;1311   
;;;1312       OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
00078e  4956              LDR      r1,|L1.2280|
000790  7008              STRB     r0,[r1,#0]
;;;1313   
;;;1314       OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
000792  4956              LDR      r1,|L1.2284|
000794  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;1315       OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
000796  493a              LDR      r1,|L1.2176|
000798  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;1316   
;;;1317   #if OS_TASK_STAT_EN > 0
;;;1318       OSIdleCtrRun  = 0L;
00079a  493a              LDR      r1,|L1.2180|
00079c  6008              STR      r0,[r1,#0]  ; OSIdleCtrRun
;;;1319       OSIdleCtrMax  = 0L;
00079e  4936              LDR      r1,|L1.2168|
0007a0  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;1320       OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
0007a2  4934              LDR      r1,|L1.2164|
0007a4  7008              STRB     r0,[r1,#0]
;;;1321   #endif
;;;1322   }
0007a6  4770              BX       lr
;;;1323   /*$PAGE*/
                          ENDP

                  OSInit PROC
;;;553    
;;;554    void  OSInit (void)
0007a8  b510              PUSH     {r4,lr}
;;;555    {
;;;556        OSInitHookBegin();                                           /* Call port specific initialization code   */
0007aa  f7fffffe          BL       OSInitHookBegin
;;;557    
;;;558        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
0007ae  f7fffffe          BL       OS_InitMisc
;;;559    
;;;560        OS_InitRdyList();                                            /* Initialize the Ready List                */
0007b2  f7fffffe          BL       OS_InitRdyList
;;;561    
;;;562        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
0007b6  f7fffffe          BL       OS_InitTCBList
;;;563    
;;;564        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
0007ba  f7fffffe          BL       OS_InitEventList
;;;565    
;;;566    #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
;;;567        OS_FlagInit();                                               /* Initialize the event flag structures     */
0007be  f7fffffe          BL       OS_FlagInit
;;;568    #endif
;;;569    
;;;570    #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
;;;571        OS_MemInit();                                                /* Initialize the memory manager            */
0007c2  f7fffffe          BL       OS_MemInit
;;;572    #endif
;;;573    
;;;574    #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
;;;575        OS_QInit();                                                  /* Initialize the message queue structures  */
0007c6  f7fffffe          BL       OS_QInit
;;;576    #endif
;;;577    
;;;578        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
0007ca  f7fffffe          BL       OS_InitTaskIdle
;;;579    #if OS_TASK_STAT_EN > 0
;;;580        OS_InitTaskStat();                                           /* Create the Statistic Task                */
0007ce  f7fffffe          BL       OS_InitTaskStat
;;;581    #endif
;;;582    
;;;583    #if OS_TMR_EN > 0
;;;584        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;585    #endif
;;;586    
;;;587        OSInitHookEnd();                                             /* Call port specific init. code            */
0007d2  f7fffffe          BL       OSInitHookEnd
;;;588    
;;;589    #if OS_DEBUG_EN > 0
;;;590        OSDebugInit();
0007d6  f7fffffe          BL       OSDebugInit
;;;591    #endif
;;;592    }
0007da  bd10              POP      {r4,pc}
;;;593    /*$PAGE*/
                          ENDP

                  OSIntEnter PROC
;;;618    
;;;619    void  OSIntEnter (void)
0007dc  4842              LDR      r0,|L1.2280|
;;;620    {
;;;621        if (OSRunning == OS_TRUE) {
0007de  7800              LDRB     r0,[r0,#0]  ; OSRunning
0007e0  2801              CMP      r0,#1
0007e2  d108              BNE      |L1.2038|
;;;622            if (OSIntNesting < 255u) {
0007e4  483d              LDR      r0,|L1.2268|
0007e6  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0007e8  28ff              CMP      r0,#0xff
0007ea  d204              BCS      |L1.2038|
;;;623                OSIntNesting++;                      /* Increment ISR nesting level                        */
0007ec  483b              LDR      r0,|L1.2268|
0007ee  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0007f0  1c40              ADDS     r0,r0,#1
0007f2  493a              LDR      r1,|L1.2268|
0007f4  7008              STRB     r0,[r1,#0]
                  |L1.2038|
;;;624            }
;;;625        }
;;;626    }
0007f6  4770              BX       lr
;;;627    /*$PAGE*/
                          ENDP

                  OSIntExit PROC
;;;646    
;;;647    void  OSIntExit (void)
0007f8  b510              PUSH     {r4,lr}
;;;648    {
;;;649    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;650        OS_CPU_SR  cpu_sr = 0;
0007fa  2400              MOVS     r4,#0
;;;651    #endif
;;;652    
;;;653    
;;;654    
;;;655        if (OSRunning == OS_TRUE) {
0007fc  483a              LDR      r0,|L1.2280|
0007fe  7800              LDRB     r0,[r0,#0]  ; OSRunning
000800  2801              CMP      r0,#1
000802  d131              BNE      |L1.2152|
;;;656            OS_ENTER_CRITICAL();
000804  f7fffffe          BL       OS_CPU_SR_Save
000808  4604              MOV      r4,r0
;;;657            if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
00080a  4834              LDR      r0,|L1.2268|
00080c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00080e  2800              CMP      r0,#0
000810  dd04              BLE      |L1.2076|
;;;658                OSIntNesting--;
000812  4832              LDR      r0,|L1.2268|
000814  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000816  1e40              SUBS     r0,r0,#1
000818  4930              LDR      r1,|L1.2268|
00081a  7008              STRB     r0,[r1,#0]
                  |L1.2076|
;;;659            }
;;;660            if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
00081c  482f              LDR      r0,|L1.2268|
00081e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000820  b9f8              CBNZ     r0,|L1.2146|
;;;661                if (OSLockNesting == 0) {                      /* ... and not locked.                      */
000822  482f              LDR      r0,|L1.2272|
000824  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000826  b9e0              CBNZ     r0,|L1.2146|
;;;662                    OS_SchedNew();
000828  f7fffffe          BL       OS_SchedNew
;;;663                    
;;;664    /// ------- cy 101007   debug to V2.88  -------
;;;665    //                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
;;;666    //                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
;;;667                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00082c  4810              LDR      r0,|L1.2160|
00082e  4928              LDR      r1,|L1.2256|
000830  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000832  f8500021          LDR      r0,[r0,r1,LSL #2]
000836  4927              LDR      r1,|L1.2260|
000838  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;668                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00083a  4825              LDR      r0,|L1.2256|
00083c  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
00083e  4923              LDR      r1,|L1.2252|
000840  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000842  4288              CMP      r0,r1
000844  d00d              BEQ      |L1.2146|
;;;669    /// ------- cy 101007   debug to V2.88  -------
;;;670                        
;;;671    #if OS_TASK_PROFILE_EN > 0
;;;672                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000846  4823              LDR      r0,|L1.2260|
000848  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
00084a  6b80              LDR      r0,[r0,#0x38]
00084c  1c40              ADDS     r0,r0,#1
00084e  4921              LDR      r1,|L1.2260|
000850  6809              LDR      r1,[r1,#0]  ; OSTCBHighRdy
000852  6388              STR      r0,[r1,#0x38]
;;;673    #endif
;;;674                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
000854  4825              LDR      r0,|L1.2284|
000856  6800              LDR      r0,[r0,#0]  ; OSCtxSwCtr
000858  1c40              ADDS     r0,r0,#1
00085a  4924              LDR      r1,|L1.2284|
00085c  6008              STR      r0,[r1,#0]  ; OSCtxSwCtr
;;;675                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00085e  f7fffffe          BL       OSIntCtxSw
                  |L1.2146|
;;;676                    }
;;;677                }
;;;678            }
;;;679            OS_EXIT_CRITICAL();
000862  4620              MOV      r0,r4
000864  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2152|
;;;680        }
;;;681    }
000868  bd10              POP      {r4,pc}
00086a  0000              DCW      0x0000
                  |L1.2156|
                          DCD      OSTCBCur
                  |L1.2160|
                          DCD      OSTCBPrioTbl
                  |L1.2164|
                          DCD      OSStatRdy
                  |L1.2168|
                          DCD      OSIdleCtrMax
                  |L1.2172|
                          DCD      OSCPUUsage
                  |L1.2176|
                          DCD      OSIdleCtr
                  |L1.2180|
                          DCD      OSIdleCtrRun
                  |L1.2184|
                          DCD      OSTaskStatStk
                  |L1.2188|
00088c  75432f4f          DCB      "uC/OS-II Stat",0
000890  532d4949
000894  20537461
000898  7400    
00089a  00                DCB      0
00089b  00                DCB      0
                  |L1.2204|
                          DCD      OSTaskIdleStk
                  |L1.2208|
0008a0  75432f4f          DCB      "uC/OS-II Idle",0
0008a4  532d4949
0008a8  2049646c
0008ac  6500    
0008ae  00                DCB      0
0008af  00                DCB      0
                  |L1.2224|
                          DCD      OSEventTbl
                  |L1.2228|
                          DCD      OSEventFreeList
                  |L1.2232|
                          DCD      OSTCBTbl
                  |L1.2236|
                          DCD      OSTCBList
                  |L1.2240|
                          DCD      OSTCBFreeList
                  |L1.2244|
                          DCD      OSRdyGrp
                  |L1.2248|
                          DCD      OSRdyTbl
                  |L1.2252|
                          DCD      OSPrioCur
                  |L1.2256|
                          DCD      OSPrioHighRdy
                  |L1.2260|
                          DCD      OSTCBHighRdy
                  |L1.2264|
                          DCD      OSTime
                  |L1.2268|
                          DCD      OSIntNesting
                  |L1.2272|
                          DCD      OSLockNesting
                  |L1.2276|
                          DCD      OSTaskCtr
                  |L1.2280|
                          DCD      OSRunning
                  |L1.2284|
                          DCD      OSCtxSwCtr
                          ENDP

                  OSSchedLock PROC
;;;699    #if OS_SCHED_LOCK_EN > 0
;;;700    void  OSSchedLock (void)
0008f0  b510              PUSH     {r4,lr}
;;;701    {
;;;702    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;703        OS_CPU_SR  cpu_sr = 0;
0008f2  2400              MOVS     r4,#0
;;;704    #endif
;;;705    
;;;706    
;;;707    
;;;708        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
0008f4  48ff              LDR      r0,|L1.3316|
0008f6  7800              LDRB     r0,[r0,#0]  ; OSRunning
0008f8  2801              CMP      r0,#1
0008fa  d111              BNE      |L1.2336|
;;;709            OS_ENTER_CRITICAL();
0008fc  f7fffffe          BL       OS_CPU_SR_Save
000900  4604              MOV      r4,r0
;;;710            if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
000902  48fd              LDR      r0,|L1.3320|
000904  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000906  b940              CBNZ     r0,|L1.2330|
;;;711                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000908  48fc              LDR      r0,|L1.3324|
00090a  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00090c  28ff              CMP      r0,#0xff
00090e  d204              BCS      |L1.2330|
;;;712                    OSLockNesting++;                 /* Increment lock nesting level                       */
000910  48fa              LDR      r0,|L1.3324|
000912  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000914  1c40              ADDS     r0,r0,#1
000916  49f9              LDR      r1,|L1.3324|
000918  7008              STRB     r0,[r1,#0]
                  |L1.2330|
;;;713                }
;;;714            }
;;;715            OS_EXIT_CRITICAL();
00091a  4620              MOV      r0,r4
00091c  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2336|
;;;716        }
;;;717    }
000920  bd10              POP      {r4,pc}
;;;718    #endif
                          ENDP

                  OSSchedUnlock PROC
;;;736    #if OS_SCHED_LOCK_EN > 0
;;;737    void  OSSchedUnlock (void)
000922  b510              PUSH     {r4,lr}
;;;738    {
;;;739    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;740        OS_CPU_SR  cpu_sr = 0;
000924  2400              MOVS     r4,#0
;;;741    #endif
;;;742    
;;;743    
;;;744    
;;;745        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000926  48f3              LDR      r0,|L1.3316|
000928  7800              LDRB     r0,[r0,#0]  ; OSRunning
00092a  2801              CMP      r0,#1
00092c  d122              BNE      |L1.2420|
;;;746            OS_ENTER_CRITICAL();
00092e  f7fffffe          BL       OS_CPU_SR_Save
000932  4604              MOV      r4,r0
;;;747            if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
000934  48f1              LDR      r0,|L1.3324|
000936  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000938  2800              CMP      r0,#0
00093a  dd18              BLE      |L1.2414|
;;;748                OSLockNesting--;                               /* Decrement lock nesting level             */
00093c  48ef              LDR      r0,|L1.3324|
00093e  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000940  1e40              SUBS     r0,r0,#1
000942  49ee              LDR      r1,|L1.3324|
000944  7008              STRB     r0,[r1,#0]
;;;749                if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
000946  4608              MOV      r0,r1
000948  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
00094a  b960              CBNZ     r0,|L1.2406|
;;;750                    if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
00094c  48ea              LDR      r0,|L1.3320|
00094e  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000950  b928              CBNZ     r0,|L1.2398|
;;;751                        OS_EXIT_CRITICAL();
000952  4620              MOV      r0,r4
000954  f7fffffe          BL       OS_CPU_SR_Restore
;;;752                        OS_Sched();                            /* See if a HPT is ready                    */
000958  f7fffffe          BL       OS_Sched
00095c  e00a              B        |L1.2420|
                  |L1.2398|
;;;753                    } else {
;;;754                        OS_EXIT_CRITICAL();
00095e  4620              MOV      r0,r4
000960  f7fffffe          BL       OS_CPU_SR_Restore
000964  e006              B        |L1.2420|
                  |L1.2406|
;;;755                    }
;;;756                } else {
;;;757                    OS_EXIT_CRITICAL();
000966  4620              MOV      r0,r4
000968  f7fffffe          BL       OS_CPU_SR_Restore
00096c  e002              B        |L1.2420|
                  |L1.2414|
;;;758                }
;;;759            } else {
;;;760                OS_EXIT_CRITICAL();
00096e  4620              MOV      r0,r4
000970  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2420|
;;;761            }
;;;762        }
;;;763    }
000974  bd10              POP      {r4,pc}
;;;764    #endif
                          ENDP

                  OSStart PROC
;;;786    
;;;787    void  OSStart (void)
000976  b510              PUSH     {r4,lr}
;;;788    {
;;;789        if (OSRunning == OS_FALSE) {
000978  48de              LDR      r0,|L1.3316|
00097a  7800              LDRB     r0,[r0,#0]  ; OSRunning
00097c  b990              CBNZ     r0,|L1.2468|
;;;790            OS_SchedNew();                               /* Find highest priority's task priority number   */
00097e  f7fffffe          BL       OS_SchedNew
;;;791            OSPrioCur     = OSPrioHighRdy;
000982  48df              LDR      r0,|L1.3328|
000984  7800              LDRB     r0,[r0,#0]  ; OSPrioHighRdy
000986  49df              LDR      r1,|L1.3332|
000988  7008              STRB     r0,[r1,#0]
;;;792            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00098a  48df              LDR      r0,|L1.3336|
00098c  49dc              LDR      r1,|L1.3328|
00098e  7809              LDRB     r1,[r1,#0]  ; OSPrioHighRdy
000990  f8500021          LDR      r0,[r0,r1,LSL #2]
000994  49dd              LDR      r1,|L1.3340|
000996  6008              STR      r0,[r1,#0]  ; OSTCBHighRdy
;;;793            OSTCBCur      = OSTCBHighRdy;
000998  4608              MOV      r0,r1
00099a  6800              LDR      r0,[r0,#0]  ; OSTCBHighRdy
00099c  49dc              LDR      r1,|L1.3344|
00099e  6008              STR      r0,[r1,#0]  ; OSTCBCur
;;;794            OSStartHighRdy();                            /* Execute target specific code to start task     */
0009a0  f7fffffe          BL       OSStartHighRdy
                  |L1.2468|
;;;795        }
;;;796    }
0009a4  bd10              POP      {r4,pc}
;;;797    /*$PAGE*/
                          ENDP

                  OSStatInit PROC
;;;818    #if OS_TASK_STAT_EN > 0
;;;819    void  OSStatInit (void)
0009a6  b510              PUSH     {r4,lr}
;;;820    {
;;;821    #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
;;;822        OS_CPU_SR  cpu_sr = 0;
0009a8  2400              MOVS     r4,#0
;;;823    #endif
;;;824    
;;;825    
;;;826    
;;;827        OSTimeDly(2);                                /* Synchronize with clock tick                        */
0009aa  2002              MOVS     r0,#2
0009ac  f7fffffe          BL       OSTimeDly
;;;828        OS_ENTER_CRITICAL();
0009b0  f7fffffe          BL       OS_CPU_SR_Save
0009b4  4604              MOV      r4,r0
;;;829        OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
0009b6  2000              MOVS     r0,#0
0009b8  49d6              LDR      r1,|L1.3348|
0009ba  6008              STR      r0,[r1,#0]  ; OSIdleCtr
;;;830        OS_EXIT_CRITICAL();
0009bc  4620              MOV      r0,r4
0009be  f7fffffe          BL       OS_CPU_SR_Restore
;;;831        OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
0009c2  2064              MOVS     r0,#0x64
0009c4  f7fffffe          BL       OSTimeDly
;;;832        OS_ENTER_CRITICAL();
0009c8  f7fffffe          BL       OS_CPU_SR_Save
0009cc  4604              MOV      r4,r0
;;;833        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
0009ce  48d1              LDR      r0,|L1.3348|
0009d0  6800              LDR      r0,[r0,#0]  ; OSIdleCtr
0009d2  49d1              LDR      r1,|L1.3352|
0009d4  6008              STR      r0,[r1,#0]  ; OSIdleCtrMax
;;;834        OSStatRdy    = OS_TRUE;
0009d6  2001              MOVS     r0,#1
0009d8  49d0              LDR      r1,|L1.3356|
0009da  7008              STRB     r0,[r1,#0]
;;;835        OS_EXIT_CRITICAL();
0009dc  4620              MOV      r0,r4
0009de  f7fffffe          BL       OS_CPU_SR_Restore
;;;836    }
0009e2  bd10              POP      {r4,pc}
;;;837    #endif
                          ENDP

                  OSTimeTick PROC
;;;852    
;;;853    void  OSTimeTick (void)
0009e4  b570              PUSH     {r4-r6,lr}
;;;854    {
;;;855        OS_TCB    *ptcb;
;;;856    #if OS_TICK_STEP_EN > 0
;;;857        BOOLEAN    step;
;;;858    #endif
;;;859    #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
;;;860        OS_CPU_SR  cpu_sr = 0;
0009e6  2600              MOVS     r6,#0
;;;861    #endif
;;;862    
;;;863    
;;;864    
;;;865    #if OS_TIME_TICK_HOOK_EN > 0
;;;866        OSTimeTickHook();                                      /* Call user definable hook                     */
0009e8  f7fffffe          BL       OSTimeTickHook
;;;867    #endif
;;;868    #if OS_TIME_GET_SET_EN > 0
;;;869        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
0009ec  f7fffffe          BL       OS_CPU_SR_Save
0009f0  4606              MOV      r6,r0
;;;870        OSTime++;
0009f2  48cb              LDR      r0,|L1.3360|
0009f4  6800              LDR      r0,[r0,#0]  ; OSTime
0009f6  1c40              ADDS     r0,r0,#1
0009f8  49c9              LDR      r1,|L1.3360|
0009fa  6008              STR      r0,[r1,#0]  ; OSTime
;;;871        OS_EXIT_CRITICAL();
0009fc  4630              MOV      r0,r6
0009fe  f7fffffe          BL       OS_CPU_SR_Restore
;;;872    #endif
;;;873        if (OSRunning == OS_TRUE) {
000a02  48bc              LDR      r0,|L1.3316|
000a04  7800              LDRB     r0,[r0,#0]  ; OSRunning
000a06  2801              CMP      r0,#1
000a08  d158              BNE      |L1.2748|
;;;874    #if OS_TICK_STEP_EN > 0
;;;875            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
000a0a  48c6              LDR      r0,|L1.3364|
000a0c  7800              LDRB     r0,[r0,#0]  ; OSTickStepState
000a0e  b120              CBZ      r0,|L1.2586|
000a10  2801              CMP      r0,#1
000a12  d004              BEQ      |L1.2590|
000a14  2802              CMP      r0,#2
000a16  d109              BNE      |L1.2604|
000a18  e003              B        |L1.2594|
                  |L1.2586|
;;;876                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;877                     step = OS_TRUE;
000a1a  2501              MOVS     r5,#1
;;;878                     break;
000a1c  e00b              B        |L1.2614|
                  |L1.2590|
;;;879    
;;;880                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;881                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
000a1e  2500              MOVS     r5,#0
;;;882                     break;
000a20  e009              B        |L1.2614|
                  |L1.2594|
;;;883    
;;;884                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;885                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
000a22  2501              MOVS     r5,#1
;;;886                     OSTickStepState = OS_TICK_STEP_WAIT;
000a24  2001              MOVS     r0,#1
000a26  49bf              LDR      r1,|L1.3364|
000a28  7008              STRB     r0,[r1,#0]
;;;887                     break;
000a2a  e004              B        |L1.2614|
                  |L1.2604|
;;;888    
;;;889                default:                                       /* Invalid case, correct situation              */
;;;890                     step            = OS_TRUE;
000a2c  2501              MOVS     r5,#1
;;;891                     OSTickStepState = OS_TICK_STEP_DIS;
000a2e  2000              MOVS     r0,#0
000a30  49bc              LDR      r1,|L1.3364|
000a32  7008              STRB     r0,[r1,#0]
;;;892                     break;
000a34  bf00              NOP      
                  |L1.2614|
000a36  bf00              NOP                            ;878
;;;893            }
;;;894            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
000a38  b905              CBNZ     r5,|L1.2620|
                  |L1.2618|
;;;895                return;
;;;896            }
;;;897    #endif
;;;898            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;899            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
;;;900                OS_ENTER_CRITICAL();
;;;901                if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
;;;902                    if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
;;;903                                                               /* Check for timeout                            */
;;;904                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
;;;905                            ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
;;;906                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
;;;907                        } else {
;;;908                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
;;;909                        }
;;;910    
;;;911                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
;;;912                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
;;;913                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
;;;914                        }
;;;915                    }
;;;916                }
;;;917                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
;;;918                OS_EXIT_CRITICAL();
;;;919            }
;;;920        }
;;;921    }
000a3a  bd70              POP      {r4-r6,pc}
                  |L1.2620|
000a3c  48ba              LDR      r0,|L1.3368|
000a3e  6804              LDR      r4,[r0,#0]            ;898  ; OSTCBList
000a40  e038              B        |L1.2740|
                  |L1.2626|
000a42  f7fffffe          BL       OS_CPU_SR_Save
000a46  4606              MOV      r6,r0                 ;900
000a48  8de0              LDRH     r0,[r4,#0x2e]         ;901
000a4a  b378              CBZ      r0,|L1.2732|
000a4c  8de0              LDRH     r0,[r4,#0x2e]         ;902
000a4e  1e40              SUBS     r0,r0,#1              ;902
000a50  0400              LSLS     r0,r0,#16             ;902
000a52  0c00              LSRS     r0,r0,#16             ;902
000a54  85e0              STRH     r0,[r4,#0x2e]         ;902
000a56  d129              BNE      |L1.2732|
000a58  f8940030          LDRB     r0,[r4,#0x30]         ;904
000a5c  f0100f37          TST      r0,#0x37              ;904
000a60  d009              BEQ      |L1.2678|
000a62  f8140f30          LDRB     r0,[r4,#0x30]!        ;905
000a66  f0200037          BIC      r0,r0,#0x37           ;905
000a6a  7020              STRB     r0,[r4,#0]            ;905
000a6c  2001              MOVS     r0,#1                 ;906
000a6e  7060              STRB     r0,[r4,#1]            ;906
000a70  f1a40430          SUB      r4,r4,#0x30           ;906
000a74  e002              B        |L1.2684|
                  |L1.2678|
000a76  2000              MOVS     r0,#0                 ;908
000a78  f8840031          STRB     r0,[r4,#0x31]         ;908
                  |L1.2684|
000a7c  f8940030          LDRB     r0,[r4,#0x30]         ;911
000a80  f0100f08          TST      r0,#8                 ;911
000a84  d112              BNE      |L1.2732|
000a86  f1040434          ADD      r4,r4,#0x34           ;912
000a8a  78a0              LDRB     r0,[r4,#2]            ;912
000a8c  49a7              LDR      r1,|L1.3372|
000a8e  7809              LDRB     r1,[r1,#0]            ;912  ; OSRdyGrp
000a90  ea400001          ORR      r0,r0,r1              ;912
000a94  49a5              LDR      r1,|L1.3372|
000a96  7008              STRB     r0,[r1,#0]            ;912
000a98  7820              LDRB     r0,[r4,#0]            ;913
000a9a  49a5              LDR      r1,|L1.3376|
000a9c  5c08              LDRB     r0,[r1,r0]            ;913
000a9e  7861              LDRB     r1,[r4,#1]            ;913
000aa0  ea400001          ORR      r0,r0,r1              ;913
000aa4  f8141934          LDRB     r1,[r4],#-0x34        ;913
000aa8  4aa1              LDR      r2,|L1.3376|
000aaa  5450              STRB     r0,[r2,r1]            ;913
                  |L1.2732|
000aac  6964              LDR      r4,[r4,#0x14]         ;917
000aae  4630              MOV      r0,r6                 ;918
000ab0  f7fffffe          BL       OS_CPU_SR_Restore
                  |L1.2740|
000ab4  f8940032          LDRB     r0,[r4,#0x32]         ;899
000ab8  281f              CMP      r0,#0x1f              ;899
000aba  d1c2              BNE      |L1.2626|
                  |L1.2748|
000abc  bf00              NOP      
000abe  e7bc              B        |L1.2618|
;;;922    
                          ENDP

                  OSVersion PROC
;;;937    
;;;938    INT16U  OSVersion (void)
000ac0  f44f708f          MOV      r0,#0x11e
;;;939    {
;;;940        return (OS_VERSION);
;;;941    }
000ac4  4770              BX       lr
;;;942    
                          ENDP

                  OS_Dummy PROC
;;;956    #if OS_TASK_DEL_EN > 0
;;;957    void  OS_Dummy (void)
000ac6  4770              BX       lr
;;;958    {
;;;959    }
;;;960    #endif
                          ENDP

                  OS_EventTaskRemove PROC
;;;1139   #if (OS_EVENT_EN)
;;;1140   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000ac8  b510              PUSH     {r4,lr}
;;;1141                             OS_EVENT *pevent)
;;;1142   {
;;;1143       INT8U  y;
;;;1144   
;;;1145   
;;;1146       y                       =  ptcb->OSTCBY;
000aca  f8902034          LDRB     r2,[r0,#0x34]
;;;1147       pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
000ace  f101030b          ADD      r3,r1,#0xb
000ad2  5c9b              LDRB     r3,[r3,r2]
000ad4  f8904035          LDRB     r4,[r0,#0x35]
000ad8  43a3              BICS     r3,r3,r4
000ada  f101040b          ADD      r4,r1,#0xb
000ade  54a3              STRB     r3,[r4,r2]
;;;1148       if (pevent->OSEventTbl[y] == 0) {
000ae0  4623              MOV      r3,r4
000ae2  5c9b              LDRB     r3,[r3,r2]
000ae4  b923              CBNZ     r3,|L1.2800|
;;;1149           pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
000ae6  7a8b              LDRB     r3,[r1,#0xa]
000ae8  f8904036          LDRB     r4,[r0,#0x36]
000aec  43a3              BICS     r3,r3,r4
000aee  728b              STRB     r3,[r1,#0xa]
                  |L1.2800|
;;;1150       }
;;;1151   }
000af0  bd10              POP      {r4,pc}
;;;1152   #endif
                          ENDP

                  OS_EventTaskRdy PROC
;;;990    #if (OS_EVENT_EN)
;;;991    INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
000af2  e92d4ff0          PUSH     {r4-r11,lr}
;;;992    {
000af6  4605              MOV      r5,r0
000af8  460f              MOV      r7,r1
000afa  4690              MOV      r8,r2
000afc  4699              MOV      r9,r3
;;;993        OS_TCB  *ptcb;
;;;994        INT8U    y;
;;;995        INT8U    x;
;;;996        INT8U    prio;
;;;997    #if OS_LOWEST_PRIO > 63
;;;998        INT16U  *ptbl;
;;;999    #endif
;;;1000   
;;;1001   
;;;1002   #if OS_LOWEST_PRIO <= 63
;;;1003       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000afe  7aa8              LDRB     r0,[r5,#0xa]
000b00  498c              LDR      r1,|L1.3380|
000b02  5c0e              LDRB     r6,[r1,r0]
;;;1004       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
000b04  f105000b          ADD      r0,r5,#0xb
000b08  5d80              LDRB     r0,[r0,r6]
000b0a  f811b000          LDRB     r11,[r1,r0]
;;;1005       prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
000b0e  eb0b00c6          ADD      r0,r11,r6,LSL #3
000b12  f0000aff          AND      r10,r0,#0xff
;;;1006   #else
;;;1007       if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
;;;1008           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFF];
;;;1009       } else {
;;;1010           y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
;;;1011       }
;;;1012       ptbl = &pevent->OSEventTbl[y];
;;;1013       if ((*ptbl & 0xFF) != 0) {
;;;1014           x = OSUnMapTbl[*ptbl & 0xFF];
;;;1015       } else {
;;;1016           x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
;;;1017       }
;;;1018       prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
;;;1019   #endif
;;;1020   
;;;1021       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
000b16  487c              LDR      r0,|L1.3336|
000b18  f850402a          LDR      r4,[r0,r10,LSL #2]
;;;1022       ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
000b1c  2000              MOVS     r0,#0
000b1e  f1040424          ADD      r4,r4,#0x24
000b22  8160              STRH     r0,[r4,#0xa]
;;;1023   #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
;;;1024       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
000b24  6027              STR      r7,[r4,#0]
;;;1025   #else
;;;1026       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1027   #endif
;;;1028       ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
000b26  7b20              LDRB     r0,[r4,#0xc]
000b28  ea200008          BIC      r0,r0,r8
000b2c  7320              STRB     r0,[r4,#0xc]
;;;1029       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000b2e  f884900d          STRB     r9,[r4,#0xd]
;;;1030                                                           /* See if task is ready (could be susp'd)      */
;;;1031       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
000b32  7b20              LDRB     r0,[r4,#0xc]
000b34  f1a40424          SUB      r4,r4,#0x24
000b38  f0100f08          TST      r0,#8
000b3c  d10d              BNE      |L1.2906|
;;;1032           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
000b3e  f8940036          LDRB     r0,[r4,#0x36]
000b42  497a              LDR      r1,|L1.3372|
000b44  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000b46  4308              ORRS     r0,r0,r1
000b48  4978              LDR      r1,|L1.3372|
000b4a  7008              STRB     r0,[r1,#0]
;;;1033           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
000b4c  4878              LDR      r0,|L1.3376|
000b4e  5d80              LDRB     r0,[r0,r6]
000b50  f8941035          LDRB     r1,[r4,#0x35]
000b54  4308              ORRS     r0,r0,r1
000b56  4976              LDR      r1,|L1.3376|
000b58  5588              STRB     r0,[r1,r6]
                  |L1.2906|
;;;1034       }
;;;1035   
;;;1036       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000b5a  4629              MOV      r1,r5
000b5c  4620              MOV      r0,r4
000b5e  f7fffffe          BL       OS_EventTaskRemove
;;;1037   #if (OS_EVENT_MULTI_EN > 0)
;;;1038       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
000b62  6a20              LDR      r0,[r4,#0x20]
000b64  b120              CBZ      r0,|L1.2928|
;;;1039           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
000b66  4620              MOV      r0,r4
000b68  6a21              LDR      r1,[r4,#0x20]
000b6a  f7fffffe          BL       OS_EventTaskRemoveMulti
;;;1040           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
000b6e  61e5              STR      r5,[r4,#0x1c]
                  |L1.2928|
;;;1041       }
;;;1042   #endif
;;;1043   
;;;1044       return (prio);
000b70  4650              MOV      r0,r10
;;;1045   }
000b72  e8bd8ff0          POP      {r4-r11,pc}
;;;1046   #endif
                          ENDP

                  OS_EventTaskWait PROC
;;;1062   #if (OS_EVENT_EN)
;;;1063   void  OS_EventTaskWait (OS_EVENT *pevent)
000b76  b510              PUSH     {r4,lr}
;;;1064   {
;;;1065       INT8U  y;
;;;1066   
;;;1067   
;;;1068       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000b78  4a65              LDR      r2,|L1.3344|
000b7a  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000b7c  61d0              STR      r0,[r2,#0x1c]
;;;1069   
;;;1070       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000b7e  4a64              LDR      r2,|L1.3344|
000b80  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000b82  f8923034          LDRB     r3,[r2,#0x34]
000b86  f100020b          ADD      r2,r0,#0xb
000b8a  5cd2              LDRB     r2,[r2,r3]
000b8c  4b60              LDR      r3,|L1.3344|
000b8e  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000b90  f8933035          LDRB     r3,[r3,#0x35]
000b94  431a              ORRS     r2,r2,r3
000b96  4b5e              LDR      r3,|L1.3344|
000b98  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000b9a  f8934034          LDRB     r4,[r3,#0x34]
000b9e  f100030b          ADD      r3,r0,#0xb
000ba2  551a              STRB     r2,[r3,r4]
;;;1071       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000ba4  7a82              LDRB     r2,[r0,#0xa]
000ba6  4b5a              LDR      r3,|L1.3344|
000ba8  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000baa  f8933036          LDRB     r3,[r3,#0x36]
000bae  431a              ORRS     r2,r2,r3
000bb0  7282              STRB     r2,[r0,#0xa]
;;;1072   
;;;1073       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000bb2  4a57              LDR      r2,|L1.3344|
000bb4  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000bb6  f8921034          LDRB     r1,[r2,#0x34]
;;;1074       OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
000bba  4a5d              LDR      r2,|L1.3376|
000bbc  5c52              LDRB     r2,[r2,r1]
000bbe  4b54              LDR      r3,|L1.3344|
000bc0  681b              LDR      r3,[r3,#0]  ; OSTCBCur
000bc2  f8933035          LDRB     r3,[r3,#0x35]
000bc6  439a              BICS     r2,r2,r3
000bc8  4b59              LDR      r3,|L1.3376|
000bca  545a              STRB     r2,[r3,r1]
;;;1075       if (OSRdyTbl[y] == 0) {
000bcc  461a              MOV      r2,r3
000bce  5c52              LDRB     r2,[r2,r1]
000bd0  b942              CBNZ     r2,|L1.3044|
;;;1076           OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
000bd2  4a4f              LDR      r2,|L1.3344|
000bd4  6812              LDR      r2,[r2,#0]  ; OSTCBCur
000bd6  f8923036          LDRB     r3,[r2,#0x36]
000bda  4a54              LDR      r2,|L1.3372|
000bdc  7812              LDRB     r2,[r2,#0]  ; OSRdyGrp
000bde  439a              BICS     r2,r2,r3
000be0  4b52              LDR      r3,|L1.3372|
000be2  701a              STRB     r2,[r3,#0]
                  |L1.3044|
;;;1077       }
;;;1078   }
000be4  bd10              POP      {r4,pc}
;;;1079   #endif
                          ENDP

                  OS_EventWaitListInit PROC
;;;1214   #if (OS_EVENT_EN)
;;;1215   void  OS_EventWaitListInit (OS_EVENT *pevent)
000be6  2300              MOVS     r3,#0
;;;1216   {
;;;1217   #if OS_LOWEST_PRIO <= 63
;;;1218       INT8U  *ptbl;
;;;1219   #else
;;;1220       INT16U *ptbl;
;;;1221   #endif
;;;1222       INT8U   i;
;;;1223   
;;;1224   
;;;1225       pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
000be8  7283              STRB     r3,[r0,#0xa]
;;;1226       ptbl               = &pevent->OSEventTbl[0];
000bea  f100010b          ADD      r1,r0,#0xb
;;;1227   
;;;1228       for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
000bee  2200              MOVS     r2,#0
000bf0  e004              B        |L1.3068|
                  |L1.3058|
;;;1229           *ptbl++ = 0;
000bf2  2300              MOVS     r3,#0
000bf4  f8013b01          STRB     r3,[r1],#1
000bf8  1c53              ADDS     r3,r2,#1              ;1228
000bfa  b2da              UXTB     r2,r3                 ;1228
                  |L1.3068|
000bfc  2a04              CMP      r2,#4                 ;1228
000bfe  dbf8              BLT      |L1.3058|
;;;1230       }
;;;1231   }
000c00  4770              BX       lr
;;;1232   #endif
                          ENDP

                  OS_MemCopy PROC
;;;1586   
;;;1587   void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
000c02  e005              B        |L1.3088|
                  |L1.3076|
;;;1588   {
;;;1589       while (size > 0) {
;;;1590           *pdest++ = *psrc++;
000c04  f8113b01          LDRB     r3,[r1],#1
000c08  f8003b01          STRB     r3,[r0],#1
;;;1591           size--;
000c0c  1e53              SUBS     r3,r2,#1
000c0e  b29a              UXTH     r2,r3
                  |L1.3088|
000c10  2a00              CMP      r2,#0                 ;1589
000c12  dcf7              BGT      |L1.3076|
;;;1592       }
;;;1593   }
000c14  4770              BX       lr
;;;1594   /*$PAGE*/
                          ENDP

                  OS_TCBInit PROC
;;;1933   
;;;1934   INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
000c16  e92d4ff8          PUSH     {r3-r11,lr}
;;;1935   {
000c1a  4605              MOV      r5,r0
000c1c  460e              MOV      r6,r1
000c1e  4617              MOV      r7,r2
000c20  4698              MOV      r8,r3
000c22  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000c26  f8dd9028          LDR      r9,[sp,#0x28]
;;;1936       OS_TCB    *ptcb;
;;;1937   #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
;;;1938       OS_CPU_SR  cpu_sr = 0;
000c2a  2000              MOVS     r0,#0
000c2c  9000              STR      r0,[sp,#0]
;;;1939   #endif
;;;1940   
;;;1941   
;;;1942   
;;;1943       OS_ENTER_CRITICAL();
000c2e  f7fffffe          BL       OS_CPU_SR_Save
000c32  9000              STR      r0,[sp,#0]
;;;1944       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000c34  4840              LDR      r0,|L1.3384|
000c36  6804              LDR      r4,[r0,#0]  ; OSTCBFreeList
;;;1945       if (ptcb != (OS_TCB *)0) {
000c38  b3ec              CBZ      r4,|L1.3254|
;;;1946           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
000c3a  f1040418          ADD      r4,r4,#0x18
000c3e  f8540c04          LDR      r0,[r4,#-4]
000c42  493d              LDR      r1,|L1.3384|
000c44  6008              STR      r0,[r1,#0]  ; OSTCBFreeList
;;;1947           OS_EXIT_CRITICAL();
000c46  9800              LDR      r0,[sp,#0]
000c48  f7fffffe          BL       OS_CPU_SR_Restore
;;;1948           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000c4c  f8446c18          STR      r6,[r4,#-0x18]
;;;1949           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
000c50  76a5              STRB     r5,[r4,#0x1a]
;;;1950           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
000c52  2000              MOVS     r0,#0
000c54  7620              STRB     r0,[r4,#0x18]
;;;1951           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000c56  7660              STRB     r0,[r4,#0x19]
;;;1952           ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
000c58  82e0              STRH     r0,[r4,#0x16]
;;;1953   
;;;1954   #if OS_TASK_CREATE_EXT_EN > 0
;;;1955           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000c5a  f844ac14          STR      r10,[r4,#-0x14]
;;;1956           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
000c5e  f8449c0c          STR      r9,[r4,#-0xc]
;;;1957           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
000c62  f8447c10          STR      r7,[r4,#-0x10]
;;;1958           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000c66  f824bc08          STRH     r11,[r4,#-8]
;;;1959           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000c6a  f8248c06          STRH     r8,[r4,#-6]
;;;1960   #else
;;;1961           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1962           stk_size                 = stk_size;
;;;1963           pbos                     = pbos;
;;;1964           opt                      = opt;
;;;1965           id                       = id;
;;;1966   #endif
;;;1967   
;;;1968   #if OS_TASK_DEL_EN > 0
;;;1969           ptcb->OSTCBDelReq        = OS_ERR_NONE;
000c6e  77e0              STRB     r0,[r4,#0x1f]
;;;1970   #endif
;;;1971   
;;;1972   #if OS_LOWEST_PRIO <= 63
;;;1973           ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
000c70  10e8              ASRS     r0,r5,#3
000c72  7720              STRB     r0,[r4,#0x1c]
;;;1974           ptcb->OSTCBX             = (INT8U)(prio & 0x07);
000c74  f0050007          AND      r0,r5,#7
000c78  76e0              STRB     r0,[r4,#0x1b]
;;;1975           ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
000c7a  7f21              LDRB     r1,[r4,#0x1c]
000c7c  2001              MOVS     r0,#1
000c7e  4088              LSLS     r0,r0,r1
000c80  77a0              STRB     r0,[r4,#0x1e]
;;;1976           ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
000c82  7ee1              LDRB     r1,[r4,#0x1b]
000c84  2001              MOVS     r0,#1
000c86  4088              LSLS     r0,r0,r1
000c88  7760              STRB     r0,[r4,#0x1d]
;;;1977   #else
;;;1978           ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* Pre-compute X, Y, BitX and BitY     */
;;;1979           ptcb->OSTCBX             = (INT8U) (prio & 0x0F);
;;;1980           ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
;;;1981           ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
;;;1982   #endif
;;;1983   
;;;1984   #if (OS_EVENT_EN)
;;;1985           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000c8a  2000              MOVS     r0,#0
000c8c  6060              STR      r0,[r4,#4]
;;;1986   #if (OS_EVENT_MULTI_EN > 0)
;;;1987           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000c8e  60a0              STR      r0,[r4,#8]
;;;1988   #endif
;;;1989   #endif
;;;1990   
;;;1991   #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
;;;1992           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000c90  6120              STR      r0,[r4,#0x10]
;;;1993   #endif
;;;1994   
;;;1995   #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
;;;1996           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000c92  60e0              STR      r0,[r4,#0xc]
;;;1997   #endif
;;;1998   
;;;1999   #if OS_TASK_PROFILE_EN > 0
;;;2000           ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
000c94  6220              STR      r0,[r4,#0x20]
;;;2001           ptcb->OSTCBCyclesStart = 0L;
000c96  62a0              STR      r0,[r4,#0x28]
;;;2002           ptcb->OSTCBCyclesTot   = 0L;
000c98  6260              STR      r0,[r4,#0x24]
;;;2003           ptcb->OSTCBStkBase     = (OS_STK *)0;
000c9a  62e0              STR      r0,[r4,#0x2c]
;;;2004           ptcb->OSTCBStkUsed     = 0L;
000c9c  6320              STR      r0,[r4,#0x30]
;;;2005   #endif
;;;2006   
;;;2007   #if OS_TASK_NAME_SIZE > 1
;;;2008           ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
000c9e  203f              MOVS     r0,#0x3f
000ca0  f8840034          STRB     r0,[r4,#0x34]
000ca4  f1a40418          SUB      r4,r4,#0x18
;;;2009           ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
000ca8  f04f0100          MOV      r1,#0
000cac  f04f004d          MOV      r0,#0x4d
000cb0  5501              STRB     r1,[r0,r4]
;;;2010   #endif
;;;2011   
;;;2012           OSTCBInitHook(ptcb);
000cb2  4620              MOV      r0,r4
000cb4  e000              B        |L1.3256|
                  |L1.3254|
000cb6  e05b              B        |L1.3440|
                  |L1.3256|
000cb8  f7fffffe          BL       OSTCBInitHook
;;;2013   
;;;2014           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
000cbc  4620              MOV      r0,r4
000cbe  f7fffffe          BL       OSTaskCreateHook
;;;2015   
;;;2016           OS_ENTER_CRITICAL();
000cc2  f7fffffe          BL       OS_CPU_SR_Save
000cc6  9000              STR      r0,[sp,#0]
;;;2017           OSTCBPrioTbl[prio] = ptcb;
000cc8  480f              LDR      r0,|L1.3336|
000cca  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2018           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
000cce  4816              LDR      r0,|L1.3368|
000cd0  6800              LDR      r0,[r0,#0]  ; OSTCBList
000cd2  6160              STR      r0,[r4,#0x14]
;;;2019           ptcb->OSTCBPrev    = (OS_TCB *)0;
000cd4  2000              MOVS     r0,#0
000cd6  61a0              STR      r0,[r4,#0x18]
;;;2020           if (OSTCBList != (OS_TCB *)0) {
000cd8  4813              LDR      r0,|L1.3368|
000cda  6800              LDR      r0,[r0,#0]  ; OSTCBList
000cdc  b110              CBZ      r0,|L1.3300|
;;;2021               OSTCBList->OSTCBPrev = ptcb;
000cde  4812              LDR      r0,|L1.3368|
000ce0  6800              LDR      r0,[r0,#0]  ; OSTCBList
000ce2  6184              STR      r4,[r0,#0x18]
                  |L1.3300|
;;;2022           }
;;;2023           OSTCBList               = ptcb;
000ce4  4810              LDR      r0,|L1.3368|
000ce6  6004              STR      r4,[r0,#0]  ; OSTCBList
;;;2024           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
000ce8  f1040434          ADD      r4,r4,#0x34
000cec  78a0              LDRB     r0,[r4,#2]
000cee  490f              LDR      r1,|L1.3372|
000cf0  7809              LDRB     r1,[r1,#0]  ; OSRdyGrp
000cf2  e023              B        |L1.3388|
                  |L1.3316|
                          DCD      OSRunning
                  |L1.3320|
                          DCD      OSIntNesting
                  |L1.3324|
                          DCD      OSLockNesting
                  |L1.3328|
                          DCD      OSPrioHighRdy
                  |L1.3332|
                          DCD      OSPrioCur
                  |L1.3336|
                          DCD      OSTCBPrioTbl
                  |L1.3340|
                          DCD      OSTCBHighRdy
                  |L1.3344|
                          DCD      OSTCBCur
                  |L1.3348|
                          DCD      OSIdleCtr
                  |L1.3352|
                          DCD      OSIdleCtrMax
                  |L1.3356|
                          DCD      OSStatRdy
                  |L1.3360|
                          DCD      OSTime
                  |L1.3364|
                          DCD      OSTickStepState
                  |L1.3368|
                          DCD      OSTCBList
                  |L1.3372|
                          DCD      OSRdyGrp
                  |L1.3376|
                          DCD      OSRdyTbl
                  |L1.3380|
                          DCD      OSUnMapTbl
                  |L1.3384|
                          DCD      OSTCBFreeList
                  |L1.3388|
000d3c  ea400001          ORR      r0,r0,r1
000d40  490e              LDR      r1,|L1.3452|
000d42  7008              STRB     r0,[r1,#0]
;;;2025           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000d44  7820              LDRB     r0,[r4,#0]
000d46  490e              LDR      r1,|L1.3456|
000d48  5c08              LDRB     r0,[r1,r0]
000d4a  7861              LDRB     r1,[r4,#1]
000d4c  ea400001          ORR      r0,r0,r1
000d50  f8141934          LDRB     r1,[r4],#-0x34
000d54  4a0a              LDR      r2,|L1.3456|
000d56  5450              STRB     r0,[r2,r1]
;;;2026           OSTaskCtr++;                                       /* Increment the #tasks counter             */
000d58  480a              LDR      r0,|L1.3460|
000d5a  7800              LDRB     r0,[r0,#0]  ; OSTaskCtr
000d5c  f1000001          ADD      r0,r0,#1
000d60  4908              LDR      r1,|L1.3460|
000d62  7008              STRB     r0,[r1,#0]
;;;2027           OS_EXIT_CRITICAL();
000d64  9800              LDR      r0,[sp,#0]
000d66  f7fffffe          BL       OS_CPU_SR_Restore
;;;2028           return (OS_ERR_NONE);
000d6a  2000              MOVS     r0,#0
                  |L1.3436|
;;;2029       }
;;;2030       OS_EXIT_CRITICAL();
;;;2031       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2032   }
000d6c  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.3440|
000d70  9800              LDR      r0,[sp,#0]            ;2030
000d72  f7fffffe          BL       OS_CPU_SR_Restore
000d76  2042              MOVS     r0,#0x42              ;2031
000d78  e7f8              B        |L1.3436|
                          ENDP

000d7a  0000              DCW      0x0000
                  |L1.3452|
                          DCD      OSRdyGrp
                  |L1.3456|
                          DCD      OSRdyTbl
                  |L1.3460|
                          DCD      OSTaskCtr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        640
                  OSFlagTbl
                          %        140
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        128
                  OSTCBTbl
                          %        2024
                  OSMemTbl
                          %        180
                  OSQTbl
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSFlagFreeList
                          DCD      0x00000000
                  OSCPUUsage
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSStatRdy
000018  00                DCB      0x00
                  OSIntNesting
000019  00                DCB      0x00
                  OSLockNesting
00001a  00                DCB      0x00
                  OSPrioCur
00001b  00                DCB      0x00
                  OSPrioHighRdy
00001c  00                DCB      0x00
                  OSRdyGrp
00001d  00                DCB      0x00
                  OSRdyTbl
00001e  0000              DCB      0x00,0x00
000020  0000              DCB      0x00,0x00
                  OSRunning
000022  00                DCB      0x00
                  OSTaskCtr
000023  00                DCB      0x00
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTickStepState
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  OSMemFreeList
                          DCD      0x00000000
                  OSQFreeList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
