; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\stm32f10x_it.o --depend=.\exe\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\stm32f10x_it.crf ..\Source\APP\stm32f10x_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  IrqDelayMs PROC
;;;87     /// -----------------------------------------------------------------------------------------------------
;;;88     static  void  IrqDelayMs (u32 time)
000000  4601              MOV      r1,r0
;;;89     {
;;;90         vu32  i;
;;;91         vu32  j;
;;;92         
;;;93         
;;;94         for (j = time; j != 0; j--) {
000002  e006              B        |L1.18|
                  |L1.4|
;;;95             for (i = 8000; i != 0; i--) {
000004  f44f52fa          MOV      r2,#0x1f40
000008  e000              B        |L1.12|
                  |L1.10|
00000a  1e52              SUBS     r2,r2,#1
                  |L1.12|
00000c  2a00              CMP      r2,#0
00000e  d1fc              BNE      |L1.10|
000010  1e49              SUBS     r1,r1,#1              ;94
                  |L1.18|
000012  2900              CMP      r1,#0                 ;94
000014  d1f6              BNE      |L1.4|
;;;96                 ;
;;;97             }
;;;98         }
;;;99     }
000016  4770              BX       lr
;;;100    
                          ENDP

                  DispErrNo PROC
;;;101    static  void  DispErrNo (u32 n)
000018  b570              PUSH     {r4-r6,lr}
;;;102    {
00001a  4604              MOV      r4,r0
;;;103        vu32  i;
;;;104        
;;;105        
;;;106        BSP_LED_Set(0, BSP_LED_ON);
00001c  2100              MOVS     r1,#0
00001e  4608              MOV      r0,r1
000020  f7fffffe          BL       BSP_LED_Set
;;;107    
;;;108        BSP_LED_Set(1, BSP_LED_ON);
000024  2100              MOVS     r1,#0
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       BSP_LED_Set
;;;109        IrqDelayMs(250);
00002c  20fa              MOVS     r0,#0xfa
00002e  f7fffffe          BL       IrqDelayMs
;;;110            
;;;111        BSP_LED_Toggle(0);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       BSP_LED_Toggle
;;;112        BSP_LED_Toggle(1);
000038  2001              MOVS     r0,#1
00003a  f7fffffe          BL       BSP_LED_Toggle
;;;113        IrqDelayMs(250);
00003e  20fa              MOVS     r0,#0xfa
000040  f7fffffe          BL       IrqDelayMs
;;;114            
;;;115        for (i = 0; i < n; i++) {
000044  2500              MOVS     r5,#0
000046  e00c              B        |L1.98|
                  |L1.72|
;;;116            BSP_LED_Toggle(1);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       BSP_LED_Toggle
;;;117            IrqDelayMs(250);
00004e  20fa              MOVS     r0,#0xfa
000050  f7fffffe          BL       IrqDelayMs
;;;118            BSP_LED_Toggle(1);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       BSP_LED_Toggle
;;;119            IrqDelayMs(250);
00005a  20fa              MOVS     r0,#0xfa
00005c  f7fffffe          BL       IrqDelayMs
000060  1c6d              ADDS     r5,r5,#1              ;115
                  |L1.98|
000062  42a5              CMP      r5,r4                 ;115
000064  d3f0              BCC      |L1.72|
;;;120        }
;;;121    }
000066  bd70              POP      {r4-r6,pc}
;;;122    /// cy 101004   a
                          ENDP

                  NMI_Handler PROC
;;;129      */
;;;130    void NMI_Handler(void)
000068  bf00              NOP      
                  |L1.106|
;;;131    {
;;;132        /// cy 101004   a
;;;133        for ( ; ; ) {
;;;134            DispErrNo(1);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       DispErrNo
000070  e7fb              B        |L1.106|
;;;135        }
;;;136        /// cy 101004   a
;;;137    }
;;;138    
                          ENDP

                  HardFault_Handler PROC
;;;143      */
;;;144    void HardFault_Handler(void)
000072  bf00              NOP      
                  |L1.116|
;;;145    {
;;;146        /// cy 101004   m
;;;147    //  /* Go to infinite loop when Hard Fault exception occurs */
;;;148    //  while (1)
;;;149    //  {
;;;150    //  }
;;;151    
;;;152        for ( ; ; ) {
;;;153            DispErrNo(2);
000074  2002              MOVS     r0,#2
000076  f7fffffe          BL       DispErrNo
00007a  e7fb              B        |L1.116|
;;;154        }
;;;155        /// cy 101004   m
;;;156    }
;;;157    
                          ENDP

                  MemManage_Handler PROC
;;;162      */
;;;163    void MemManage_Handler(void)
00007c  bf00              NOP      
                  |L1.126|
;;;164    {
;;;165        /// cy 101004   m
;;;166    //  /* Go to infinite loop when Memory Manage exception occurs */
;;;167    //  while (1)
;;;168    //  {
;;;169    //  }
;;;170    
;;;171        for ( ; ; ) {
;;;172            DispErrNo(3);
00007e  2003              MOVS     r0,#3
000080  f7fffffe          BL       DispErrNo
000084  e7fb              B        |L1.126|
;;;173        }
;;;174        /// cy 101004   m
;;;175    }
;;;176    
                          ENDP

                  BusFault_Handler PROC
;;;181      */
;;;182    void BusFault_Handler(void)
000086  bf00              NOP      
                  |L1.136|
;;;183    {
;;;184        /// cy 101004   m
;;;185    //  /* Go to infinite loop when Bus Fault exception occurs */
;;;186    //  while (1)
;;;187    //  {
;;;188    //  }
;;;189    
;;;190        for ( ; ; ) {
;;;191            DispErrNo(4);
000088  2004              MOVS     r0,#4
00008a  f7fffffe          BL       DispErrNo
00008e  e7fb              B        |L1.136|
;;;192        }
;;;193        /// cy 101004   m
;;;194    }
;;;195    
                          ENDP

                  UsageFault_Handler PROC
;;;200      */
;;;201    void UsageFault_Handler(void)
000090  bf00              NOP      
                  |L1.146|
;;;202    {
;;;203        /// cy 101004   m
;;;204    //  /* Go to infinite loop when Usage Fault exception occurs */
;;;205    //  while (1)
;;;206    //  {
;;;207    //  }
;;;208    
;;;209        for ( ; ; ) {
;;;210            DispErrNo(5);
000092  2005              MOVS     r0,#5
000094  f7fffffe          BL       DispErrNo
000098  e7fb              B        |L1.146|
;;;211        }
;;;212        /// cy 101004   m
;;;213    }
;;;214    
                          ENDP

                  SVC_Handler PROC
;;;219      */
;;;220    void SVC_Handler(void)
00009a  bf00              NOP      
                  |L1.156|
;;;221    {
;;;222        /// cy 101004   a
;;;223        for ( ; ; ) {
;;;224            DispErrNo(6);
00009c  2006              MOVS     r0,#6
00009e  f7fffffe          BL       DispErrNo
0000a2  e7fb              B        |L1.156|
;;;225        }
;;;226        /// cy 101004   a
;;;227    }
;;;228    
                          ENDP

                  DebugMon_Handler PROC
;;;233      */
;;;234    void DebugMon_Handler(void)
0000a4  bf00              NOP      
                  |L1.166|
;;;235    {
;;;236        /// cy 101004   a
;;;237        for ( ; ; ) {
;;;238            DispErrNo(7);
0000a6  2007              MOVS     r0,#7
0000a8  f7fffffe          BL       DispErrNo
0000ac  e7fb              B        |L1.166|
;;;239        }
;;;240        /// cy 101004   a
;;;241    }
;;;242    
                          ENDP

                  PendSV_Handler PROC
;;;247      */
;;;248    void PendSV_Handler(void)
0000ae  4770              BX       lr
;;;249    {
;;;250    }
;;;251    
                          ENDP

                  SysTick_Handler PROC
;;;256      */
;;;257    void SysTick_Handler(void)
0000b0  4770              BX       lr
;;;258    {
;;;259    }
;;;260    
                          ENDP

                  PPP_IRQHandler PROC
;;;282    /// ----------------------------------------------------------------------------
;;;283    void PPP_IRQHandler(void)
0000b2  b510              PUSH     {r4,lr}
;;;284    {
;;;285    //#if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
;;;286    //    CPU_SR         cpu_sr;
;;;287    //#endif
;;;288    //    
;;;289    //    
;;;290    //    CPU_CRITICAL_ENTER();       /// Tell uC/OS-II that we are starting an ISR
;;;291    //    OSIntNesting++;
;;;292    //    CPU_CRITICAL_EXIT();
;;;293    //    
;;;294    //    /// call the actual IRQ function
;;;295    //    /// ......
;;;296    //
;;;297    //    OSIntExit();                /// Tell uC/OS-II that we are leaving the ISR
;;;298        
;;;299    #if (OS_CRITICAL_METHOD == 3)
;;;300        OS_CPU_SR       cpu_sr;
;;;301    #endif
;;;302        
;;;303        
;;;304        OS_ENTER_CRITICAL();        /// Tell uC/OS-II that we are starting an ISR
0000b4  f7fffffe          BL       OS_CPU_SR_Save
0000b8  4604              MOV      r4,r0
;;;305        OSIntNesting++;
0000ba  481f              LDR      r0,|L1.312|
0000bc  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0000be  1c40              ADDS     r0,r0,#1
0000c0  491d              LDR      r1,|L1.312|
0000c2  7008              STRB     r0,[r1,#0]
;;;306        OS_EXIT_CRITICAL();
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       OS_CPU_SR_Restore
;;;307        
;;;308        /// call the actual IRQ function
;;;309        /// ......
;;;310    
;;;311        OSIntExit();                /// Tell uC/OS-II that we are leaving the ISR
0000ca  f7fffffe          BL       OSIntExit
;;;312    }
0000ce  bd10              POP      {r4,pc}
;;;313    
                          ENDP

                  USART1_IRQHandler PROC
;;;315    
;;;316    void  BSP_USART_491_IRQHandler (void)
0000d0  b570              PUSH     {r4-r6,lr}
;;;317    {
;;;318    #if (OS_CRITICAL_METHOD == 3)
;;;319        OS_CPU_SR       cpu_sr;
;;;320    #endif
;;;321        
;;;322        
;;;323        OS_ENTER_CRITICAL();        /// Tell uC/OS-II that we are starting an ISR
0000d2  f7fffffe          BL       OS_CPU_SR_Save
0000d6  4604              MOV      r4,r0
;;;324        OSIntNesting++;
0000d8  4817              LDR      r0,|L1.312|
0000da  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
0000dc  1c40              ADDS     r0,r0,#1
0000de  4916              LDR      r1,|L1.312|
0000e0  7008              STRB     r0,[r1,#0]
;;;325        OS_EXIT_CRITICAL();
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       OS_CPU_SR_Restore
;;;326        
;;;327        
;;;328        if (USART_GetITStatus(BSP_USART_491, USART_IT_RXNE) != RESET) {
0000e8  f2405125          MOV      r1,#0x525
0000ec  4813              LDR      r0,|L1.316|
0000ee  f7fffffe          BL       USART_GetITStatus
0000f2  b128              CBZ      r0,|L1.256|
;;;329            C491_IrqToRxBuf(USART_ReceiveData(BSP_USART_491));
0000f4  4811              LDR      r0,|L1.316|
0000f6  f7fffffe          BL       USART_ReceiveData
0000fa  4605              MOV      r5,r0
0000fc  f7fffffe          BL       C491_IrqToRxBuf
                  |L1.256|
;;;330        }
;;;331        
;;;332    //    if (USART_GetITStatus(BSP_USART_491, USART_IT_TC  ) != RESET) {
;;;333    //        USART_ClearITPendingBit(BSP_USART_491, USART_IT_TC);
;;;334    //        BSP_491_DeSet(DISABLE);
;;;335    //        OSSemPost(C491_T_SemPtr);
;;;336    //    }
;;;337        if (USART_GetITStatus(BSP_USART_491, USART_IT_TC) != RESET) {   
000100  f2406126          MOV      r1,#0x626
000104  480d              LDR      r0,|L1.316|
000106  f7fffffe          BL       USART_GetITStatus
00010a  b108              CBZ      r0,|L1.272|
;;;338            
;;;339    //        if (C491_TxIndex < C491_TxNum) {
;;;340    //			USART_SendData(BSP_USART_491, C491_TxBuf[C491_TxIndex++]);
;;;341    //		} else {
;;;342    ////        USART_ClearITPendingBit(BSP_USART_491, USART_IT_TC);  /// 需要试验
;;;343    //            /// 可不用清除中断, 只关闭中断, 以便以后发送数据
;;;344    //            USART_ITConfig(BSP_USART_491, USART_IT_TC, DISABLE);
;;;345    //            BSP_491_DeSet(DISABLE);
;;;346    //        }
;;;347            C491_IrqTx();
00010c  f7fffffe          BL       C491_IrqTx
                  |L1.272|
;;;348        }
;;;349        
;;;350        
;;;351        OSIntExit();                /// Tell uC/OS-II that we are leaving the ISR
000110  f7fffffe          BL       OSIntExit
;;;352    }
000114  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

                  TIM1_CC_IRQHandler PROC
;;;354    
;;;355    void  BSP_TMR_8M_IRQHandler (void)
000116  b510              PUSH     {r4,lr}
;;;356    {
;;;357    #if (OS_CRITICAL_METHOD == 3)
;;;358        OS_CPU_SR       cpu_sr;
;;;359    #endif
;;;360    //    BitAction       st;
;;;361    //    u8              i;
;;;362        
;;;363        
;;;364    #ifdef  PC924
;;;365        if (TIM_GetITStatus(BSP_TMR_8M, BSP_FLAG_CC_MC_CLOSE) != RESET) {   /// 闭环控制定时比较中断, 不可关闭自身
;;;366            TIM_ClearITPendingBit(BSP_TMR_8M, BSP_FLAG_CC_MC_CLOSE);        /// 清中断标志
;;;367            
;;;368            MCL_IRQ();
;;;369            
;;;370        } else {                                                            /// 开环控制定时比较中断, 可以关闭自身
;;;371            
;;;372            OS_ENTER_CRITICAL();        /// Tell uC/OS-II that we are starting an ISR
;;;373            OSIntNesting++;
;;;374            OS_EXIT_CRITICAL();
;;;375            
;;;376            if (TIM_GetITStatus(BSP_TMR_8M, BSP_FLAG_CC_MC_OPEN) != RESET) {
;;;377                TIM_ClearITPendingBit(BSP_TMR_8M, BSP_FLAG_CC_MC_OPEN);     /// 清中断标志
;;;378                
;;;379                MCO_IRQ();                                                  /// 闭环电机开环控制用的定时中断
;;;380                
;;;381            } else {
;;;382                
;;;383                MOTO_IRQandClr();                                           /// 开环电机定时中断, 并清除标志位
;;;384                
;;;385            }
;;;386            
;;;387            OSIntExit();                /// Tell uC/OS-II that we are leaving the ISR
;;;388        }
;;;389        
;;;390    #else
;;;391        OS_ENTER_CRITICAL();            /// Tell uC/OS-II that we are starting an ISR
000118  f7fffffe          BL       OS_CPU_SR_Save
00011c  4604              MOV      r4,r0
;;;392        OSIntNesting++;
00011e  4806              LDR      r0,|L1.312|
000120  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000122  1c40              ADDS     r0,r0,#1
000124  4904              LDR      r1,|L1.312|
000126  7008              STRB     r0,[r1,#0]
;;;393        OS_EXIT_CRITICAL();
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       OS_CPU_SR_Restore
;;;394        
;;;395        MOTO_IRQandClr();                                                   /// 开环电机定时中断, 并清除标志位
00012e  f7fffffe          BL       MOTO_IRQandClr
;;;396            
;;;397        OSIntExit();                    /// Tell uC/OS-II that we are leaving the ISR
000132  f7fffffe          BL       OSIntExit
;;;398    #endif
;;;399        
;;;400    }
000136  bd10              POP      {r4,pc}
;;;401    
                          ENDP

                  |L1.312|
                          DCD      OSIntNesting
                  |L1.316|
                          DCD      0x40013800
