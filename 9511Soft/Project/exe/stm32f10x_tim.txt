; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\stm32f10x_tim.o --depend=.\exe\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\stm32f10x_tim.crf ..\Source\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;186      */
;;;187    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;188    {
000002  4604              MOV      r4,r0
;;;189      /* Check the parameters */
;;;190      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;191     
;;;192      if (TIMx == TIM1)
000004  48fb              LDR      r0,|L1.1012|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L1.28|
;;;193      {
;;;194        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  14c0              ASRS     r0,r0,#19
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  14e0              ASRS     r0,r4,#19
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e052              B        |L1.194|
                  |L1.28|
;;;196      }     
;;;197      else if (TIMx == TIM2)
00001c  f1b44f80          CMP      r4,#0x40000000
000020  d108              BNE      |L1.52|
;;;198      {
;;;199        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000022  2101              MOVS     r1,#1
000024  4608              MOV      r0,r1
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;200        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e046              B        |L1.194|
                  |L1.52|
;;;201      }
;;;202      else if (TIMx == TIM3)
000034  48f0              LDR      r0,|L1.1016|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L1.76|
;;;203      {
;;;204        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;205        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000042  2100              MOVS     r1,#0
000044  2002              MOVS     r0,#2
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e03a              B        |L1.194|
                  |L1.76|
;;;206      }
;;;207      else if (TIMx == TIM4)
00004c  48eb              LDR      r0,|L1.1020|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L1.100|
;;;208      {
;;;209        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000052  2101              MOVS     r1,#1
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;210        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00005a  2100              MOVS     r1,#0
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e02e              B        |L1.194|
                  |L1.100|
;;;211      } 
;;;212      else if (TIMx == TIM5)
000064  48e6              LDR      r0,|L1.1024|
000066  4284              CMP      r4,r0
000068  d108              BNE      |L1.124|
;;;213      {
;;;214        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  2008              MOVS     r0,#8
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;215        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000072  2100              MOVS     r1,#0
000074  2008              MOVS     r0,#8
000076  f7fffffe          BL       RCC_APB1PeriphResetCmd
00007a  e022              B        |L1.194|
                  |L1.124|
;;;216      } 
;;;217      else if (TIMx == TIM6)
00007c  48e1              LDR      r0,|L1.1028|
00007e  4284              CMP      r4,r0
000080  d108              BNE      |L1.148|
;;;218      {
;;;219        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000082  2101              MOVS     r1,#1
000084  2010              MOVS     r0,#0x10
000086  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;220        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00008a  2100              MOVS     r1,#0
00008c  2010              MOVS     r0,#0x10
00008e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000092  e016              B        |L1.194|
                  |L1.148|
;;;221      } 
;;;222      else if (TIMx == TIM7)
000094  48dc              LDR      r0,|L1.1032|
000096  4284              CMP      r4,r0
000098  d108              BNE      |L1.172|
;;;223      {
;;;224        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2020              MOVS     r0,#0x20
00009e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;225        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000a2  2100              MOVS     r1,#0
0000a4  2020              MOVS     r0,#0x20
0000a6  f7fffffe          BL       RCC_APB1PeriphResetCmd
0000aa  e00a              B        |L1.194|
                  |L1.172|
;;;226      } 
;;;227      else
;;;228      {
;;;229        if (TIMx == TIM8)
0000ac  48d7              LDR      r0,|L1.1036|
0000ae  4284              CMP      r4,r0
0000b0  d107              BNE      |L1.194|
;;;230        {
;;;231          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  1440              ASRS     r0,r0,#17
0000b6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
0000ba  2100              MOVS     r1,#0
0000bc  1460              ASRS     r0,r4,#17
0000be  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L1.194|
;;;233        }  
;;;234      }
;;;235    }
0000c2  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;244      */
;;;245    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000c4  8802              LDRH     r2,[r0,#0]
;;;246    {
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;249      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;250      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;251      /* Select the Counter Mode and set the clock division */
;;;252      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
0000c6  f002028f          AND      r2,r2,#0x8f
0000ca  8002              STRH     r2,[r0,#0]
;;;253      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
0000cc  88ca              LDRH     r2,[r1,#6]
0000ce  884b              LDRH     r3,[r1,#2]
0000d0  431a              ORRS     r2,r2,r3
0000d2  8803              LDRH     r3,[r0,#0]
0000d4  431a              ORRS     r2,r2,r3
0000d6  8002              STRH     r2,[r0,#0]
;;;254                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;255      
;;;256      /* Set the Autoreload value */
;;;257      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000d8  888a              LDRH     r2,[r1,#4]
0000da  8582              STRH     r2,[r0,#0x2c]
;;;258     
;;;259      /* Set the Prescaler value */
;;;260      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000dc  880a              LDRH     r2,[r1,#0]
0000de  8502              STRH     r2,[r0,#0x28]
;;;261        
;;;262      if ((((uint32_t) TIMx) == TIM1_BASE) || (((uint32_t) TIMx) == TIM8_BASE))  
0000e0  4ac4              LDR      r2,|L1.1012|
0000e2  4290              CMP      r0,r2
0000e4  d002              BEQ      |L1.236|
0000e6  4ac9              LDR      r2,|L1.1036|
0000e8  4290              CMP      r0,r2
0000ea  d101              BNE      |L1.240|
                  |L1.236|
;;;263      {
;;;264        /* Set the Repetition Counter value */
;;;265        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0000ec  7a0a              LDRB     r2,[r1,#8]
0000ee  8602              STRH     r2,[r0,#0x30]
                  |L1.240|
;;;266      }
;;;267    
;;;268      /* Generate an update event to reload the Prescaler value immediatly */
;;;269      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
0000f0  2201              MOVS     r2,#1
0000f2  8282              STRH     r2,[r0,#0x14]
;;;270    }
0000f4  4770              BX       lr
;;;271    
                          ENDP

                  TIM_OC1Init PROC
;;;279      */
;;;280    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0000f6  b570              PUSH     {r4-r6,lr}
;;;281    {
;;;282      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0000f8  2400              MOVS     r4,#0
0000fa  2200              MOVS     r2,#0
0000fc  2300              MOVS     r3,#0
;;;283       
;;;284      /* Check the parameters */
;;;285      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;286      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;287      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;288      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;289      /* Disable the Channel 1: Reset the CC1E Bit */
;;;290      TIMx->CCER &= CCER_CC1E_Reset;
0000fe  8c05              LDRH     r5,[r0,#0x20]
000100  f64f76fe          MOV      r6,#0xfffe
000104  4035              ANDS     r5,r5,r6
000106  8405              STRH     r5,[r0,#0x20]
;;;291      
;;;292      /* Get the TIMx CCER register value */
;;;293      tmpccer = TIMx->CCER;
000108  8c02              LDRH     r2,[r0,#0x20]
;;;294      /* Get the TIMx CR2 register value */
;;;295      tmpcr2 =  TIMx->CR2;
00010a  8883              LDRH     r3,[r0,#4]
;;;296      
;;;297      /* Get the TIMx CCMR1 register value */
;;;298      tmpccmrx = TIMx->CCMR1;
00010c  8b04              LDRH     r4,[r0,#0x18]
;;;299        
;;;300      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;301      tmpccmrx &= CCMR_OC13M_Mask & CCMR_CC13S_Mask;
00010e  f64f758c          MOV      r5,#0xff8c
000112  402c              ANDS     r4,r4,r5
;;;302      
;;;303      /* Select the Output Compare Mode */
;;;304      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000114  880d              LDRH     r5,[r1,#0]
000116  432c              ORRS     r4,r4,r5
;;;305      
;;;306      /* Reset the Output Polarity level */
;;;307      tmpccer &= CCER_CC1P_Reset;
000118  1e75              SUBS     r5,r6,#1
00011a  402a              ANDS     r2,r2,r5
;;;308      /* Set the Output Compare Polarity */
;;;309      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00011c  890d              LDRH     r5,[r1,#8]
00011e  432a              ORRS     r2,r2,r5
;;;310      
;;;311      /* Set the Output State */
;;;312      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000120  884d              LDRH     r5,[r1,#2]
000122  432a              ORRS     r2,r2,r5
;;;313     
;;;314      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
000124  4db3              LDR      r5,|L1.1012|
000126  42a8              CMP      r0,r5
000128  d002              BEQ      |L1.304|
00012a  4db8              LDR      r5,|L1.1036|
00012c  42a8              CMP      r0,r5
00012e  d113              BNE      |L1.344|
                  |L1.304|
;;;315      {
;;;316        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;317        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;318        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;319        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;320        
;;;321        /* Reset the Output N Polarity level */
;;;322        tmpccer &= CCER_CC1NP_Reset;
000130  f64f75f7          MOV      r5,#0xfff7
000134  402a              ANDS     r2,r2,r5
;;;323        /* Set the Output N Polarity */
;;;324        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000136  894d              LDRH     r5,[r1,#0xa]
000138  432a              ORRS     r2,r2,r5
;;;325        /* Reset the Output N State */
;;;326        tmpccer &= CCER_CC1NE_Reset;
00013a  f64f75fb          MOV      r5,#0xfffb
00013e  402a              ANDS     r2,r2,r5
;;;327        
;;;328        /* Set the Output N State */
;;;329        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000140  888d              LDRH     r5,[r1,#4]
000142  432a              ORRS     r2,r2,r5
;;;330        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;331        tmpcr2 &= CR2_OIS1_Reset;
000144  f64765ff          MOV      r5,#0x7eff
000148  402b              ANDS     r3,r3,r5
;;;332        tmpcr2 &= CR2_OIS1N_Reset;
00014a  f64755ff          MOV      r5,#0x7dff
00014e  402b              ANDS     r3,r3,r5
;;;333        /* Set the Output Idle state */
;;;334        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000150  898d              LDRH     r5,[r1,#0xc]
000152  432b              ORRS     r3,r3,r5
;;;335        /* Set the Output N Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000154  89cd              LDRH     r5,[r1,#0xe]
000156  432b              ORRS     r3,r3,r5
                  |L1.344|
;;;337      }
;;;338      /* Write to TIMx CR2 */
;;;339      TIMx->CR2 = tmpcr2;
000158  8083              STRH     r3,[r0,#4]
;;;340      
;;;341      /* Write to TIMx CCMR1 */
;;;342      TIMx->CCMR1 = tmpccmrx;
00015a  8304              STRH     r4,[r0,#0x18]
;;;343    
;;;344      /* Set the Capture Compare Register value */
;;;345      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
00015c  88cd              LDRH     r5,[r1,#6]
00015e  8685              STRH     r5,[r0,#0x34]
;;;346      
;;;347      /* Write to TIMx CCER */
;;;348      TIMx->CCER = tmpccer;
000160  8402              STRH     r2,[r0,#0x20]
;;;349    }
000162  bd70              POP      {r4-r6,pc}
;;;350    
                          ENDP

                  TIM_OC2Init PROC
;;;358      */
;;;359    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000164  b570              PUSH     {r4-r6,lr}
;;;360    {
;;;361      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000166  2400              MOVS     r4,#0
000168  2200              MOVS     r2,#0
00016a  2300              MOVS     r3,#0
;;;362       
;;;363      /* Check the parameters */
;;;364      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;365      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;366      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;367      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;368      /* Disable the Channel 2: Reset the CC2E Bit */
;;;369      TIMx->CCER &= CCER_CC2E_Reset;
00016c  8c05              LDRH     r5,[r0,#0x20]
00016e  f64f76ef          MOV      r6,#0xffef
000172  4035              ANDS     r5,r5,r6
000174  8405              STRH     r5,[r0,#0x20]
;;;370      
;;;371      /* Get the TIMx CCER register value */  
;;;372      tmpccer = TIMx->CCER;
000176  8c02              LDRH     r2,[r0,#0x20]
;;;373      /* Get the TIMx CR2 register value */
;;;374      tmpcr2 =  TIMx->CR2;
000178  8883              LDRH     r3,[r0,#4]
;;;375      
;;;376      /* Get the TIMx CCMR1 register value */
;;;377      tmpccmrx = TIMx->CCMR1;
00017a  8b04              LDRH     r4,[r0,#0x18]
;;;378    
;;;379      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;380      tmpccmrx &= CCMR_OC24M_Mask & CCMR_CC24S_Mask;  
00017c  f64845ff          MOV      r5,#0x8cff
000180  402c              ANDS     r4,r4,r5
;;;381      
;;;382      /* Select the Output Compare Mode */
;;;383      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000182  880d              LDRH     r5,[r1,#0]
000184  062d              LSLS     r5,r5,#24
000186  ea444415          ORR      r4,r4,r5,LSR #16
;;;384      
;;;385      /* Reset the Output Polarity level */
;;;386      tmpccer &= CCER_CC2P_Reset;
00018a  f64f75df          MOV      r5,#0xffdf
00018e  402a              ANDS     r2,r2,r5
;;;387      /* Set the Output Compare Polarity */
;;;388      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000190  890d              LDRH     r5,[r1,#8]
000192  052d              LSLS     r5,r5,#20
000194  ea424215          ORR      r2,r2,r5,LSR #16
;;;389      
;;;390      /* Set the Output State */
;;;391      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000198  884d              LDRH     r5,[r1,#2]
00019a  052d              LSLS     r5,r5,#20
00019c  ea424215          ORR      r2,r2,r5,LSR #16
;;;392        
;;;393      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
0001a0  4d94              LDR      r5,|L1.1012|
0001a2  42a8              CMP      r0,r5
0001a4  d002              BEQ      |L1.428|
0001a6  4d99              LDR      r5,|L1.1036|
0001a8  42a8              CMP      r0,r5
0001aa  d11b              BNE      |L1.484|
                  |L1.428|
;;;394      {
;;;395        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;396        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;397        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;398        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;399        
;;;400        /* Reset the Output N Polarity level */
;;;401        tmpccer &= CCER_CC2NP_Reset;
0001ac  f64f757f          MOV      r5,#0xff7f
0001b0  402a              ANDS     r2,r2,r5
;;;402        /* Set the Output N Polarity */
;;;403        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0001b2  894d              LDRH     r5,[r1,#0xa]
0001b4  052d              LSLS     r5,r5,#20
0001b6  ea424215          ORR      r2,r2,r5,LSR #16
;;;404        /* Reset the Output N State */
;;;405        tmpccer &= CCER_CC2NE_Reset;
0001ba  f64f75bf          MOV      r5,#0xffbf
0001be  402a              ANDS     r2,r2,r5
;;;406        
;;;407        /* Set the Output N State */
;;;408        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
0001c0  888d              LDRH     r5,[r1,#4]
0001c2  052d              LSLS     r5,r5,#20
0001c4  ea424215          ORR      r2,r2,r5,LSR #16
;;;409        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;410        tmpcr2 &= CR2_OIS2_Reset;
0001c8  f64735ff          MOV      r5,#0x7bff
0001cc  402b              ANDS     r3,r3,r5
;;;411        tmpcr2 &= CR2_OIS2N_Reset;
0001ce  f24775ff          MOV      r5,#0x77ff
0001d2  402b              ANDS     r3,r3,r5
;;;412        /* Set the Output Idle state */
;;;413        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0001d4  898d              LDRH     r5,[r1,#0xc]
0001d6  04ad              LSLS     r5,r5,#18
0001d8  ea434315          ORR      r3,r3,r5,LSR #16
;;;414        /* Set the Output N Idle state */
;;;415        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0001dc  89cd              LDRH     r5,[r1,#0xe]
0001de  04ad              LSLS     r5,r5,#18
0001e0  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.484|
;;;416      }
;;;417      /* Write to TIMx CR2 */
;;;418      TIMx->CR2 = tmpcr2;
0001e4  8083              STRH     r3,[r0,#4]
;;;419      
;;;420      /* Write to TIMx CCMR1 */
;;;421      TIMx->CCMR1 = tmpccmrx;
0001e6  8304              STRH     r4,[r0,#0x18]
;;;422    
;;;423      /* Set the Capture Compare Register value */
;;;424      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0001e8  88cd              LDRH     r5,[r1,#6]
0001ea  8705              STRH     r5,[r0,#0x38]
;;;425      
;;;426      /* Write to TIMx CCER */
;;;427      TIMx->CCER = tmpccer;
0001ec  8402              STRH     r2,[r0,#0x20]
;;;428    }
0001ee  bd70              POP      {r4-r6,pc}
;;;429    
                          ENDP

                  TIM_OC3Init PROC
;;;437      */
;;;438    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
0001f0  b570              PUSH     {r4-r6,lr}
;;;439    {
;;;440      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
0001f2  2400              MOVS     r4,#0
0001f4  2200              MOVS     r2,#0
0001f6  2300              MOVS     r3,#0
;;;441       
;;;442      /* Check the parameters */
;;;443      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;444      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;445      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;446      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;447      /* Disable the Channel 2: Reset the CC2E Bit */
;;;448      TIMx->CCER &= CCER_CC3E_Reset;
0001f8  8c05              LDRH     r5,[r0,#0x20]
0001fa  f64f66ff          MOV      r6,#0xfeff
0001fe  4035              ANDS     r5,r5,r6
000200  8405              STRH     r5,[r0,#0x20]
;;;449      
;;;450      /* Get the TIMx CCER register value */
;;;451      tmpccer = TIMx->CCER;
000202  8c02              LDRH     r2,[r0,#0x20]
;;;452      /* Get the TIMx CR2 register value */
;;;453      tmpcr2 =  TIMx->CR2;
000204  8883              LDRH     r3,[r0,#4]
;;;454      
;;;455      /* Get the TIMx CCMR2 register value */
;;;456      tmpccmrx = TIMx->CCMR2;
000206  8b84              LDRH     r4,[r0,#0x1c]
;;;457        
;;;458      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;459      tmpccmrx &= CCMR_OC13M_Mask & CCMR_CC13S_Mask;  
000208  f64f758c          MOV      r5,#0xff8c
00020c  402c              ANDS     r4,r4,r5
;;;460      
;;;461      /* Select the Output Compare Mode */
;;;462      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
00020e  880d              LDRH     r5,[r1,#0]
000210  432c              ORRS     r4,r4,r5
;;;463      
;;;464      /* Reset the Output Polarity level */
;;;465      tmpccer &= CCER_CC3P_Reset;
000212  f64f55ff          MOV      r5,#0xfdff
000216  402a              ANDS     r2,r2,r5
;;;466      /* Set the Output Compare Polarity */
;;;467      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000218  890d              LDRH     r5,[r1,#8]
00021a  062d              LSLS     r5,r5,#24
00021c  ea424215          ORR      r2,r2,r5,LSR #16
;;;468      
;;;469      /* Set the Output State */
;;;470      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000220  884d              LDRH     r5,[r1,#2]
000222  062d              LSLS     r5,r5,#24
000224  ea424215          ORR      r2,r2,r5,LSR #16
;;;471       
;;;472      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
000228  4d72              LDR      r5,|L1.1012|
00022a  42a8              CMP      r0,r5
00022c  d002              BEQ      |L1.564|
00022e  4d77              LDR      r5,|L1.1036|
000230  42a8              CMP      r0,r5
000232  d11b              BNE      |L1.620|
                  |L1.564|
;;;473      {
;;;474        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;475        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;476        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;477        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;478        
;;;479        /* Reset the Output N Polarity level */
;;;480        tmpccer &= CCER_CC3NP_Reset;
000234  f24f75ff          MOV      r5,#0xf7ff
000238  402a              ANDS     r2,r2,r5
;;;481        /* Set the Output N Polarity */
;;;482        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00023a  894d              LDRH     r5,[r1,#0xa]
00023c  062d              LSLS     r5,r5,#24
00023e  ea424215          ORR      r2,r2,r5,LSR #16
;;;483        /* Reset the Output N State */
;;;484        tmpccer &= CCER_CC3NE_Reset;
000242  f64f35ff          MOV      r5,#0xfbff
000246  402a              ANDS     r2,r2,r5
;;;485        
;;;486        /* Set the Output N State */
;;;487        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000248  888d              LDRH     r5,[r1,#4]
00024a  062d              LSLS     r5,r5,#24
00024c  ea424215          ORR      r2,r2,r5,LSR #16
;;;488        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;489        tmpcr2 &= CR2_OIS3_Reset;
000250  f64675ff          MOV      r5,#0x6fff
000254  402b              ANDS     r3,r3,r5
;;;490        tmpcr2 &= CR2_OIS3N_Reset;
000256  f64575ff          MOV      r5,#0x5fff
00025a  402b              ANDS     r3,r3,r5
;;;491        /* Set the Output Idle state */
;;;492        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
00025c  898d              LDRH     r5,[r1,#0xc]
00025e  052d              LSLS     r5,r5,#20
000260  ea434315          ORR      r3,r3,r5,LSR #16
;;;493        /* Set the Output N Idle state */
;;;494        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000264  89cd              LDRH     r5,[r1,#0xe]
000266  052d              LSLS     r5,r5,#20
000268  ea434315          ORR      r3,r3,r5,LSR #16
                  |L1.620|
;;;495      }
;;;496      /* Write to TIMx CR2 */
;;;497      TIMx->CR2 = tmpcr2;
00026c  8083              STRH     r3,[r0,#4]
;;;498      
;;;499      /* Write to TIMx CCMR2 */
;;;500      TIMx->CCMR2 = tmpccmrx;
00026e  8384              STRH     r4,[r0,#0x1c]
;;;501    
;;;502      /* Set the Capture Compare Register value */
;;;503      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000270  88cd              LDRH     r5,[r1,#6]
000272  8785              STRH     r5,[r0,#0x3c]
;;;504      
;;;505      /* Write to TIMx CCER */
;;;506      TIMx->CCER = tmpccer;
000274  8402              STRH     r2,[r0,#0x20]
;;;507    }
000276  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

                  TIM_OC4Init PROC
;;;516      */
;;;517    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000278  b570              PUSH     {r4-r6,lr}
;;;518    {
;;;519      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00027a  2300              MOVS     r3,#0
00027c  2200              MOVS     r2,#0
00027e  2400              MOVS     r4,#0
;;;520       
;;;521      /* Check the parameters */
;;;522      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;523      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;524      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;525      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;526      /* Disable the Channel 2: Reset the CC4E Bit */
;;;527      TIMx->CCER &= CCER_CC4E_Reset;
000280  8c05              LDRH     r5,[r0,#0x20]
000282  f64e76ff          MOV      r6,#0xefff
000286  4035              ANDS     r5,r5,r6
000288  8405              STRH     r5,[r0,#0x20]
;;;528      
;;;529      /* Get the TIMx CCER register value */
;;;530      tmpccer = TIMx->CCER;
00028a  8c02              LDRH     r2,[r0,#0x20]
;;;531      /* Get the TIMx CR2 register value */
;;;532      tmpcr2 =  TIMx->CR2;
00028c  8884              LDRH     r4,[r0,#4]
;;;533      
;;;534      /* Get the TIMx CCMR2 register value */
;;;535      tmpccmrx = TIMx->CCMR2;
00028e  8b83              LDRH     r3,[r0,#0x1c]
;;;536        
;;;537      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;538      tmpccmrx &= CCMR_OC24M_Mask & CCMR_CC24S_Mask; 
000290  f64845ff          MOV      r5,#0x8cff
000294  402b              ANDS     r3,r3,r5
;;;539       
;;;540      /* Select the Output Compare Mode */
;;;541      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000296  880d              LDRH     r5,[r1,#0]
000298  062d              LSLS     r5,r5,#24
00029a  ea434315          ORR      r3,r3,r5,LSR #16
;;;542      
;;;543      /* Reset the Output Polarity level */
;;;544      tmpccer &= CCER_CC4P_Reset;
00029e  f64d75ff          MOV      r5,#0xdfff
0002a2  402a              ANDS     r2,r2,r5
;;;545      /* Set the Output Compare Polarity */
;;;546      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
0002a4  890d              LDRH     r5,[r1,#8]
0002a6  072d              LSLS     r5,r5,#28
0002a8  ea424215          ORR      r2,r2,r5,LSR #16
;;;547      
;;;548      /* Set the Output State */
;;;549      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
0002ac  884d              LDRH     r5,[r1,#2]
0002ae  072d              LSLS     r5,r5,#28
0002b0  ea424215          ORR      r2,r2,r5,LSR #16
;;;550        
;;;551      if(((uint32_t) TIMx == TIM1_BASE) || ((uint32_t) TIMx == TIM8_BASE))
0002b4  4d4f              LDR      r5,|L1.1012|
0002b6  42a8              CMP      r0,r5
0002b8  d002              BEQ      |L1.704|
0002ba  4d54              LDR      r5,|L1.1036|
0002bc  42a8              CMP      r0,r5
0002be  d105              BNE      |L1.716|
                  |L1.704|
;;;552      {
;;;553        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;554        /* Reset the Ouput Compare IDLE State */
;;;555        tmpcr2 &= CR2_OIS4_Reset;
0002c0  f3c4040d          UBFX     r4,r4,#0,#14
;;;556        /* Set the Output Idle state */
;;;557        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0002c4  898d              LDRH     r5,[r1,#0xc]
0002c6  05ad              LSLS     r5,r5,#22
0002c8  ea444415          ORR      r4,r4,r5,LSR #16
                  |L1.716|
;;;558      }
;;;559      /* Write to TIMx CR2 */
;;;560      TIMx->CR2 = tmpcr2;
0002cc  8084              STRH     r4,[r0,#4]
;;;561      
;;;562      /* Write to TIMx CCMR2 */  
;;;563      TIMx->CCMR2 = tmpccmrx;
0002ce  8383              STRH     r3,[r0,#0x1c]
;;;564    
;;;565      /* Set the Capture Compare Register value */
;;;566      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0002d0  88cd              LDRH     r5,[r1,#6]
0002d2  f8a05040          STRH     r5,[r0,#0x40]
;;;567      
;;;568      /* Write to TIMx CCER */
;;;569      TIMx->CCER = tmpccer;
0002d6  8402              STRH     r2,[r0,#0x20]
;;;570    }
0002d8  bd70              POP      {r4-r6,pc}
;;;571    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2389     */
;;;2390   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0002da  8b82              LDRH     r2,[r0,#0x1c]
;;;2391   {  
;;;2392     /* Check the parameters */
;;;2393     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2394     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2395     /* Reset the IC4PSC Bits */
;;;2396     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
0002dc  f24f33ff          MOV      r3,#0xf3ff
0002e0  401a              ANDS     r2,r2,r3
0002e2  8382              STRH     r2,[r0,#0x1c]
;;;2397     /* Set the IC4PSC value */
;;;2398     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
0002e4  8b82              LDRH     r2,[r0,#0x1c]
0002e6  060b              LSLS     r3,r1,#24
0002e8  ea424213          ORR      r2,r2,r3,LSR #16
0002ec  8382              STRH     r2,[r0,#0x1c]
;;;2399   }
0002ee  4770              BX       lr
;;;2400   
                          ENDP

                  TI4_Config PROC
;;;2762     */
;;;2763   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0002f0  b5f0              PUSH     {r4-r7,lr}
;;;2764                          uint16_t TIM_ICFilter)
;;;2765   {
0002f2  460c              MOV      r4,r1
0002f4  4615              MOV      r5,r2
;;;2766     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
0002f6  2100              MOVS     r1,#0
0002f8  2200              MOVS     r2,#0
0002fa  2600              MOVS     r6,#0
;;;2767   
;;;2768     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2769     TIMx->CCER &= CCER_CC4E_Reset;
0002fc  8c07              LDRH     r7,[r0,#0x20]
0002fe  f64e7cff          MOV      r12,#0xefff
000302  ea07070c          AND      r7,r7,r12
000306  8407              STRH     r7,[r0,#0x20]
;;;2770     tmpccmr2 = TIMx->CCMR2;
000308  8b81              LDRH     r1,[r0,#0x1c]
;;;2771     tmpccer = TIMx->CCER;
00030a  8c02              LDRH     r2,[r0,#0x20]
;;;2772     tmp = (uint16_t)(TIM_ICPolarity << 12);
00030c  0727              LSLS     r7,r4,#28
00030e  0c3e              LSRS     r6,r7,#16
;;;2773   
;;;2774     /* Select the Input and set the filter */
;;;2775     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000310  f64047ff          MOV      r7,#0xcff
000314  4039              ANDS     r1,r1,r7
;;;2776     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
000316  062f              LSLS     r7,r5,#24
000318  ea414117          ORR      r1,r1,r7,LSR #16
;;;2777     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
00031c  071f              LSLS     r7,r3,#28
00031e  ea414117          ORR      r1,r1,r7,LSR #16
;;;2778   
;;;2779     /* Select the Polarity and set the CC4E Bit */
;;;2780     tmpccer &= CCER_CC4P_Reset;
000322  f64d77ff          MOV      r7,#0xdfff
000326  403a              ANDS     r2,r2,r7
;;;2781     tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC4E_Set);
000328  f4465780          ORR      r7,r6,#0x1000
00032c  433a              ORRS     r2,r2,r7
;;;2782     /* Write to TIMx CCMR2 and CCER registers */
;;;2783     TIMx->CCMR2 = tmpccmr2;
00032e  8381              STRH     r1,[r0,#0x1c]
;;;2784     TIMx->CCER = tmpccer ;
000330  8402              STRH     r2,[r0,#0x20]
;;;2785   }
000332  bdf0              POP      {r4-r7,pc}
;;;2786   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2367     */
;;;2368   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000334  8b82              LDRH     r2,[r0,#0x1c]
;;;2369   {
;;;2370     /* Check the parameters */
;;;2371     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2372     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2373     /* Reset the IC3PSC Bits */
;;;2374     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000336  f64f73f3          MOV      r3,#0xfff3
00033a  401a              ANDS     r2,r2,r3
00033c  8382              STRH     r2,[r0,#0x1c]
;;;2375     /* Set the IC3PSC value */
;;;2376     TIMx->CCMR2 |= TIM_ICPSC;
00033e  8b82              LDRH     r2,[r0,#0x1c]
000340  430a              ORRS     r2,r2,r1
000342  8382              STRH     r2,[r0,#0x1c]
;;;2377   }
000344  4770              BX       lr
;;;2378   
                          ENDP

                  TI3_Config PROC
;;;2726     */
;;;2727   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000346  b5f0              PUSH     {r4-r7,lr}
;;;2728                          uint16_t TIM_ICFilter)
;;;2729   {
000348  460c              MOV      r4,r1
00034a  4615              MOV      r5,r2
;;;2730     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
00034c  2100              MOVS     r1,#0
00034e  2200              MOVS     r2,#0
000350  2600              MOVS     r6,#0
;;;2731     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2732     TIMx->CCER &= CCER_CC3E_Reset;
000352  8c07              LDRH     r7,[r0,#0x20]
000354  f64f6cff          MOV      r12,#0xfeff
000358  ea07070c          AND      r7,r7,r12
00035c  8407              STRH     r7,[r0,#0x20]
;;;2733     tmpccmr2 = TIMx->CCMR2;
00035e  8b81              LDRH     r1,[r0,#0x1c]
;;;2734     tmpccer = TIMx->CCER;
000360  8c02              LDRH     r2,[r0,#0x20]
;;;2735     tmp = (uint16_t)(TIM_ICPolarity << 8);
000362  0627              LSLS     r7,r4,#24
000364  0c3e              LSRS     r6,r7,#16
;;;2736     /* Select the Input and set the filter */
;;;2737     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000366  f64f770c          MOV      r7,#0xff0c
00036a  4039              ANDS     r1,r1,r7
;;;2738     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00036c  051f              LSLS     r7,r3,#20
00036e  ea454717          ORR      r7,r5,r7,LSR #16
000372  4339              ORRS     r1,r1,r7
;;;2739     /* Select the Polarity and set the CC3E Bit */
;;;2740     tmpccer &= CCER_CC3P_Reset;
000374  f64f57ff          MOV      r7,#0xfdff
000378  403a              ANDS     r2,r2,r7
;;;2741     tmpccer |= (uint16_t)(tmp | (uint16_t)CCER_CC3E_Set);
00037a  f4467780          ORR      r7,r6,#0x100
00037e  433a              ORRS     r2,r2,r7
;;;2742     /* Write to TIMx CCMR2 and CCER registers */
;;;2743     TIMx->CCMR2 = tmpccmr2;
000380  8381              STRH     r1,[r0,#0x1c]
;;;2744     TIMx->CCER = tmpccer;
000382  8402              STRH     r2,[r0,#0x20]
;;;2745   }
000384  bdf0              POP      {r4-r7,pc}
;;;2746   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2345     */
;;;2346   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000386  8b02              LDRH     r2,[r0,#0x18]
;;;2347   {
;;;2348     /* Check the parameters */
;;;2349     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2350     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2351     /* Reset the IC2PSC Bits */
;;;2352     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
000388  f24f33ff          MOV      r3,#0xf3ff
00038c  401a              ANDS     r2,r2,r3
00038e  8302              STRH     r2,[r0,#0x18]
;;;2353     /* Set the IC2PSC value */
;;;2354     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000390  8b02              LDRH     r2,[r0,#0x18]
000392  060b              LSLS     r3,r1,#24
000394  ea424213          ORR      r2,r2,r3,LSR #16
000398  8302              STRH     r2,[r0,#0x18]
;;;2355   }
00039a  4770              BX       lr
;;;2356   
                          ENDP

                  TI2_Config PROC
;;;2689     */
;;;2690   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00039c  b5f0              PUSH     {r4-r7,lr}
;;;2691                          uint16_t TIM_ICFilter)
;;;2692   {
00039e  460c              MOV      r4,r1
0003a0  4615              MOV      r5,r2
;;;2693     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
0003a2  2100              MOVS     r1,#0
0003a4  2200              MOVS     r2,#0
0003a6  2600              MOVS     r6,#0
;;;2694     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2695     TIMx->CCER &= CCER_CC2E_Reset;
0003a8  8c07              LDRH     r7,[r0,#0x20]
0003aa  f64f7cef          MOV      r12,#0xffef
0003ae  ea07070c          AND      r7,r7,r12
0003b2  8407              STRH     r7,[r0,#0x20]
;;;2696     tmpccmr1 = TIMx->CCMR1;
0003b4  8b01              LDRH     r1,[r0,#0x18]
;;;2697     tmpccer = TIMx->CCER;
0003b6  8c02              LDRH     r2,[r0,#0x20]
;;;2698     tmp = (uint16_t)(TIM_ICPolarity << 4);
0003b8  0527              LSLS     r7,r4,#20
0003ba  0c3e              LSRS     r6,r7,#16
;;;2699     /* Select the Input and set the filter */
;;;2700     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
0003bc  f64047ff          MOV      r7,#0xcff
0003c0  4039              ANDS     r1,r1,r7
;;;2701     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
0003c2  071f              LSLS     r7,r3,#28
0003c4  ea414117          ORR      r1,r1,r7,LSR #16
;;;2702     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
0003c8  062f              LSLS     r7,r5,#24
0003ca  ea414117          ORR      r1,r1,r7,LSR #16
;;;2703     /* Select the Polarity and set the CC2E Bit */
;;;2704     tmpccer &= CCER_CC2P_Reset;
0003ce  f64f77df          MOV      r7,#0xffdf
0003d2  403a              ANDS     r2,r2,r7
;;;2705     tmpccer |=  (uint16_t)(tmp | (uint16_t)CCER_CC2E_Set);
0003d4  f0460710          ORR      r7,r6,#0x10
0003d8  433a              ORRS     r2,r2,r7
;;;2706     /* Write to TIMx CCMR1 and CCER registers */
;;;2707     TIMx->CCMR1 = tmpccmr1 ;
0003da  8301              STRH     r1,[r0,#0x18]
;;;2708     TIMx->CCER = tmpccer;
0003dc  8402              STRH     r2,[r0,#0x20]
;;;2709   }
0003de  bdf0              POP      {r4-r7,pc}
;;;2710   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2323     */
;;;2324   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0003e0  8b02              LDRH     r2,[r0,#0x18]
;;;2325   {
;;;2326     /* Check the parameters */
;;;2327     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2328     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2329     /* Reset the IC1PSC Bits */
;;;2330     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
0003e2  f64f73f3          MOV      r3,#0xfff3
0003e6  401a              ANDS     r2,r2,r3
0003e8  8302              STRH     r2,[r0,#0x18]
;;;2331     /* Set the IC1PSC value */
;;;2332     TIMx->CCMR1 |= TIM_ICPSC;
0003ea  8b02              LDRH     r2,[r0,#0x18]
0003ec  430a              ORRS     r2,r2,r1
0003ee  8302              STRH     r2,[r0,#0x18]
;;;2333   }
0003f0  4770              BX       lr
0003f2  0000              DCW      0x0000
                  |L1.1012|
                          DCD      0x40012c00
                  |L1.1016|
                          DCD      0x40000400
                  |L1.1020|
                          DCD      0x40000800
                  |L1.1024|
                          DCD      0x40000c00
                  |L1.1028|
                          DCD      0x40001000
                  |L1.1032|
                          DCD      0x40001400
                  |L1.1036|
                          DCD      0x40013400
                          ENDP

                  TI1_Config PROC
;;;2654     */
;;;2655   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000410  b5f0              PUSH     {r4-r7,lr}
;;;2656                          uint16_t TIM_ICFilter)
;;;2657   {
000412  460c              MOV      r4,r1
000414  4615              MOV      r5,r2
;;;2658     uint16_t tmpccmr1 = 0, tmpccer = 0;
000416  2100              MOVS     r1,#0
000418  2200              MOVS     r2,#0
;;;2659     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2660     TIMx->CCER &= CCER_CC1E_Reset;
00041a  8c06              LDRH     r6,[r0,#0x20]
00041c  f64f77fe          MOV      r7,#0xfffe
000420  403e              ANDS     r6,r6,r7
000422  8406              STRH     r6,[r0,#0x20]
;;;2661     tmpccmr1 = TIMx->CCMR1;
000424  8b01              LDRH     r1,[r0,#0x18]
;;;2662     tmpccer = TIMx->CCER;
000426  8c02              LDRH     r2,[r0,#0x20]
;;;2663     /* Select the Input and set the filter */
;;;2664     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
000428  f64f760c          MOV      r6,#0xff0c
00042c  4031              ANDS     r1,r1,r6
;;;2665     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00042e  051e              LSLS     r6,r3,#20
000430  ea454616          ORR      r6,r5,r6,LSR #16
000434  4331              ORRS     r1,r1,r6
;;;2666     /* Select the Polarity and set the CC1E Bit */
;;;2667     tmpccer &= CCER_CC1P_Reset;
000436  1e7e              SUBS     r6,r7,#1
000438  4032              ANDS     r2,r2,r6
;;;2668     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)CCER_CC1E_Set);
00043a  f0440601          ORR      r6,r4,#1
00043e  4332              ORRS     r2,r2,r6
;;;2669     /* Write to TIMx CCMR1 and CCER registers */
;;;2670     TIMx->CCMR1 = tmpccmr1;
000440  8301              STRH     r1,[r0,#0x18]
;;;2671     TIMx->CCER = tmpccer;
000442  8402              STRH     r2,[r0,#0x20]
;;;2672   }
000444  bdf0              POP      {r4-r7,pc}
;;;2673   
                          ENDP

                  TIM_ICInit PROC
;;;579      */
;;;580    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000446  b570              PUSH     {r4-r6,lr}
;;;581    {
000448  4605              MOV      r5,r0
00044a  460c              MOV      r4,r1
;;;582      /* Check the parameters */
;;;583      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;584      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;585      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;586      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;587      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;588      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;589      
;;;590      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00044c  8820              LDRH     r0,[r4,#0]
00044e  b950              CBNZ     r0,|L1.1126|
;;;591      {
;;;592        /* TI1 Configuration */
;;;593        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000450  8923              LDRH     r3,[r4,#8]
000452  88a2              LDRH     r2,[r4,#4]
000454  8861              LDRH     r1,[r4,#2]
000456  4628              MOV      r0,r5
000458  f7fffffe          BL       TI1_Config
;;;594                   TIM_ICInitStruct->TIM_ICSelection,
;;;595                   TIM_ICInitStruct->TIM_ICFilter);
;;;596        /* Set the Input Capture Prescaler value */
;;;597        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00045c  88e1              LDRH     r1,[r4,#6]
00045e  4628              MOV      r0,r5
000460  f7fffffe          BL       TIM_SetIC1Prescaler
000464  e025              B        |L1.1202|
                  |L1.1126|
;;;598      }
;;;599      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000466  8820              LDRH     r0,[r4,#0]
000468  2804              CMP      r0,#4
00046a  d10a              BNE      |L1.1154|
;;;600      {
;;;601        /* TI2 Configuration */
;;;602        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00046c  8923              LDRH     r3,[r4,#8]
00046e  88a2              LDRH     r2,[r4,#4]
000470  8861              LDRH     r1,[r4,#2]
000472  4628              MOV      r0,r5
000474  f7fffffe          BL       TI2_Config
;;;603                   TIM_ICInitStruct->TIM_ICSelection,
;;;604                   TIM_ICInitStruct->TIM_ICFilter);
;;;605        /* Set the Input Capture Prescaler value */
;;;606        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000478  88e1              LDRH     r1,[r4,#6]
00047a  4628              MOV      r0,r5
00047c  f7fffffe          BL       TIM_SetIC2Prescaler
000480  e017              B        |L1.1202|
                  |L1.1154|
;;;607      }
;;;608      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000482  8820              LDRH     r0,[r4,#0]
000484  2808              CMP      r0,#8
000486  d10a              BNE      |L1.1182|
;;;609      {
;;;610        /* TI3 Configuration */
;;;611        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000488  8923              LDRH     r3,[r4,#8]
00048a  88a2              LDRH     r2,[r4,#4]
00048c  8861              LDRH     r1,[r4,#2]
00048e  4628              MOV      r0,r5
000490  f7fffffe          BL       TI3_Config
;;;612                   TIM_ICInitStruct->TIM_ICSelection,
;;;613                   TIM_ICInitStruct->TIM_ICFilter);
;;;614        /* Set the Input Capture Prescaler value */
;;;615        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000494  88e1              LDRH     r1,[r4,#6]
000496  4628              MOV      r0,r5
000498  f7fffffe          BL       TIM_SetIC3Prescaler
00049c  e009              B        |L1.1202|
                  |L1.1182|
;;;616      }
;;;617      else
;;;618      {
;;;619        /* TI4 Configuration */
;;;620        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00049e  8923              LDRH     r3,[r4,#8]
0004a0  88a2              LDRH     r2,[r4,#4]
0004a2  8861              LDRH     r1,[r4,#2]
0004a4  4628              MOV      r0,r5
0004a6  f7fffffe          BL       TI4_Config
;;;621                   TIM_ICInitStruct->TIM_ICSelection,
;;;622                   TIM_ICInitStruct->TIM_ICFilter);
;;;623        /* Set the Input Capture Prescaler value */
;;;624        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004aa  88e1              LDRH     r1,[r4,#6]
0004ac  4628              MOV      r0,r5
0004ae  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.1202|
;;;625      }
;;;626    }
0004b2  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP

                  TIM_PWMIConfig PROC
;;;635      */
;;;636    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0004b4  e92d41f0          PUSH     {r4-r8,lr}
;;;637    {
0004b8  4605              MOV      r5,r0
0004ba  460c              MOV      r4,r1
;;;638      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
0004bc  2600              MOVS     r6,#0
;;;639      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
0004be  2701              MOVS     r7,#1
;;;640      /* Check the parameters */
;;;641      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;642      /* Select the Opposite Input Polarity */
;;;643      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
0004c0  8860              LDRH     r0,[r4,#2]
0004c2  b908              CBNZ     r0,|L1.1224|
;;;644      {
;;;645        icoppositepolarity = TIM_ICPolarity_Falling;
0004c4  2602              MOVS     r6,#2
0004c6  e000              B        |L1.1226|
                  |L1.1224|
;;;646      }
;;;647      else
;;;648      {
;;;649        icoppositepolarity = TIM_ICPolarity_Rising;
0004c8  2600              MOVS     r6,#0
                  |L1.1226|
;;;650      }
;;;651      /* Select the Opposite Input */
;;;652      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
0004ca  88a0              LDRH     r0,[r4,#4]
0004cc  2801              CMP      r0,#1
0004ce  d101              BNE      |L1.1236|
;;;653      {
;;;654        icoppositeselection = TIM_ICSelection_IndirectTI;
0004d0  2702              MOVS     r7,#2
0004d2  e000              B        |L1.1238|
                  |L1.1236|
;;;655      }
;;;656      else
;;;657      {
;;;658        icoppositeselection = TIM_ICSelection_DirectTI;
0004d4  2701              MOVS     r7,#1
                  |L1.1238|
;;;659      }
;;;660      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
0004d6  8820              LDRH     r0,[r4,#0]
0004d8  b9a0              CBNZ     r0,|L1.1284|
;;;661      {
;;;662        /* TI1 Configuration */
;;;663        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
0004da  8923              LDRH     r3,[r4,#8]
0004dc  88a2              LDRH     r2,[r4,#4]
0004de  8861              LDRH     r1,[r4,#2]
0004e0  4628              MOV      r0,r5
0004e2  f7fffffe          BL       TI1_Config
;;;664                   TIM_ICInitStruct->TIM_ICFilter);
;;;665        /* Set the Input Capture Prescaler value */
;;;666        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004e6  88e1              LDRH     r1,[r4,#6]
0004e8  4628              MOV      r0,r5
0004ea  f7fffffe          BL       TIM_SetIC1Prescaler
;;;667        /* TI2 Configuration */
;;;668        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
0004ee  8923              LDRH     r3,[r4,#8]
0004f0  463a              MOV      r2,r7
0004f2  4631              MOV      r1,r6
0004f4  4628              MOV      r0,r5
0004f6  f7fffffe          BL       TI2_Config
;;;669        /* Set the Input Capture Prescaler value */
;;;670        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004fa  88e1              LDRH     r1,[r4,#6]
0004fc  4628              MOV      r0,r5
0004fe  f7fffffe          BL       TIM_SetIC2Prescaler
000502  e013              B        |L1.1324|
                  |L1.1284|
;;;671      }
;;;672      else
;;;673      { 
;;;674        /* TI2 Configuration */
;;;675        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000504  8923              LDRH     r3,[r4,#8]
000506  88a2              LDRH     r2,[r4,#4]
000508  8861              LDRH     r1,[r4,#2]
00050a  4628              MOV      r0,r5
00050c  f7fffffe          BL       TI2_Config
;;;676                   TIM_ICInitStruct->TIM_ICFilter);
;;;677        /* Set the Input Capture Prescaler value */
;;;678        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000510  88e1              LDRH     r1,[r4,#6]
000512  4628              MOV      r0,r5
000514  f7fffffe          BL       TIM_SetIC2Prescaler
;;;679        /* TI1 Configuration */
;;;680        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000518  8923              LDRH     r3,[r4,#8]
00051a  463a              MOV      r2,r7
00051c  4631              MOV      r1,r6
00051e  4628              MOV      r0,r5
000520  f7fffffe          BL       TI1_Config
;;;681        /* Set the Input Capture Prescaler value */
;;;682        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000524  88e1              LDRH     r1,[r4,#6]
000526  4628              MOV      r0,r5
000528  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.1324|
;;;683      }
;;;684    }
00052c  e8bd81f0          POP      {r4-r8,pc}
;;;685    
                          ENDP

                  TIM_BDTRConfig PROC
;;;693      */
;;;694    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000530  880a              LDRH     r2,[r1,#0]
;;;695    {
;;;696      /* Check the parameters */
;;;697      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;698      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;699      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;700      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;701      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;702      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;703      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;704      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;705         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;706      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000532  884b              LDRH     r3,[r1,#2]
000534  431a              ORRS     r2,r2,r3
000536  888b              LDRH     r3,[r1,#4]
000538  431a              ORRS     r2,r2,r3
00053a  88cb              LDRH     r3,[r1,#6]
00053c  431a              ORRS     r2,r2,r3
00053e  890b              LDRH     r3,[r1,#8]
000540  431a              ORRS     r2,r2,r3
000542  894b              LDRH     r3,[r1,#0xa]
000544  431a              ORRS     r2,r2,r3
000546  898b              LDRH     r3,[r1,#0xc]
000548  431a              ORRS     r2,r2,r3
00054a  f8a02044          STRH     r2,[r0,#0x44]
;;;707                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;708                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;709                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;710    }
00054e  4770              BX       lr
;;;711    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;717      */
;;;718    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000550  f64f71ff          MOV      r1,#0xffff
;;;719    {
;;;720      /* Set the default configuration */
;;;721      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000554  8081              STRH     r1,[r0,#4]
;;;722      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000556  2100              MOVS     r1,#0
000558  8001              STRH     r1,[r0,#0]
;;;723      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00055a  80c1              STRH     r1,[r0,#6]
;;;724      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00055c  8041              STRH     r1,[r0,#2]
;;;725      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00055e  7201              STRB     r1,[r0,#8]
;;;726    }
000560  4770              BX       lr
;;;727    
                          ENDP

                  TIM_OCStructInit PROC
;;;733      */
;;;734    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000562  2100              MOVS     r1,#0
;;;735    {
;;;736      /* Set the default configuration */
;;;737      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000564  8001              STRH     r1,[r0,#0]
;;;738      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000566  8041              STRH     r1,[r0,#2]
;;;739      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000568  8081              STRH     r1,[r0,#4]
;;;740      TIM_OCInitStruct->TIM_Pulse = 0x0000;
00056a  80c1              STRH     r1,[r0,#6]
;;;741      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00056c  8101              STRH     r1,[r0,#8]
;;;742      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00056e  8141              STRH     r1,[r0,#0xa]
;;;743      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
000570  8181              STRH     r1,[r0,#0xc]
;;;744      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000572  81c1              STRH     r1,[r0,#0xe]
;;;745    }
000574  4770              BX       lr
;;;746    
                          ENDP

                  TIM_ICStructInit PROC
;;;752      */
;;;753    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000576  2100              MOVS     r1,#0
;;;754    {
;;;755      /* Set the default configuration */
;;;756      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000578  8001              STRH     r1,[r0,#0]
;;;757      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
00057a  8041              STRH     r1,[r0,#2]
;;;758      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
00057c  2101              MOVS     r1,#1
00057e  8081              STRH     r1,[r0,#4]
;;;759      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
000580  2100              MOVS     r1,#0
000582  80c1              STRH     r1,[r0,#6]
;;;760      TIM_ICInitStruct->TIM_ICFilter = 0x00;
000584  8101              STRH     r1,[r0,#8]
;;;761    }
000586  4770              BX       lr
;;;762    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;768      */
;;;769    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000588  2100              MOVS     r1,#0
;;;770    {
;;;771      /* Set the default configuration */
;;;772      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
00058a  8001              STRH     r1,[r0,#0]
;;;773      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
00058c  8041              STRH     r1,[r0,#2]
;;;774      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
00058e  8081              STRH     r1,[r0,#4]
;;;775      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000590  80c1              STRH     r1,[r0,#6]
;;;776      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
000592  8101              STRH     r1,[r0,#8]
;;;777      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
000594  8141              STRH     r1,[r0,#0xa]
;;;778      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
000596  8181              STRH     r1,[r0,#0xc]
;;;779    }
000598  4770              BX       lr
;;;780    
                          ENDP

                  TIM_Cmd PROC
;;;787      */
;;;788    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
00059a  b121              CBZ      r1,|L1.1446|
;;;789    {
;;;790      /* Check the parameters */
;;;791      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;792      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;793      
;;;794      if (NewState != DISABLE)
;;;795      {
;;;796        /* Enable the TIM Counter */
;;;797        TIMx->CR1 |= CR1_CEN_Set;
00059c  8802              LDRH     r2,[r0,#0]
00059e  f0420201          ORR      r2,r2,#1
0005a2  8002              STRH     r2,[r0,#0]
0005a4  e004              B        |L1.1456|
                  |L1.1446|
;;;798      }
;;;799      else
;;;800      {
;;;801        /* Disable the TIM Counter */
;;;802        TIMx->CR1 &= CR1_CEN_Reset;
0005a6  8802              LDRH     r2,[r0,#0]
0005a8  f24033fe          MOV      r3,#0x3fe
0005ac  401a              ANDS     r2,r2,r3
0005ae  8002              STRH     r2,[r0,#0]
                  |L1.1456|
;;;803      }
;;;804    }
0005b0  4770              BX       lr
;;;805    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;812      */
;;;813    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
0005b2  b131              CBZ      r1,|L1.1474|
;;;814    {
;;;815      /* Check the parameters */
;;;816      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;817      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;818      if (NewState != DISABLE)
;;;819      {
;;;820        /* Enable the TIM Main Output */
;;;821        TIMx->BDTR |= BDTR_MOE_Set;
0005b4  f8b02044          LDRH     r2,[r0,#0x44]
0005b8  f4424200          ORR      r2,r2,#0x8000
0005bc  f8a02044          STRH     r2,[r0,#0x44]
0005c0  e005              B        |L1.1486|
                  |L1.1474|
;;;822      }
;;;823      else
;;;824      {
;;;825        /* Disable the TIM Main Output */
;;;826        TIMx->BDTR &= BDTR_MOE_Reset;
0005c2  f8b02044          LDRH     r2,[r0,#0x44]
0005c6  f3c2020e          UBFX     r2,r2,#0,#15
0005ca  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.1486|
;;;827      }  
;;;828    }
0005ce  4770              BX       lr
;;;829    
                          ENDP

                  TIM_ITConfig PROC
;;;849      */
;;;850    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
0005d0  b510              PUSH     {r4,lr}
;;;851    {  
;;;852      /* Check the parameters */
;;;853      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;854      assert_param(IS_TIM_IT(TIM_IT));
;;;855      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;856      
;;;857      if (NewState != DISABLE)
0005d2  b11a              CBZ      r2,|L1.1500|
;;;858      {
;;;859        /* Enable the Interrupt sources */
;;;860        TIMx->DIER |= TIM_IT;
0005d4  8983              LDRH     r3,[r0,#0xc]
0005d6  430b              ORRS     r3,r3,r1
0005d8  8183              STRH     r3,[r0,#0xc]
0005da  e004              B        |L1.1510|
                  |L1.1500|
;;;861      }
;;;862      else
;;;863      {
;;;864        /* Disable the Interrupt sources */
;;;865        TIMx->DIER &= (uint16_t)~TIM_IT;
0005dc  8983              LDRH     r3,[r0,#0xc]
0005de  43cc              MVNS     r4,r1
0005e0  b2a4              UXTH     r4,r4
0005e2  4023              ANDS     r3,r3,r4
0005e4  8183              STRH     r3,[r0,#0xc]
                  |L1.1510|
;;;866      }
;;;867    }
0005e6  bd10              POP      {r4,pc}
;;;868    
                          ENDP

                  TIM_GenerateEvent PROC
;;;886      */
;;;887    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
0005e8  8281              STRH     r1,[r0,#0x14]
;;;888    { 
;;;889      /* Check the parameters */
;;;890      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;891      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;892      
;;;893      /* Set the event sources */
;;;894      TIMx->EGR = TIM_EventSource;
;;;895    }
0005ea  4770              BX       lr
;;;896    
                          ENDP

                  TIM_DMAConfig PROC
;;;913      */
;;;914    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
0005ec  ea410302          ORR      r3,r1,r2
;;;915    {
;;;916      /* Check the parameters */
;;;917      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;918      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;919      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;920      /* Set the DMA Base and the DMA Burst Length */
;;;921      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
0005f0  f8a03048          STRH     r3,[r0,#0x48]
;;;922    }
0005f4  4770              BX       lr
;;;923    
                          ENDP

                  TIM_DMACmd PROC
;;;939      */
;;;940    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
0005f6  b510              PUSH     {r4,lr}
;;;941    { 
;;;942      /* Check the parameters */
;;;943      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;944      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;945      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;946      
;;;947      if (NewState != DISABLE)
0005f8  b11a              CBZ      r2,|L1.1538|
;;;948      {
;;;949        /* Enable the DMA sources */
;;;950        TIMx->DIER |= TIM_DMASource; 
0005fa  8983              LDRH     r3,[r0,#0xc]
0005fc  430b              ORRS     r3,r3,r1
0005fe  8183              STRH     r3,[r0,#0xc]
000600  e004              B        |L1.1548|
                  |L1.1538|
;;;951      }
;;;952      else
;;;953      {
;;;954        /* Disable the DMA sources */
;;;955        TIMx->DIER &= (uint16_t)~TIM_DMASource;
000602  8983              LDRH     r3,[r0,#0xc]
000604  43cc              MVNS     r4,r1
000606  b2a4              UXTH     r4,r4
000608  4023              ANDS     r3,r3,r4
00060a  8183              STRH     r3,[r0,#0xc]
                  |L1.1548|
;;;956      }
;;;957    }
00060c  bd10              POP      {r4,pc}
;;;958    
                          ENDP

                  TIM_InternalClockConfig PROC
;;;963      */
;;;964    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
00060e  8901              LDRH     r1,[r0,#8]
;;;965    {
;;;966      /* Check the parameters */
;;;967      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;968      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;969      TIMx->SMCR &=  SMCR_SMS_Mask;
000610  f64f72f8          MOV      r2,#0xfff8
000614  4011              ANDS     r1,r1,r2
000616  8101              STRH     r1,[r0,#8]
;;;970    }
000618  4770              BX       lr
;;;971    
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1203     */
;;;1204   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
00061a  460a              MOV      r2,r1
;;;1205   {
;;;1206     uint16_t tmpsmcr = 0;
00061c  2100              MOVS     r1,#0
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1209     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1210     /* Get the TIMx SMCR register value */
;;;1211     tmpsmcr = TIMx->SMCR;
00061e  8901              LDRH     r1,[r0,#8]
;;;1212     /* Reset the TS Bits */
;;;1213     tmpsmcr &= SMCR_TS_Mask;
000620  f64f738f          MOV      r3,#0xff8f
000624  4019              ANDS     r1,r1,r3
;;;1214     /* Set the Input Trigger source */
;;;1215     tmpsmcr |= TIM_InputTriggerSource;
000626  4311              ORRS     r1,r1,r2
;;;1216     /* Write to TIMx SMCR */
;;;1217     TIMx->SMCR = tmpsmcr;
000628  8101              STRH     r1,[r0,#8]
;;;1218   }
00062a  4770              BX       lr
;;;1219   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;982      */
;;;983    void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
00062c  b530              PUSH     {r4,r5,lr}
;;;984    {
00062e  4604              MOV      r4,r0
000630  460d              MOV      r5,r1
;;;985      /* Check the parameters */
;;;986      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;987      assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;988      /* Select the Internal Trigger */
;;;989      TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000632  4629              MOV      r1,r5
000634  4620              MOV      r0,r4
000636  f7fffffe          BL       TIM_SelectInputTrigger
;;;990      /* Select the External clock mode1 */
;;;991      TIMx->SMCR |= TIM_SlaveMode_External1;
00063a  8920              LDRH     r0,[r4,#8]
00063c  f0400007          ORR      r0,r0,#7
000640  8120              STRH     r0,[r4,#8]
;;;992    }
000642  bd30              POP      {r4,r5,pc}
;;;993    
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1009     */
;;;1010   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000644  e92d41f0          PUSH     {r4-r8,lr}
;;;1011                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1012   {
000648  4604              MOV      r4,r0
00064a  460d              MOV      r5,r1
00064c  4616              MOV      r6,r2
00064e  461f              MOV      r7,r3
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1015     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1016     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1017     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1018     /* Configure the Timer Input Clock Source */
;;;1019     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000650  2d60              CMP      r5,#0x60
000652  d106              BNE      |L1.1634|
;;;1020     {
;;;1021       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000654  463b              MOV      r3,r7
000656  2201              MOVS     r2,#1
000658  4631              MOV      r1,r6
00065a  4620              MOV      r0,r4
00065c  f7fffffe          BL       TI2_Config
000660  e005              B        |L1.1646|
                  |L1.1634|
;;;1022     }
;;;1023     else
;;;1024     {
;;;1025       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000662  463b              MOV      r3,r7
000664  2201              MOVS     r2,#1
000666  4631              MOV      r1,r6
000668  4620              MOV      r0,r4
00066a  f7fffffe          BL       TI1_Config
                  |L1.1646|
;;;1026     }
;;;1027     /* Select the Trigger source */
;;;1028     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
00066e  4629              MOV      r1,r5
000670  4620              MOV      r0,r4
000672  f7fffffe          BL       TIM_SelectInputTrigger
;;;1029     /* Select the External clock mode1 */
;;;1030     TIMx->SMCR |= TIM_SlaveMode_External1;
000676  8920              LDRH     r0,[r4,#8]
000678  f0400007          ORR      r0,r0,#7
00067c  8120              STRH     r0,[r4,#8]
;;;1031   }
00067e  e8bd81f0          POP      {r4-r8,pc}
;;;1032   
                          ENDP

                  TIM_ETRConfig PROC
;;;1122     */
;;;1123   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000682  b530              PUSH     {r4,r5,lr}
;;;1124                      uint16_t ExtTRGFilter)
;;;1125   {
000684  460c              MOV      r4,r1
;;;1126     uint16_t tmpsmcr = 0;
000686  2100              MOVS     r1,#0
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1129     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1130     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1131     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1132     tmpsmcr = TIMx->SMCR;
000688  8901              LDRH     r1,[r0,#8]
;;;1133     /* Reset the ETR Bits */
;;;1134     tmpsmcr &= SMCR_ETR_Mask;
00068a  b2c9              UXTB     r1,r1
;;;1135     /* Set the Prescaler, the Filter value and the Polarity */
;;;1136     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00068c  061d              LSLS     r5,r3,#24
00068e  ea424515          ORR      r5,r2,r5,LSR #16
000692  4325              ORRS     r5,r5,r4
000694  4329              ORRS     r1,r1,r5
;;;1137     /* Write to TIMx SMCR */
;;;1138     TIMx->SMCR = tmpsmcr;
000696  8101              STRH     r1,[r0,#8]
;;;1139   }
000698  bd30              POP      {r4,r5,pc}
;;;1140   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1049     */
;;;1050   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
00069a  e92d41f0          PUSH     {r4-r8,lr}
;;;1051                                uint16_t ExtTRGFilter)
;;;1052   {
00069e  4605              MOV      r5,r0
0006a0  460e              MOV      r6,r1
0006a2  4617              MOV      r7,r2
0006a4  4698              MOV      r8,r3
;;;1053     uint16_t tmpsmcr = 0;
0006a6  2400              MOVS     r4,#0
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1056     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1057     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1058     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1059     /* Configure the ETR Clock source */
;;;1060     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
0006a8  4643              MOV      r3,r8
0006aa  463a              MOV      r2,r7
0006ac  4631              MOV      r1,r6
0006ae  4628              MOV      r0,r5
0006b0  f7fffffe          BL       TIM_ETRConfig
;;;1061     
;;;1062     /* Get the TIMx SMCR register value */
;;;1063     tmpsmcr = TIMx->SMCR;
0006b4  892c              LDRH     r4,[r5,#8]
;;;1064     /* Reset the SMS Bits */
;;;1065     tmpsmcr &= SMCR_SMS_Mask;
0006b6  f64f71f8          MOV      r1,#0xfff8
0006ba  400c              ANDS     r4,r4,r1
;;;1066     /* Select the External clock mode1 */
;;;1067     tmpsmcr |= TIM_SlaveMode_External1;
0006bc  f0440407          ORR      r4,r4,#7
;;;1068     /* Select the Trigger selection : ETRF */
;;;1069     tmpsmcr &= SMCR_TS_Mask;
0006c0  f64f718f          MOV      r1,#0xff8f
0006c4  400c              ANDS     r4,r4,r1
;;;1070     tmpsmcr |= TIM_TS_ETRF;
0006c6  f0440470          ORR      r4,r4,#0x70
;;;1071     /* Write to TIMx SMCR */
;;;1072     TIMx->SMCR = tmpsmcr;
0006ca  812c              STRH     r4,[r5,#8]
;;;1073   }
0006cc  e8bd81f0          POP      {r4-r8,pc}
;;;1074   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1091     */
;;;1092   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
0006d0  b5f0              PUSH     {r4-r7,lr}
;;;1093                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1094   {
0006d2  4604              MOV      r4,r0
0006d4  460d              MOV      r5,r1
0006d6  4616              MOV      r6,r2
0006d8  461f              MOV      r7,r3
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1097     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1098     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1099     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1100     /* Configure the ETR Clock source */
;;;1101     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
0006da  463b              MOV      r3,r7
0006dc  4632              MOV      r2,r6
0006de  4629              MOV      r1,r5
0006e0  4620              MOV      r0,r4
0006e2  f7fffffe          BL       TIM_ETRConfig
;;;1102     /* Enable the External clock mode2 */
;;;1103     TIMx->SMCR |= SMCR_ECE_Set;
0006e6  8920              LDRH     r0,[r4,#8]
0006e8  f4404080          ORR      r0,r0,#0x4000
0006ec  8120              STRH     r0,[r4,#8]
;;;1104   }
0006ee  bdf0              POP      {r4-r7,pc}
;;;1105   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1150     */
;;;1151   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
0006f0  8501              STRH     r1,[r0,#0x28]
;;;1152   {
;;;1153     /* Check the parameters */
;;;1154     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1155     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1156     /* Set the Prescaler value */
;;;1157     TIMx->PSC = Prescaler;
;;;1158     /* Set or reset the UG Bit */
;;;1159     TIMx->EGR = TIM_PSCReloadMode;
0006f2  8282              STRH     r2,[r0,#0x14]
;;;1160   }
0006f4  4770              BX       lr
;;;1161   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1173     */
;;;1174   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
0006f6  460a              MOV      r2,r1
;;;1175   {
;;;1176     uint16_t tmpcr1 = 0;
0006f8  2100              MOVS     r1,#0
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1180     tmpcr1 = TIMx->CR1;
0006fa  8801              LDRH     r1,[r0,#0]
;;;1181     /* Reset the CMS and DIR Bits */
;;;1182     tmpcr1 &= CR1_CounterMode_Mask;
0006fc  f240338f          MOV      r3,#0x38f
000700  4019              ANDS     r1,r1,r3
;;;1183     /* Set the Counter Mode */
;;;1184     tmpcr1 |= TIM_CounterMode;
000702  4311              ORRS     r1,r1,r2
;;;1185     /* Write to TIMx CR1 register */
;;;1186     TIMx->CR1 = tmpcr1;
000704  8001              STRH     r1,[r0,#0]
;;;1187   }
000706  4770              BX       lr
;;;1188   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1238     */
;;;1239   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000708  b5f0              PUSH     {r4-r7,lr}
;;;1240                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1241   {
00070a  460c              MOV      r4,r1
00070c  4615              MOV      r5,r2
00070e  461e              MOV      r6,r3
;;;1242     uint16_t tmpsmcr = 0;
000710  2100              MOVS     r1,#0
;;;1243     uint16_t tmpccmr1 = 0;
000712  2200              MOVS     r2,#0
;;;1244     uint16_t tmpccer = 0;
000714  2300              MOVS     r3,#0
;;;1245       
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1248     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1249     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1250     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1251   
;;;1252     /* Get the TIMx SMCR register value */
;;;1253     tmpsmcr = TIMx->SMCR;
000716  8901              LDRH     r1,[r0,#8]
;;;1254   
;;;1255     /* Get the TIMx CCMR1 register value */
;;;1256     tmpccmr1 = TIMx->CCMR1;
000718  8b02              LDRH     r2,[r0,#0x18]
;;;1257   
;;;1258     /* Get the TIMx CCER register value */
;;;1259     tmpccer = TIMx->CCER;
00071a  8c03              LDRH     r3,[r0,#0x20]
;;;1260   
;;;1261     /* Set the encoder Mode */
;;;1262     tmpsmcr &= SMCR_SMS_Mask;
00071c  f64f77f8          MOV      r7,#0xfff8
000720  4039              ANDS     r1,r1,r7
;;;1263     tmpsmcr |= TIM_EncoderMode;
000722  4321              ORRS     r1,r1,r4
;;;1264   
;;;1265     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1266     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
000724  f64f47fc          MOV      r7,#0xfcfc
000728  403a              ANDS     r2,r2,r7
;;;1267     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
00072a  f2401701          MOV      r7,#0x101
00072e  433a              ORRS     r2,r2,r7
;;;1268   
;;;1269     /* Set the TI1 and the TI2 Polarities */
;;;1270     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000730  f64f77dd          MOV      r7,#0xffdd
000734  403b              ANDS     r3,r3,r7
;;;1271     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
000736  0537              LSLS     r7,r6,#20
000738  ea454717          ORR      r7,r5,r7,LSR #16
00073c  433b              ORRS     r3,r3,r7
;;;1272   
;;;1273     /* Write to TIMx SMCR */
;;;1274     TIMx->SMCR = tmpsmcr;
00073e  8101              STRH     r1,[r0,#8]
;;;1275   
;;;1276     /* Write to TIMx CCMR1 */
;;;1277     TIMx->CCMR1 = tmpccmr1;
000740  8302              STRH     r2,[r0,#0x18]
;;;1278   
;;;1279     /* Write to TIMx CCER */
;;;1280     TIMx->CCER = tmpccer;
000742  8403              STRH     r3,[r0,#0x20]
;;;1281   }
000744  bdf0              POP      {r4-r7,pc}
;;;1282   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1291     */
;;;1292   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000746  460a              MOV      r2,r1
;;;1293   {
;;;1294     uint16_t tmpccmr1 = 0;
000748  2100              MOVS     r1,#0
;;;1295     /* Check the parameters */
;;;1296     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1297     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1298     tmpccmr1 = TIMx->CCMR1;
00074a  8b01              LDRH     r1,[r0,#0x18]
;;;1299     /* Reset the OC1M Bits */
;;;1300     tmpccmr1 &= CCMR_OC13M_Mask;
00074c  f64f738f          MOV      r3,#0xff8f
000750  4019              ANDS     r1,r1,r3
;;;1301     /* Configure The Forced output Mode */
;;;1302     tmpccmr1 |= TIM_ForcedAction;
000752  4311              ORRS     r1,r1,r2
;;;1303     /* Write to TIMx CCMR1 register */
;;;1304     TIMx->CCMR1 = tmpccmr1;
000754  8301              STRH     r1,[r0,#0x18]
;;;1305   }
000756  4770              BX       lr
;;;1306   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1315     */
;;;1316   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000758  460a              MOV      r2,r1
;;;1317   {
;;;1318     uint16_t tmpccmr1 = 0;
00075a  2100              MOVS     r1,#0
;;;1319     /* Check the parameters */
;;;1320     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1321     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1322     tmpccmr1 = TIMx->CCMR1;
00075c  8b01              LDRH     r1,[r0,#0x18]
;;;1323     /* Reset the OC2M Bits */
;;;1324     tmpccmr1 &= CCMR_OC24M_Mask;
00075e  f64873ff          MOV      r3,#0x8fff
000762  4019              ANDS     r1,r1,r3
;;;1325     /* Configure The Forced output Mode */
;;;1326     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000764  0613              LSLS     r3,r2,#24
000766  ea414113          ORR      r1,r1,r3,LSR #16
;;;1327     /* Write to TIMx CCMR1 register */
;;;1328     TIMx->CCMR1 = tmpccmr1;
00076a  8301              STRH     r1,[r0,#0x18]
;;;1329   }
00076c  4770              BX       lr
;;;1330   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1339     */
;;;1340   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00076e  460a              MOV      r2,r1
;;;1341   {
;;;1342     uint16_t tmpccmr2 = 0;
000770  2100              MOVS     r1,#0
;;;1343     /* Check the parameters */
;;;1344     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1345     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1346     tmpccmr2 = TIMx->CCMR2;
000772  8b81              LDRH     r1,[r0,#0x1c]
;;;1347     /* Reset the OC1M Bits */
;;;1348     tmpccmr2 &= CCMR_OC13M_Mask;
000774  f64f738f          MOV      r3,#0xff8f
000778  4019              ANDS     r1,r1,r3
;;;1349     /* Configure The Forced output Mode */
;;;1350     tmpccmr2 |= TIM_ForcedAction;
00077a  4311              ORRS     r1,r1,r2
;;;1351     /* Write to TIMx CCMR2 register */
;;;1352     TIMx->CCMR2 = tmpccmr2;
00077c  8381              STRH     r1,[r0,#0x1c]
;;;1353   }
00077e  4770              BX       lr
;;;1354   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1363     */
;;;1364   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000780  460a              MOV      r2,r1
;;;1365   {
;;;1366     uint16_t tmpccmr2 = 0;
000782  2100              MOVS     r1,#0
;;;1367     /* Check the parameters */
;;;1368     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1369     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1370     tmpccmr2 = TIMx->CCMR2;
000784  8b81              LDRH     r1,[r0,#0x1c]
;;;1371     /* Reset the OC2M Bits */
;;;1372     tmpccmr2 &= CCMR_OC24M_Mask;
000786  f64873ff          MOV      r3,#0x8fff
00078a  4019              ANDS     r1,r1,r3
;;;1373     /* Configure The Forced output Mode */
;;;1374     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00078c  0613              LSLS     r3,r2,#24
00078e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1375     /* Write to TIMx CCMR2 register */
;;;1376     TIMx->CCMR2 = tmpccmr2;
000792  8381              STRH     r1,[r0,#0x1c]
;;;1377   }
000794  4770              BX       lr
;;;1378   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1385     */
;;;1386   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000796  b121              CBZ      r1,|L1.1954|
;;;1387   {
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1390     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1391     if (NewState != DISABLE)
;;;1392     {
;;;1393       /* Set the ARR Preload Bit */
;;;1394       TIMx->CR1 |= CR1_ARPE_Set;
000798  8802              LDRH     r2,[r0,#0]
00079a  f0420280          ORR      r2,r2,#0x80
00079e  8002              STRH     r2,[r0,#0]
0007a0  e004              B        |L1.1964|
                  |L1.1954|
;;;1395     }
;;;1396     else
;;;1397     {
;;;1398       /* Reset the ARR Preload Bit */
;;;1399       TIMx->CR1 &= CR1_ARPE_Reset;
0007a2  8802              LDRH     r2,[r0,#0]
0007a4  f240337f          MOV      r3,#0x37f
0007a8  401a              ANDS     r2,r2,r3
0007aa  8002              STRH     r2,[r0,#0]
                  |L1.1964|
;;;1400     }
;;;1401   }
0007ac  4770              BX       lr
;;;1402   
                          ENDP

                  TIM_SelectCOM PROC
;;;1409     */
;;;1410   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
0007ae  b121              CBZ      r1,|L1.1978|
;;;1411   {
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1414     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1415     if (NewState != DISABLE)
;;;1416     {
;;;1417       /* Set the COM Bit */
;;;1418       TIMx->CR2 |= CR2_CCUS_Set;
0007b0  8882              LDRH     r2,[r0,#4]
0007b2  f0420204          ORR      r2,r2,#4
0007b6  8082              STRH     r2,[r0,#4]
0007b8  e004              B        |L1.1988|
                  |L1.1978|
;;;1419     }
;;;1420     else
;;;1421     {
;;;1422       /* Reset the COM Bit */
;;;1423       TIMx->CR2 &= CR2_CCUS_Reset;
0007ba  8882              LDRH     r2,[r0,#4]
0007bc  f64f73fb          MOV      r3,#0xfffb
0007c0  401a              ANDS     r2,r2,r3
0007c2  8082              STRH     r2,[r0,#4]
                  |L1.1988|
;;;1424     }
;;;1425   }
0007c4  4770              BX       lr
;;;1426   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1433     */
;;;1434   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
0007c6  b121              CBZ      r1,|L1.2002|
;;;1435   {
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1438     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1439     if (NewState != DISABLE)
;;;1440     {
;;;1441       /* Set the CCDS Bit */
;;;1442       TIMx->CR2 |= CR2_CCDS_Set;
0007c8  8882              LDRH     r2,[r0,#4]
0007ca  f0420208          ORR      r2,r2,#8
0007ce  8082              STRH     r2,[r0,#4]
0007d0  e004              B        |L1.2012|
                  |L1.2002|
;;;1443     }
;;;1444     else
;;;1445     {
;;;1446       /* Reset the CCDS Bit */
;;;1447       TIMx->CR2 &= CR2_CCDS_Reset;
0007d2  8882              LDRH     r2,[r0,#4]
0007d4  f64f73f7          MOV      r3,#0xfff7
0007d8  401a              ANDS     r2,r2,r3
0007da  8082              STRH     r2,[r0,#4]
                  |L1.2012|
;;;1448     }
;;;1449   }
0007dc  4770              BX       lr
;;;1450   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1457     */
;;;1458   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
0007de  b121              CBZ      r1,|L1.2026|
;;;1459   { 
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1462     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1463     if (NewState != DISABLE)
;;;1464     {
;;;1465       /* Set the CCPC Bit */
;;;1466       TIMx->CR2 |= CR2_CCPC_Set;
0007e0  8882              LDRH     r2,[r0,#4]
0007e2  f0420201          ORR      r2,r2,#1
0007e6  8082              STRH     r2,[r0,#4]
0007e8  e004              B        |L1.2036|
                  |L1.2026|
;;;1467     }
;;;1468     else
;;;1469     {
;;;1470       /* Reset the CCPC Bit */
;;;1471       TIMx->CR2 &= CR2_CCPC_Reset;
0007ea  8882              LDRH     r2,[r0,#4]
0007ec  f64f73fe          MOV      r3,#0xfffe
0007f0  401a              ANDS     r2,r2,r3
0007f2  8082              STRH     r2,[r0,#4]
                  |L1.2036|
;;;1472     }
;;;1473   }
0007f4  4770              BX       lr
;;;1474   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1483     */
;;;1484   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
0007f6  460a              MOV      r2,r1
;;;1485   {
;;;1486     uint16_t tmpccmr1 = 0;
0007f8  2100              MOVS     r1,#0
;;;1487     /* Check the parameters */
;;;1488     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1489     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1490     tmpccmr1 = TIMx->CCMR1;
0007fa  8b01              LDRH     r1,[r0,#0x18]
;;;1491     /* Reset the OC1PE Bit */
;;;1492     tmpccmr1 &= CCMR_OC13PE_Reset;
0007fc  f64f73f7          MOV      r3,#0xfff7
000800  4019              ANDS     r1,r1,r3
;;;1493     /* Enable or Disable the Output Compare Preload feature */
;;;1494     tmpccmr1 |= TIM_OCPreload;
000802  4311              ORRS     r1,r1,r2
;;;1495     /* Write to TIMx CCMR1 register */
;;;1496     TIMx->CCMR1 = tmpccmr1;
000804  8301              STRH     r1,[r0,#0x18]
;;;1497   }
000806  4770              BX       lr
;;;1498   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1507     */
;;;1508   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000808  460a              MOV      r2,r1
;;;1509   {
;;;1510     uint16_t tmpccmr1 = 0;
00080a  2100              MOVS     r1,#0
;;;1511     /* Check the parameters */
;;;1512     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1513     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1514     tmpccmr1 = TIMx->CCMR1;
00080c  8b01              LDRH     r1,[r0,#0x18]
;;;1515     /* Reset the OC2PE Bit */
;;;1516     tmpccmr1 &= CCMR_OC24PE_Reset;
00080e  f24f73ff          MOV      r3,#0xf7ff
000812  4019              ANDS     r1,r1,r3
;;;1517     /* Enable or Disable the Output Compare Preload feature */
;;;1518     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000814  0613              LSLS     r3,r2,#24
000816  ea414113          ORR      r1,r1,r3,LSR #16
;;;1519     /* Write to TIMx CCMR1 register */
;;;1520     TIMx->CCMR1 = tmpccmr1;
00081a  8301              STRH     r1,[r0,#0x18]
;;;1521   }
00081c  4770              BX       lr
;;;1522   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1531     */
;;;1532   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
00081e  460a              MOV      r2,r1
;;;1533   {
;;;1534     uint16_t tmpccmr2 = 0;
000820  2100              MOVS     r1,#0
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1537     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1538     tmpccmr2 = TIMx->CCMR2;
000822  8b81              LDRH     r1,[r0,#0x1c]
;;;1539     /* Reset the OC3PE Bit */
;;;1540     tmpccmr2 &= CCMR_OC13PE_Reset;
000824  f64f73f7          MOV      r3,#0xfff7
000828  4019              ANDS     r1,r1,r3
;;;1541     /* Enable or Disable the Output Compare Preload feature */
;;;1542     tmpccmr2 |= TIM_OCPreload;
00082a  4311              ORRS     r1,r1,r2
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
00082c  8381              STRH     r1,[r0,#0x1c]
;;;1545   }
00082e  4770              BX       lr
;;;1546   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1555     */
;;;1556   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000830  460a              MOV      r2,r1
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
000832  2100              MOVS     r1,#0
;;;1559     /* Check the parameters */
;;;1560     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1561     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1562     tmpccmr2 = TIMx->CCMR2;
000834  8b81              LDRH     r1,[r0,#0x1c]
;;;1563     /* Reset the OC4PE Bit */
;;;1564     tmpccmr2 &= CCMR_OC24PE_Reset;
000836  f24f73ff          MOV      r3,#0xf7ff
00083a  4019              ANDS     r1,r1,r3
;;;1565     /* Enable or Disable the Output Compare Preload feature */
;;;1566     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00083c  0613              LSLS     r3,r2,#24
00083e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1567     /* Write to TIMx CCMR2 register */
;;;1568     TIMx->CCMR2 = tmpccmr2;
000842  8381              STRH     r1,[r0,#0x1c]
;;;1569   }
000844  4770              BX       lr
;;;1570   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1579     */
;;;1580   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000846  460a              MOV      r2,r1
;;;1581   {
;;;1582     uint16_t tmpccmr1 = 0;
000848  2100              MOVS     r1,#0
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1585     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1586     /* Get the TIMx CCMR1 register value */
;;;1587     tmpccmr1 = TIMx->CCMR1;
00084a  8b01              LDRH     r1,[r0,#0x18]
;;;1588     /* Reset the OC1FE Bit */
;;;1589     tmpccmr1 &= CCMR_OC13FE_Reset;
00084c  f64f73fb          MOV      r3,#0xfffb
000850  4019              ANDS     r1,r1,r3
;;;1590     /* Enable or Disable the Output Compare Fast Bit */
;;;1591     tmpccmr1 |= TIM_OCFast;
000852  4311              ORRS     r1,r1,r2
;;;1592     /* Write to TIMx CCMR1 */
;;;1593     TIMx->CCMR1 = tmpccmr1;
000854  8301              STRH     r1,[r0,#0x18]
;;;1594   }
000856  4770              BX       lr
;;;1595   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1604     */
;;;1605   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000858  460a              MOV      r2,r1
;;;1606   {
;;;1607     uint16_t tmpccmr1 = 0;
00085a  2100              MOVS     r1,#0
;;;1608     /* Check the parameters */
;;;1609     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1610     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1611     /* Get the TIMx CCMR1 register value */
;;;1612     tmpccmr1 = TIMx->CCMR1;
00085c  8b01              LDRH     r1,[r0,#0x18]
;;;1613     /* Reset the OC2FE Bit */
;;;1614     tmpccmr1 &= CCMR_OC24FE_Reset;
00085e  f64f33ff          MOV      r3,#0xfbff
000862  4019              ANDS     r1,r1,r3
;;;1615     /* Enable or Disable the Output Compare Fast Bit */
;;;1616     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000864  0613              LSLS     r3,r2,#24
000866  ea414113          ORR      r1,r1,r3,LSR #16
;;;1617     /* Write to TIMx CCMR1 */
;;;1618     TIMx->CCMR1 = tmpccmr1;
00086a  8301              STRH     r1,[r0,#0x18]
;;;1619   }
00086c  4770              BX       lr
;;;1620   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1629     */
;;;1630   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
00086e  460a              MOV      r2,r1
;;;1631   {
;;;1632     uint16_t tmpccmr2 = 0;
000870  2100              MOVS     r1,#0
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1635     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1636     /* Get the TIMx CCMR2 register value */
;;;1637     tmpccmr2 = TIMx->CCMR2;
000872  8b81              LDRH     r1,[r0,#0x1c]
;;;1638     /* Reset the OC3FE Bit */
;;;1639     tmpccmr2 &= CCMR_OC13FE_Reset;
000874  f64f73fb          MOV      r3,#0xfffb
000878  4019              ANDS     r1,r1,r3
;;;1640     /* Enable or Disable the Output Compare Fast Bit */
;;;1641     tmpccmr2 |= TIM_OCFast;
00087a  4311              ORRS     r1,r1,r2
;;;1642     /* Write to TIMx CCMR2 */
;;;1643     TIMx->CCMR2 = tmpccmr2;
00087c  8381              STRH     r1,[r0,#0x1c]
;;;1644   }
00087e  4770              BX       lr
;;;1645   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1654     */
;;;1655   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000880  460a              MOV      r2,r1
;;;1656   {
;;;1657     uint16_t tmpccmr2 = 0;
000882  2100              MOVS     r1,#0
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1661     /* Get the TIMx CCMR2 register value */
;;;1662     tmpccmr2 = TIMx->CCMR2;
000884  8b81              LDRH     r1,[r0,#0x1c]
;;;1663     /* Reset the OC4FE Bit */
;;;1664     tmpccmr2 &= CCMR_OC24FE_Reset;
000886  f64f33ff          MOV      r3,#0xfbff
00088a  4019              ANDS     r1,r1,r3
;;;1665     /* Enable or Disable the Output Compare Fast Bit */
;;;1666     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00088c  0613              LSLS     r3,r2,#24
00088e  ea414113          ORR      r1,r1,r3,LSR #16
;;;1667     /* Write to TIMx CCMR2 */
;;;1668     TIMx->CCMR2 = tmpccmr2;
000892  8381              STRH     r1,[r0,#0x1c]
;;;1669   }
000894  4770              BX       lr
;;;1670   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1679     */
;;;1680   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000896  460a              MOV      r2,r1
;;;1681   {
;;;1682     uint16_t tmpccmr1 = 0;
000898  2100              MOVS     r1,#0
;;;1683     /* Check the parameters */
;;;1684     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1685     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1686     tmpccmr1 = TIMx->CCMR1;
00089a  8b01              LDRH     r1,[r0,#0x18]
;;;1687     /* Reset the OC1CE Bit */
;;;1688     tmpccmr1 &= CCMR_OC13CE_Reset;
00089c  f64f737f          MOV      r3,#0xff7f
0008a0  4019              ANDS     r1,r1,r3
;;;1689     /* Enable or Disable the Output Compare Clear Bit */
;;;1690     tmpccmr1 |= TIM_OCClear;
0008a2  4311              ORRS     r1,r1,r2
;;;1691     /* Write to TIMx CCMR1 register */
;;;1692     TIMx->CCMR1 = tmpccmr1;
0008a4  8301              STRH     r1,[r0,#0x18]
;;;1693   }
0008a6  4770              BX       lr
;;;1694   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1703     */
;;;1704   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008a8  460a              MOV      r2,r1
;;;1705   {
;;;1706     uint16_t tmpccmr1 = 0;
0008aa  2100              MOVS     r1,#0
;;;1707     /* Check the parameters */
;;;1708     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1709     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1710     tmpccmr1 = TIMx->CCMR1;
0008ac  8b01              LDRH     r1,[r0,#0x18]
;;;1711     /* Reset the OC2CE Bit */
;;;1712     tmpccmr1 &= CCMR_OC24CE_Reset;
0008ae  f3c1010e          UBFX     r1,r1,#0,#15
;;;1713     /* Enable or Disable the Output Compare Clear Bit */
;;;1714     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
0008b2  0613              LSLS     r3,r2,#24
0008b4  ea414113          ORR      r1,r1,r3,LSR #16
;;;1715     /* Write to TIMx CCMR1 register */
;;;1716     TIMx->CCMR1 = tmpccmr1;
0008b8  8301              STRH     r1,[r0,#0x18]
;;;1717   }
0008ba  4770              BX       lr
;;;1718   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1727     */
;;;1728   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008bc  460a              MOV      r2,r1
;;;1729   {
;;;1730     uint16_t tmpccmr2 = 0;
0008be  2100              MOVS     r1,#0
;;;1731     /* Check the parameters */
;;;1732     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1733     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1734     tmpccmr2 = TIMx->CCMR2;
0008c0  8b81              LDRH     r1,[r0,#0x1c]
;;;1735     /* Reset the OC3CE Bit */
;;;1736     tmpccmr2 &= CCMR_OC13CE_Reset;
0008c2  f64f737f          MOV      r3,#0xff7f
0008c6  4019              ANDS     r1,r1,r3
;;;1737     /* Enable or Disable the Output Compare Clear Bit */
;;;1738     tmpccmr2 |= TIM_OCClear;
0008c8  4311              ORRS     r1,r1,r2
;;;1739     /* Write to TIMx CCMR2 register */
;;;1740     TIMx->CCMR2 = tmpccmr2;
0008ca  8381              STRH     r1,[r0,#0x1c]
;;;1741   }
0008cc  4770              BX       lr
;;;1742   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1751     */
;;;1752   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008ce  460a              MOV      r2,r1
;;;1753   {
;;;1754     uint16_t tmpccmr2 = 0;
0008d0  2100              MOVS     r1,#0
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1758     tmpccmr2 = TIMx->CCMR2;
0008d2  8b81              LDRH     r1,[r0,#0x1c]
;;;1759     /* Reset the OC4CE Bit */
;;;1760     tmpccmr2 &= CCMR_OC24CE_Reset;
0008d4  f3c1010e          UBFX     r1,r1,#0,#15
;;;1761     /* Enable or Disable the Output Compare Clear Bit */
;;;1762     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
0008d8  0613              LSLS     r3,r2,#24
0008da  ea414113          ORR      r1,r1,r3,LSR #16
;;;1763     /* Write to TIMx CCMR2 register */
;;;1764     TIMx->CCMR2 = tmpccmr2;
0008de  8381              STRH     r1,[r0,#0x1c]
;;;1765   }
0008e0  4770              BX       lr
;;;1766   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1775     */
;;;1776   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0008e2  460a              MOV      r2,r1
;;;1777   {
;;;1778     uint16_t tmpccer = 0;
0008e4  2100              MOVS     r1,#0
;;;1779     /* Check the parameters */
;;;1780     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1781     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1782     tmpccer = TIMx->CCER;
0008e6  8c01              LDRH     r1,[r0,#0x20]
;;;1783     /* Set or Reset the CC1P Bit */
;;;1784     tmpccer &= CCER_CC1P_Reset;
0008e8  f64f73fd          MOV      r3,#0xfffd
0008ec  4019              ANDS     r1,r1,r3
;;;1785     tmpccer |= TIM_OCPolarity;
0008ee  4311              ORRS     r1,r1,r2
;;;1786     /* Write to TIMx CCER register */
;;;1787     TIMx->CCER = tmpccer;
0008f0  8401              STRH     r1,[r0,#0x20]
;;;1788   }
0008f2  4770              BX       lr
;;;1789   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1798     */
;;;1799   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0008f4  460a              MOV      r2,r1
;;;1800   {
;;;1801     uint16_t tmpccer = 0;
0008f6  2100              MOVS     r1,#0
;;;1802     /* Check the parameters */
;;;1803     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1804     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1805      
;;;1806     tmpccer = TIMx->CCER;
0008f8  8c01              LDRH     r1,[r0,#0x20]
;;;1807     /* Set or Reset the CC1NP Bit */
;;;1808     tmpccer &= CCER_CC1NP_Reset;
0008fa  f64f73f7          MOV      r3,#0xfff7
0008fe  4019              ANDS     r1,r1,r3
;;;1809     tmpccer |= TIM_OCNPolarity;
000900  4311              ORRS     r1,r1,r2
;;;1810     /* Write to TIMx CCER register */
;;;1811     TIMx->CCER = tmpccer;
000902  8401              STRH     r1,[r0,#0x20]
;;;1812   }
000904  4770              BX       lr
;;;1813   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1822     */
;;;1823   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000906  460a              MOV      r2,r1
;;;1824   {
;;;1825     uint16_t tmpccer = 0;
000908  2100              MOVS     r1,#0
;;;1826     /* Check the parameters */
;;;1827     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1828     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1829     tmpccer = TIMx->CCER;
00090a  8c01              LDRH     r1,[r0,#0x20]
;;;1830     /* Set or Reset the CC2P Bit */
;;;1831     tmpccer &= CCER_CC2P_Reset;
00090c  f64f73df          MOV      r3,#0xffdf
000910  4019              ANDS     r1,r1,r3
;;;1832     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000912  0513              LSLS     r3,r2,#20
000914  ea414113          ORR      r1,r1,r3,LSR #16
;;;1833     /* Write to TIMx CCER register */
;;;1834     TIMx->CCER = tmpccer;
000918  8401              STRH     r1,[r0,#0x20]
;;;1835   }
00091a  4770              BX       lr
;;;1836   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1845     */
;;;1846   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
00091c  460a              MOV      r2,r1
;;;1847   {
;;;1848     uint16_t tmpccer = 0;
00091e  2100              MOVS     r1,#0
;;;1849     /* Check the parameters */
;;;1850     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1851     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1852     
;;;1853     tmpccer = TIMx->CCER;
000920  8c01              LDRH     r1,[r0,#0x20]
;;;1854     /* Set or Reset the CC2NP Bit */
;;;1855     tmpccer &= CCER_CC2NP_Reset;
000922  f64f737f          MOV      r3,#0xff7f
000926  4019              ANDS     r1,r1,r3
;;;1856     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000928  0513              LSLS     r3,r2,#20
00092a  ea414113          ORR      r1,r1,r3,LSR #16
;;;1857     /* Write to TIMx CCER register */
;;;1858     TIMx->CCER = tmpccer;
00092e  8401              STRH     r1,[r0,#0x20]
;;;1859   }
000930  4770              BX       lr
;;;1860   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1869     */
;;;1870   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000932  460a              MOV      r2,r1
;;;1871   {
;;;1872     uint16_t tmpccer = 0;
000934  2100              MOVS     r1,#0
;;;1873     /* Check the parameters */
;;;1874     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1875     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1876     tmpccer = TIMx->CCER;
000936  8c01              LDRH     r1,[r0,#0x20]
;;;1877     /* Set or Reset the CC3P Bit */
;;;1878     tmpccer &= CCER_CC3P_Reset;
000938  f64f53ff          MOV      r3,#0xfdff
00093c  4019              ANDS     r1,r1,r3
;;;1879     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00093e  0613              LSLS     r3,r2,#24
000940  ea414113          ORR      r1,r1,r3,LSR #16
;;;1880     /* Write to TIMx CCER register */
;;;1881     TIMx->CCER = tmpccer;
000944  8401              STRH     r1,[r0,#0x20]
;;;1882   }
000946  4770              BX       lr
;;;1883   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1892     */
;;;1893   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000948  460a              MOV      r2,r1
;;;1894   {
;;;1895     uint16_t tmpccer = 0;
00094a  2100              MOVS     r1,#0
;;;1896    
;;;1897     /* Check the parameters */
;;;1898     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1899     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1900       
;;;1901     tmpccer = TIMx->CCER;
00094c  8c01              LDRH     r1,[r0,#0x20]
;;;1902     /* Set or Reset the CC3NP Bit */
;;;1903     tmpccer &= CCER_CC3NP_Reset;
00094e  f24f73ff          MOV      r3,#0xf7ff
000952  4019              ANDS     r1,r1,r3
;;;1904     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000954  0613              LSLS     r3,r2,#24
000956  ea414113          ORR      r1,r1,r3,LSR #16
;;;1905     /* Write to TIMx CCER register */
;;;1906     TIMx->CCER = tmpccer;
00095a  8401              STRH     r1,[r0,#0x20]
;;;1907   }
00095c  4770              BX       lr
;;;1908   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1917     */
;;;1918   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00095e  460a              MOV      r2,r1
;;;1919   {
;;;1920     uint16_t tmpccer = 0;
000960  2100              MOVS     r1,#0
;;;1921     /* Check the parameters */
;;;1922     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1923     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1924     tmpccer = TIMx->CCER;
000962  8c01              LDRH     r1,[r0,#0x20]
;;;1925     /* Set or Reset the CC4P Bit */
;;;1926     tmpccer &= CCER_CC4P_Reset;
000964  f64d73ff          MOV      r3,#0xdfff
000968  4019              ANDS     r1,r1,r3
;;;1927     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00096a  0713              LSLS     r3,r2,#28
00096c  ea414113          ORR      r1,r1,r3,LSR #16
;;;1928     /* Write to TIMx CCER register */
;;;1929     TIMx->CCER = tmpccer;
000970  8401              STRH     r1,[r0,#0x20]
;;;1930   }
000972  4770              BX       lr
;;;1931   
                          ENDP

                  TIM_CCxCmd PROC
;;;1944     */
;;;1945   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000974  b530              PUSH     {r4,r5,lr}
;;;1946   {
;;;1947     uint16_t tmp = 0;
000976  2300              MOVS     r3,#0
;;;1948   
;;;1949     /* Check the parameters */
;;;1950     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1951     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1952     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1953   
;;;1954     tmp = CCER_CCE_Set << TIM_Channel;
000978  2401              MOVS     r4,#1
00097a  408c              LSLS     r4,r4,r1
00097c  b2a3              UXTH     r3,r4
;;;1955   
;;;1956     /* Reset the CCxE Bit */
;;;1957     TIMx->CCER &= (uint16_t)~ tmp;
00097e  8c04              LDRH     r4,[r0,#0x20]
000980  43dd              MVNS     r5,r3
000982  b2ad              UXTH     r5,r5
000984  402c              ANDS     r4,r4,r5
000986  8404              STRH     r4,[r0,#0x20]
;;;1958   
;;;1959     /* Set or reset the CCxE Bit */ 
;;;1960     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000988  8c04              LDRH     r4,[r0,#0x20]
00098a  fa02f501          LSL      r5,r2,r1
00098e  b2ad              UXTH     r5,r5
000990  432c              ORRS     r4,r4,r5
000992  8404              STRH     r4,[r0,#0x20]
;;;1961   }
000994  bd30              POP      {r4,r5,pc}
;;;1962   
                          ENDP

                  TIM_CCxNCmd PROC
;;;1974     */
;;;1975   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000996  b530              PUSH     {r4,r5,lr}
;;;1976   {
;;;1977     uint16_t tmp = 0;
000998  2300              MOVS     r3,#0
;;;1978   
;;;1979     /* Check the parameters */
;;;1980     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1981     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1982     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1983   
;;;1984     tmp = CCER_CCNE_Set << TIM_Channel;
00099a  2404              MOVS     r4,#4
00099c  408c              LSLS     r4,r4,r1
00099e  b2a3              UXTH     r3,r4
;;;1985   
;;;1986     /* Reset the CCxNE Bit */
;;;1987     TIMx->CCER &= (uint16_t) ~tmp;
0009a0  8c04              LDRH     r4,[r0,#0x20]
0009a2  43dd              MVNS     r5,r3
0009a4  b2ad              UXTH     r5,r5
0009a6  402c              ANDS     r4,r4,r5
0009a8  8404              STRH     r4,[r0,#0x20]
;;;1988   
;;;1989     /* Set or reset the CCxNE Bit */ 
;;;1990     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
0009aa  8c04              LDRH     r4,[r0,#0x20]
0009ac  fa02f501          LSL      r5,r2,r1
0009b0  b2ad              UXTH     r5,r5
0009b2  432c              ORRS     r4,r4,r5
0009b4  8404              STRH     r4,[r0,#0x20]
;;;1991   }
0009b6  bd30              POP      {r4,r5,pc}
;;;1992   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2015     */
;;;2016   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
0009b8  b570              PUSH     {r4-r6,lr}
;;;2017   {
0009ba  4603              MOV      r3,r0
;;;2018     uint32_t tmp = 0;
0009bc  2000              MOVS     r0,#0
;;;2019     uint16_t tmp1 = 0;
0009be  2400              MOVS     r4,#0
;;;2020   
;;;2021     /* Check the parameters */
;;;2022     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2023     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2024     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2025   
;;;2026     tmp = (uint32_t) TIMx;
0009c0  4618              MOV      r0,r3
;;;2027     tmp += CCMR_Offset;
0009c2  3018              ADDS     r0,r0,#0x18
;;;2028   
;;;2029     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
0009c4  2501              MOVS     r5,#1
0009c6  408d              LSLS     r5,r5,r1
0009c8  b2ac              UXTH     r4,r5
;;;2030   
;;;2031     /* Disable the Channel: Reset the CCxE Bit */
;;;2032     TIMx->CCER &= (uint16_t) ~tmp1;
0009ca  8c1d              LDRH     r5,[r3,#0x20]
0009cc  43e6              MVNS     r6,r4
0009ce  b2b6              UXTH     r6,r6
0009d0  4035              ANDS     r5,r5,r6
0009d2  841d              STRH     r5,[r3,#0x20]
;;;2033   
;;;2034     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
0009d4  b109              CBZ      r1,|L1.2522|
0009d6  2908              CMP      r1,#8
0009d8  d10a              BNE      |L1.2544|
                  |L1.2522|
;;;2035     {
;;;2036       tmp += (TIM_Channel>>1);
0009da  eb000061          ADD      r0,r0,r1,ASR #1
;;;2037   
;;;2038       /* Reset the OCxM bits in the CCMRx register */
;;;2039       *(__IO uint32_t *) tmp &= CCMR_OC13M_Mask;
0009de  6805              LDR      r5,[r0,#0]
0009e0  f64f768f          MOV      r6,#0xff8f
0009e4  4035              ANDS     r5,r5,r6
0009e6  6005              STR      r5,[r0,#0]
;;;2040      
;;;2041       /* Configure the OCxM bits in the CCMRx register */
;;;2042       *(__IO uint32_t *) tmp |= TIM_OCMode;
0009e8  6805              LDR      r5,[r0,#0]
0009ea  4315              ORRS     r5,r5,r2
0009ec  6005              STR      r5,[r0,#0]
0009ee  e00d              B        |L1.2572|
                  |L1.2544|
;;;2043     }
;;;2044     else
;;;2045     {
;;;2046       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
0009f0  1f0d              SUBS     r5,r1,#4
0009f2  b2ad              UXTH     r5,r5
0009f4  eb000065          ADD      r0,r0,r5,ASR #1
;;;2047   
;;;2048       /* Reset the OCxM bits in the CCMRx register */
;;;2049       *(__IO uint32_t *) tmp &= CCMR_OC24M_Mask;
0009f8  6805              LDR      r5,[r0,#0]
0009fa  f64876ff          MOV      r6,#0x8fff
0009fe  4035              ANDS     r5,r5,r6
000a00  6005              STR      r5,[r0,#0]
;;;2050       
;;;2051       /* Configure the OCxM bits in the CCMRx register */
;;;2052       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000a02  6805              LDR      r5,[r0,#0]
000a04  0616              LSLS     r6,r2,#24
000a06  ea454516          ORR      r5,r5,r6,LSR #16
000a0a  6005              STR      r5,[r0,#0]
                  |L1.2572|
;;;2053     }
;;;2054   }
000a0c  bd70              POP      {r4-r6,pc}
;;;2055   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2062     */
;;;2063   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000a0e  b121              CBZ      r1,|L1.2586|
;;;2064   {
;;;2065     /* Check the parameters */
;;;2066     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2067     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2068     if (NewState != DISABLE)
;;;2069     {
;;;2070       /* Set the Update Disable Bit */
;;;2071       TIMx->CR1 |= CR1_UDIS_Set;
000a10  8802              LDRH     r2,[r0,#0]
000a12  f0420202          ORR      r2,r2,#2
000a16  8002              STRH     r2,[r0,#0]
000a18  e004              B        |L1.2596|
                  |L1.2586|
;;;2072     }
;;;2073     else
;;;2074     {
;;;2075       /* Reset the Update Disable Bit */
;;;2076       TIMx->CR1 &= CR1_UDIS_Reset;
000a1a  8802              LDRH     r2,[r0,#0]
000a1c  f24033fd          MOV      r3,#0x3fd
000a20  401a              ANDS     r2,r2,r3
000a22  8002              STRH     r2,[r0,#0]
                  |L1.2596|
;;;2077     }
;;;2078   }
000a24  4770              BX       lr
;;;2079   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2090     */
;;;2091   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000a26  b121              CBZ      r1,|L1.2610|
;;;2092   {
;;;2093     /* Check the parameters */
;;;2094     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2095     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2096     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2097     {
;;;2098       /* Set the URS Bit */
;;;2099       TIMx->CR1 |= CR1_URS_Set;
000a28  8802              LDRH     r2,[r0,#0]
000a2a  f0420204          ORR      r2,r2,#4
000a2e  8002              STRH     r2,[r0,#0]
000a30  e004              B        |L1.2620|
                  |L1.2610|
;;;2100     }
;;;2101     else
;;;2102     {
;;;2103       /* Reset the URS Bit */
;;;2104       TIMx->CR1 &= CR1_URS_Reset;
000a32  8802              LDRH     r2,[r0,#0]
000a34  f24033fb          MOV      r3,#0x3fb
000a38  401a              ANDS     r2,r2,r3
000a3a  8002              STRH     r2,[r0,#0]
                  |L1.2620|
;;;2105     }
;;;2106   }
000a3c  4770              BX       lr
;;;2107   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2114     */
;;;2115   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000a3e  b121              CBZ      r1,|L1.2634|
;;;2116   {
;;;2117     /* Check the parameters */
;;;2118     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2119     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2120     if (NewState != DISABLE)
;;;2121     {
;;;2122       /* Set the TI1S Bit */
;;;2123       TIMx->CR2 |= CR2_TI1S_Set;
000a40  8882              LDRH     r2,[r0,#4]
000a42  f0420280          ORR      r2,r2,#0x80
000a46  8082              STRH     r2,[r0,#4]
000a48  e004              B        |L1.2644|
                  |L1.2634|
;;;2124     }
;;;2125     else
;;;2126     {
;;;2127       /* Reset the TI1S Bit */
;;;2128       TIMx->CR2 &= CR2_TI1S_Reset;
000a4a  8882              LDRH     r2,[r0,#4]
000a4c  f64f737f          MOV      r3,#0xff7f
000a50  401a              ANDS     r2,r2,r3
000a52  8082              STRH     r2,[r0,#4]
                  |L1.2644|
;;;2129     }
;;;2130   }
000a54  4770              BX       lr
;;;2131   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2140     */
;;;2141   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000a56  8802              LDRH     r2,[r0,#0]
;;;2142   {
;;;2143     /* Check the parameters */
;;;2144     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2145     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2146     /* Reset the OPM Bit */
;;;2147     TIMx->CR1 &= CR1_OPM_Reset;
000a58  f24033f7          MOV      r3,#0x3f7
000a5c  401a              ANDS     r2,r2,r3
000a5e  8002              STRH     r2,[r0,#0]
;;;2148     /* Configure the OPM Mode */
;;;2149     TIMx->CR1 |= TIM_OPMode;
000a60  8802              LDRH     r2,[r0,#0]
000a62  430a              ORRS     r2,r2,r1
000a64  8002              STRH     r2,[r0,#0]
;;;2150   }
000a66  4770              BX       lr
;;;2151   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2172     */
;;;2173   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000a68  8882              LDRH     r2,[r0,#4]
;;;2174   {
;;;2175     /* Check the parameters */
;;;2176     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2177     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2178     /* Reset the MMS Bits */
;;;2179     TIMx->CR2 &= CR2_MMS_Mask;
000a6a  f64f738f          MOV      r3,#0xff8f
000a6e  401a              ANDS     r2,r2,r3
000a70  8082              STRH     r2,[r0,#4]
;;;2180     /* Select the TRGO source */
;;;2181     TIMx->CR2 |=  TIM_TRGOSource;
000a72  8882              LDRH     r2,[r0,#4]
000a74  430a              ORRS     r2,r2,r1
000a76  8082              STRH     r2,[r0,#4]
;;;2182   }
000a78  4770              BX       lr
;;;2183   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2195     */
;;;2196   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000a7a  8902              LDRH     r2,[r0,#8]
;;;2197   {
;;;2198     /* Check the parameters */
;;;2199     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2200     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2201     /* Reset the SMS Bits */
;;;2202     TIMx->SMCR &= SMCR_SMS_Mask;
000a7c  f64f73f8          MOV      r3,#0xfff8
000a80  401a              ANDS     r2,r2,r3
000a82  8102              STRH     r2,[r0,#8]
;;;2203     /* Select the Slave Mode */
;;;2204     TIMx->SMCR |= TIM_SlaveMode;
000a84  8902              LDRH     r2,[r0,#8]
000a86  430a              ORRS     r2,r2,r1
000a88  8102              STRH     r2,[r0,#8]
;;;2205   }
000a8a  4770              BX       lr
;;;2206   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2216     */
;;;2217   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000a8c  8902              LDRH     r2,[r0,#8]
;;;2218   {
;;;2219     /* Check the parameters */
;;;2220     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2221     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2222     /* Reset the MSM Bit */
;;;2223     TIMx->SMCR &= SMCR_MSM_Reset;
000a8e  f64f737f          MOV      r3,#0xff7f
000a92  401a              ANDS     r2,r2,r3
000a94  8102              STRH     r2,[r0,#8]
;;;2224     
;;;2225     /* Set or Reset the MSM Bit */
;;;2226     TIMx->SMCR |= TIM_MasterSlaveMode;
000a96  8902              LDRH     r2,[r0,#8]
000a98  430a              ORRS     r2,r2,r1
000a9a  8102              STRH     r2,[r0,#8]
;;;2227   }
000a9c  4770              BX       lr
;;;2228   
                          ENDP

                  TIM_SetCounter PROC
;;;2234     */
;;;2235   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000a9e  8481              STRH     r1,[r0,#0x24]
;;;2236   {
;;;2237     /* Check the parameters */
;;;2238     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2239     /* Set the Counter Register value */
;;;2240     TIMx->CNT = Counter;
;;;2241   }
000aa0  4770              BX       lr
;;;2242   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2248     */
;;;2249   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000aa2  8581              STRH     r1,[r0,#0x2c]
;;;2250   {
;;;2251     /* Check the parameters */
;;;2252     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2253     /* Set the Autoreload Register value */
;;;2254     TIMx->ARR = Autoreload;
;;;2255   }
000aa4  4770              BX       lr
;;;2256   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2262     */
;;;2263   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000aa6  8681              STRH     r1,[r0,#0x34]
;;;2264   {
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2267     /* Set the Capture Compare1 Register value */
;;;2268     TIMx->CCR1 = Compare1;
;;;2269   }
000aa8  4770              BX       lr
;;;2270   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2276     */
;;;2277   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000aaa  8701              STRH     r1,[r0,#0x38]
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2281     /* Set the Capture Compare2 Register value */
;;;2282     TIMx->CCR2 = Compare2;
;;;2283   }
000aac  4770              BX       lr
;;;2284   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2290     */
;;;2291   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000aae  8781              STRH     r1,[r0,#0x3c]
;;;2292   {
;;;2293     /* Check the parameters */
;;;2294     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2295     /* Set the Capture Compare3 Register value */
;;;2296     TIMx->CCR3 = Compare3;
;;;2297   }
000ab0  4770              BX       lr
;;;2298   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2304     */
;;;2305   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000ab2  f8a01040          STRH     r1,[r0,#0x40]
;;;2306   {
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2309     /* Set the Capture Compare4 Register value */
;;;2310     TIMx->CCR4 = Compare4;
;;;2311   }
000ab6  4770              BX       lr
;;;2312   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2410     */
;;;2411   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000ab8  8802              LDRH     r2,[r0,#0]
;;;2412   {
;;;2413     /* Check the parameters */
;;;2414     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2415     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2416     /* Reset the CKD Bits */
;;;2417     TIMx->CR1 &= CR1_CKD_Mask;
000aba  b2d2              UXTB     r2,r2
000abc  8002              STRH     r2,[r0,#0]
;;;2418     /* Set the CKD value */
;;;2419     TIMx->CR1 |= TIM_CKD;
000abe  8802              LDRH     r2,[r0,#0]
000ac0  430a              ORRS     r2,r2,r1
000ac2  8002              STRH     r2,[r0,#0]
;;;2420   }
000ac4  4770              BX       lr
;;;2421   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2426     */
;;;2427   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000ac6  4601              MOV      r1,r0
;;;2428   {
;;;2429     /* Check the parameters */
;;;2430     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2431     /* Get the Capture 1 Register value */
;;;2432     return TIMx->CCR1;
000ac8  8e88              LDRH     r0,[r1,#0x34]
;;;2433   }
000aca  4770              BX       lr
;;;2434   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2439     */
;;;2440   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000acc  4601              MOV      r1,r0
;;;2441   {
;;;2442     /* Check the parameters */
;;;2443     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2444     /* Get the Capture 2 Register value */
;;;2445     return TIMx->CCR2;
000ace  8f08              LDRH     r0,[r1,#0x38]
;;;2446   }
000ad0  4770              BX       lr
;;;2447   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2452     */
;;;2453   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000ad2  4601              MOV      r1,r0
;;;2454   {
;;;2455     /* Check the parameters */
;;;2456     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2457     /* Get the Capture 3 Register value */
;;;2458     return TIMx->CCR3;
000ad4  8f88              LDRH     r0,[r1,#0x3c]
;;;2459   }
000ad6  4770              BX       lr
;;;2460   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2465     */
;;;2466   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000ad8  4601              MOV      r1,r0
;;;2467   {
;;;2468     /* Check the parameters */
;;;2469     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2470     /* Get the Capture 4 Register value */
;;;2471     return TIMx->CCR4;
000ada  f8b10040          LDRH     r0,[r1,#0x40]
;;;2472   }
000ade  4770              BX       lr
;;;2473   
                          ENDP

                  TIM_GetCounter PROC
;;;2478     */
;;;2479   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000ae0  4601              MOV      r1,r0
;;;2480   {
;;;2481     /* Check the parameters */
;;;2482     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2483     /* Get the Counter Register value */
;;;2484     return TIMx->CNT;
000ae2  8c88              LDRH     r0,[r1,#0x24]
;;;2485   }
000ae4  4770              BX       lr
;;;2486   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2491     */
;;;2492   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000ae6  4601              MOV      r1,r0
;;;2493   {
;;;2494     /* Check the parameters */
;;;2495     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2496     /* Get the Prescaler Register value */
;;;2497     return TIMx->PSC;
000ae8  8d08              LDRH     r0,[r1,#0x28]
;;;2498   }
000aea  4770              BX       lr
;;;2499   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2521     */
;;;2522   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000aec  4602              MOV      r2,r0
;;;2523   { 
;;;2524     ITStatus bitstatus = RESET;  
000aee  2000              MOVS     r0,#0
;;;2525     /* Check the parameters */
;;;2526     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2527     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2528     
;;;2529     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000af0  8a13              LDRH     r3,[r2,#0x10]
000af2  420b              TST      r3,r1
000af4  d001              BEQ      |L1.2810|
;;;2530     {
;;;2531       bitstatus = SET;
000af6  2001              MOVS     r0,#1
000af8  e000              B        |L1.2812|
                  |L1.2810|
;;;2532     }
;;;2533     else
;;;2534     {
;;;2535       bitstatus = RESET;
000afa  2000              MOVS     r0,#0
                  |L1.2812|
;;;2536     }
;;;2537     return bitstatus;
;;;2538   }
000afc  4770              BX       lr
;;;2539   
                          ENDP

                  TIM_ClearFlag PROC
;;;2561     */
;;;2562   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000afe  43ca              MVNS     r2,r1
;;;2563   {  
;;;2564     /* Check the parameters */
;;;2565     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2566     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2567      
;;;2568     /* Clear the flags */
;;;2569     TIMx->SR = (uint16_t)~TIM_FLAG;
000b00  8202              STRH     r2,[r0,#0x10]
;;;2570   }
000b02  4770              BX       lr
;;;2571   
                          ENDP

                  TIM_GetITStatus PROC
;;;2589     */
;;;2590   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000b04  b530              PUSH     {r4,r5,lr}
;;;2591   {
000b06  4602              MOV      r2,r0
;;;2592     ITStatus bitstatus = RESET;  
000b08  2000              MOVS     r0,#0
;;;2593     uint16_t itstatus = 0x0, itenable = 0x0;
000b0a  2300              MOVS     r3,#0
000b0c  2400              MOVS     r4,#0
;;;2594     /* Check the parameters */
;;;2595     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2596     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2597      
;;;2598     itstatus = TIMx->SR & TIM_IT;
000b0e  8a15              LDRH     r5,[r2,#0x10]
000b10  ea050301          AND      r3,r5,r1
;;;2599     
;;;2600     itenable = TIMx->DIER & TIM_IT;
000b14  8995              LDRH     r5,[r2,#0xc]
000b16  ea050401          AND      r4,r5,r1
;;;2601     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000b1a  b113              CBZ      r3,|L1.2850|
000b1c  b10c              CBZ      r4,|L1.2850|
;;;2602     {
;;;2603       bitstatus = SET;
000b1e  2001              MOVS     r0,#1
000b20  e000              B        |L1.2852|
                  |L1.2850|
;;;2604     }
;;;2605     else
;;;2606     {
;;;2607       bitstatus = RESET;
000b22  2000              MOVS     r0,#0
                  |L1.2852|
;;;2608     }
;;;2609     return bitstatus;
;;;2610   }
000b24  bd30              POP      {r4,r5,pc}
;;;2611   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2629     */
;;;2630   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000b26  43ca              MVNS     r2,r1
;;;2631   {
;;;2632     /* Check the parameters */
;;;2633     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2634     assert_param(IS_TIM_IT(TIM_IT));
;;;2635     /* Clear the IT pending Bit */
;;;2636     TIMx->SR = (uint16_t)~TIM_IT;
000b28  8202              STRH     r2,[r0,#0x10]
;;;2637   }
000b2a  4770              BX       lr
;;;2638   
                          ENDP

