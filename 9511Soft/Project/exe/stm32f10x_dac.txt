; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\stm32f10x_dac.o --depend=.\exe\stm32f10x_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\stm32f10x_dac.crf ..\Source\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_dac.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  DAC_DeInit PROC
;;;105      */
;;;106    void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;107    {
;;;108      /* Enable DAC reset state */
;;;109      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;110      /* Release DAC from reset state */
;;;111      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;112    }
000014  bd10              POP      {r4,pc}
;;;113    
                          ENDP

                  DAC_Init PROC
;;;124      */
;;;125    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000016  b530              PUSH     {r4,r5,lr}
;;;126    {
;;;127      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000018  2200              MOVS     r2,#0
00001a  2300              MOVS     r3,#0
;;;128      /* Check the DAC parameters */
;;;129      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;130      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;131      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;132      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;133    /*---------------------------- DAC CR Configuration --------------------------*/
;;;134      /* Get the DAC CR value */
;;;135      tmpreg1 = DAC->CR;
00001c  4c5f              LDR      r4,|L1.412|
00001e  6822              LDR      r2,[r4,#0]
;;;136      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;137      tmpreg1 &= ~(CR_CLEAR_Mask << DAC_Channel);
000020  f64074fe          MOV      r4,#0xffe
000024  fa04f400          LSL      r4,r4,r0
000028  ea220204          BIC      r2,r2,r4
;;;138      /* Configure for the selected DAC channel: buffer output, trigger, wave genration,
;;;139         mask/amplitude for wave genration */
;;;140      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;141      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;142      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;143      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;144      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
00002c  e9d14500          LDRD     r4,r5,[r1,#0]
000030  ea440405          ORR      r4,r4,r5
000034  688d              LDR      r5,[r1,#8]
000036  ea440405          ORR      r4,r4,r5
00003a  68cd              LDR      r5,[r1,#0xc]
00003c  ea440305          ORR      r3,r4,r5
;;;145                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;146      /* Calculate CR register value depending on DAC_Channel */
;;;147      tmpreg1 |= tmpreg2 << DAC_Channel;
000040  fa03f400          LSL      r4,r3,r0
000044  ea440202          ORR      r2,r4,r2
;;;148      /* Write to DAC CR */
;;;149      DAC->CR = tmpreg1;
000048  4c55              LDR      r4,|L1.416|
00004a  f8c42400          STR      r2,[r4,#0x400]
;;;150    }
00004e  bd30              POP      {r4,r5,pc}
;;;151    
                          ENDP

                  DAC_StructInit PROC
;;;157      */
;;;158    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000050  2100              MOVS     r1,#0
;;;159    {
;;;160    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;161      /* Initialize the DAC_Trigger member */
;;;162      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000052  6001              STR      r1,[r0,#0]
;;;163      /* Initialize the DAC_WaveGeneration member */
;;;164      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000054  6041              STR      r1,[r0,#4]
;;;165      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;166      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
000056  6081              STR      r1,[r0,#8]
;;;167      /* Initialize the DAC_OutputBuffer member */
;;;168      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
000058  60c1              STR      r1,[r0,#0xc]
;;;169    }
00005a  4770              BX       lr
;;;170    
                          ENDP

                  DAC_Cmd PROC
;;;180      */
;;;181    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
00005c  b159              CBZ      r1,|L1.118|
;;;182    {
;;;183      /* Check the parameters */
;;;184      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;185      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;186      if (NewState != DISABLE)
;;;187      {
;;;188        /* Enable the selected DAC channel */
;;;189        DAC->CR |= CR_EN_Set << DAC_Channel;
00005e  4a4f              LDR      r2,|L1.412|
000060  6812              LDR      r2,[r2,#0]
000062  f04f0301          MOV      r3,#1
000066  fa03f300          LSL      r3,r3,r0
00006a  ea420203          ORR      r2,r2,r3
00006e  4b4c              LDR      r3,|L1.416|
000070  f8c32400          STR      r2,[r3,#0x400]
000074  e00a              B        |L1.140|
                  |L1.118|
;;;190      }
;;;191      else
;;;192      {
;;;193        /* Disable the selected DAC channel */
;;;194        DAC->CR &= ~(CR_EN_Set << DAC_Channel);
000076  4a49              LDR      r2,|L1.412|
000078  6812              LDR      r2,[r2,#0]
00007a  f04f0301          MOV      r3,#1
00007e  fa03f300          LSL      r3,r3,r0
000082  ea220203          BIC      r2,r2,r3
000086  4b46              LDR      r3,|L1.416|
000088  f8c32400          STR      r2,[r3,#0x400]
                  |L1.140|
;;;195      }
;;;196    }
00008c  4770              BX       lr
;;;197    
                          ENDP

                  DAC_DMACmd PROC
;;;207      */
;;;208    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
00008e  b159              CBZ      r1,|L1.168|
;;;209    {
;;;210      /* Check the parameters */
;;;211      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;212      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;213      if (NewState != DISABLE)
;;;214      {
;;;215        /* Enable the selected DAC channel DMA request */
;;;216        DAC->CR |= CR_DMAEN_Set << DAC_Channel;
000090  4a42              LDR      r2,|L1.412|
000092  6812              LDR      r2,[r2,#0]
000094  f44f5380          MOV      r3,#0x1000
000098  fa03f300          LSL      r3,r3,r0
00009c  ea420203          ORR      r2,r2,r3
0000a0  4b3f              LDR      r3,|L1.416|
0000a2  f8c32400          STR      r2,[r3,#0x400]
0000a6  e00a              B        |L1.190|
                  |L1.168|
;;;217      }
;;;218      else
;;;219      {
;;;220        /* Disable the selected DAC channel DMA request */
;;;221        DAC->CR &= ~(CR_DMAEN_Set << DAC_Channel);
0000a8  4a3c              LDR      r2,|L1.412|
0000aa  6812              LDR      r2,[r2,#0]
0000ac  f44f5380          MOV      r3,#0x1000
0000b0  fa03f300          LSL      r3,r3,r0
0000b4  ea220203          BIC      r2,r2,r3
0000b8  4b39              LDR      r3,|L1.416|
0000ba  f8c32400          STR      r2,[r3,#0x400]
                  |L1.190|
;;;222      }
;;;223    }
0000be  4770              BX       lr
;;;224    
                          ENDP

                  DAC_SoftwareTriggerCmd PROC
;;;234      */
;;;235    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
0000c0  b510              PUSH     {r4,lr}
;;;236    {
;;;237      /* Check the parameters */
;;;238      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;239      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;240      if (NewState != DISABLE)
0000c2  b169              CBZ      r1,|L1.224|
;;;241      {
;;;242        /* Enable software trigger for the selected DAC channel */
;;;243        DAC->SWTRIGR |= SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4);
0000c4  4a37              LDR      r2,|L1.420|
0000c6  6812              LDR      r2,[r2,#0]
0000c8  ea4f1410          LSR      r4,r0,#4
0000cc  f04f0301          MOV      r3,#1
0000d0  fa03f304          LSL      r3,r3,r4
0000d4  ea420203          ORR      r2,r2,r3
0000d8  4b31              LDR      r3,|L1.416|
0000da  f8c32404          STR      r2,[r3,#0x404]
0000de  e00c              B        |L1.250|
                  |L1.224|
;;;244      }
;;;245      else
;;;246      {
;;;247        /* Disable software trigger for the selected DAC channel */
;;;248        DAC->SWTRIGR &= ~(SWTRIGR_SWTRIG_Set << (DAC_Channel >> 4));
0000e0  4a30              LDR      r2,|L1.420|
0000e2  6812              LDR      r2,[r2,#0]
0000e4  ea4f1410          LSR      r4,r0,#4
0000e8  f04f0301          MOV      r3,#1
0000ec  fa03f304          LSL      r3,r3,r4
0000f0  ea220203          BIC      r2,r2,r3
0000f4  4b2a              LDR      r3,|L1.416|
0000f6  f8c32404          STR      r2,[r3,#0x404]
                  |L1.250|
;;;249      }
;;;250    }
0000fa  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  DAC_DualSoftwareTriggerCmd PROC
;;;258      */
;;;259    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
0000fc  b138              CBZ      r0,|L1.270|
;;;260    {
;;;261      /* Check the parameters */
;;;262      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;263      if (NewState != DISABLE)
;;;264      {
;;;265        /* Enable software trigger for both DAC channels */
;;;266        DAC->SWTRIGR |= DUAL_SWTRIG_Set ;
0000fe  4929              LDR      r1,|L1.420|
000100  6809              LDR      r1,[r1,#0]
000102  f0410103          ORR      r1,r1,#3
000106  4a26              LDR      r2,|L1.416|
000108  f8c21404          STR      r1,[r2,#0x404]
00010c  e006              B        |L1.284|
                  |L1.270|
;;;267      }
;;;268      else
;;;269      {
;;;270        /* Disable software trigger for both DAC channels */
;;;271        DAC->SWTRIGR &= DUAL_SWTRIG_Reset;
00010e  4925              LDR      r1,|L1.420|
000110  6809              LDR      r1,[r1,#0]
000112  f0210103          BIC      r1,r1,#3
000116  4a22              LDR      r2,|L1.416|
000118  f8c21404          STR      r1,[r2,#0x404]
                  |L1.284|
;;;272      }
;;;273    }
00011c  4770              BX       lr
;;;274    
                          ENDP

                  DAC_WaveGenerationCmd PROC
;;;288      */
;;;289    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
00011e  b510              PUSH     {r4,lr}
;;;290    {
;;;291      /* Check the parameters */
;;;292      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;293      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;294      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;295      if (NewState != DISABLE)
000120  b14a              CBZ      r2,|L1.310|
;;;296      {
;;;297        /* Enable the selected wave generation for the selected DAC channel */
;;;298        DAC->CR |= DAC_Wave << DAC_Channel;
000122  4b1e              LDR      r3,|L1.412|
000124  681b              LDR      r3,[r3,#0]
000126  fa01f400          LSL      r4,r1,r0
00012a  ea430304          ORR      r3,r3,r4
00012e  4c1c              LDR      r4,|L1.416|
000130  f8c43400          STR      r3,[r4,#0x400]
000134  e008              B        |L1.328|
                  |L1.310|
;;;299      }
;;;300      else
;;;301      {
;;;302        /* Disable the selected wave generation for the selected DAC channel */
;;;303        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000136  4b19              LDR      r3,|L1.412|
000138  681b              LDR      r3,[r3,#0]
00013a  fa01f400          LSL      r4,r1,r0
00013e  ea230304          BIC      r3,r3,r4
000142  4c17              LDR      r4,|L1.416|
000144  f8c43400          STR      r3,[r4,#0x400]
                  |L1.328|
;;;304      }
;;;305    }
000148  bd10              POP      {r4,pc}
;;;306    
                          ENDP

                  DAC_SetChannel1Data PROC
;;;316      */
;;;317    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
00014a  2200              MOVS     r2,#0
;;;318    {  
;;;319      __IO uint32_t tmp = 0;
;;;320      
;;;321      /* Check the parameters */
;;;322      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;323      assert_param(IS_DAC_DATA(Data));
;;;324      
;;;325      tmp = (uint32_t)DAC_BASE; 
00014c  4a13              LDR      r2,|L1.412|
;;;326      tmp += DHR12R1_Offset + DAC_Align;
00014e  f1000308          ADD      r3,r0,#8
000152  441a              ADD      r2,r2,r3
;;;327    
;;;328      /* Set the DAC channel1 selected data holding register */
;;;329      *(__IO uint32_t *) tmp = Data;
000154  6011              STR      r1,[r2,#0]
;;;330    }
000156  4770              BX       lr
;;;331    
                          ENDP

                  DAC_SetChannel2Data PROC
;;;341      */
;;;342    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
000158  2200              MOVS     r2,#0
;;;343    {
;;;344      __IO uint32_t tmp = 0;
;;;345    
;;;346      /* Check the parameters */
;;;347      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;348      assert_param(IS_DAC_DATA(Data));
;;;349      
;;;350      tmp = (uint32_t)DAC_BASE;
00015a  4a10              LDR      r2,|L1.412|
;;;351      tmp += DHR12R2_Offset + DAC_Align;
00015c  f1000314          ADD      r3,r0,#0x14
000160  441a              ADD      r2,r2,r3
;;;352    
;;;353      /* Set the DAC channel2 selected data holding register */
;;;354      *(__IO uint32_t *)tmp = Data;
000162  6011              STR      r1,[r2,#0]
;;;355    }
000164  4770              BX       lr
;;;356    
                          ENDP

                  DAC_SetDualChannelData PROC
;;;370      */
;;;371    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000166  b530              PUSH     {r4,r5,lr}
;;;372    {
;;;373      uint32_t data = 0, tmp = 0;
000168  2400              MOVS     r4,#0
00016a  2300              MOVS     r3,#0
;;;374      
;;;375      /* Check the parameters */
;;;376      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;377      assert_param(IS_DAC_DATA(Data1));
;;;378      assert_param(IS_DAC_DATA(Data2));
;;;379      
;;;380      /* Calculate and set dual DAC data holding register value */
;;;381      if (DAC_Align == DAC_Align_8b_R)
00016c  2808              CMP      r0,#8
00016e  d102              BNE      |L1.374|
;;;382      {
;;;383        data = ((uint32_t)Data2 << 8) | Data1; 
000170  ea422401          ORR      r4,r2,r1,LSL #8
000174  e001              B        |L1.378|
                  |L1.374|
;;;384      }
;;;385      else
;;;386      {
;;;387        data = ((uint32_t)Data2 << 16) | Data1;
000176  ea424401          ORR      r4,r2,r1,LSL #16
                  |L1.378|
;;;388      }
;;;389      
;;;390      tmp = (uint32_t)DAC_BASE;
00017a  4b08              LDR      r3,|L1.412|
;;;391      tmp += DHR12RD_Offset + DAC_Align;
00017c  f1000520          ADD      r5,r0,#0x20
000180  442b              ADD      r3,r3,r5
;;;392    
;;;393      /* Set the dual DAC selected data holding register */
;;;394      *(__IO uint32_t *)tmp = data;
000182  601c              STR      r4,[r3,#0]
;;;395    }
000184  bd30              POP      {r4,r5,pc}
;;;396    
                          ENDP

                  DAC_GetDataOutputValue PROC
;;;404      */
;;;405    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000186  4601              MOV      r1,r0
;;;406    {
;;;407      __IO uint32_t tmp = 0;
000188  2200              MOVS     r2,#0
;;;408      
;;;409      /* Check the parameters */
;;;410      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;411      
;;;412      tmp = (uint32_t) DAC_BASE ;
00018a  4a04              LDR      r2,|L1.412|
;;;413      tmp += DOR_Offset + ((uint32_t)DAC_Channel >> 2);
00018c  202c              MOVS     r0,#0x2c
00018e  eb000091          ADD      r0,r0,r1,LSR #2
000192  4402              ADD      r2,r2,r0
;;;414      
;;;415      /* Returns the DAC channel data output register value */
;;;416      return (uint16_t) (*(__IO uint32_t*) tmp);
000194  6810              LDR      r0,[r2,#0]
000196  b280              UXTH     r0,r0
;;;417    }
000198  4770              BX       lr
;;;418    
                          ENDP

00019a  0000              DCW      0x0000
                  |L1.412|
                          DCD      0x40007400
                  |L1.416|
                          DCD      0x40007000
                  |L1.420|
                          DCD      0x40007404
