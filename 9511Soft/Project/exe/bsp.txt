; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\exe\bsp.o --depend=.\exe\bsp.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Source\APP -I..\Source\APP\MC -I..\Source\BSP -I..\Source\FS\FF007 -I..\Source\OS\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView -I..\Source\OS\uCOS-II\Source -I..\Source\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Source\Libraries\CMSIS\Core\CM3 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DHARDWARE_VER=1 --omf_browse=.\exe\bsp.crf ..\Source\BSP\bsp.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  BSP_EnPeriph PROC
;;;282    /// -----------------------------------------------------------------------------------------------------
;;;283    static  void  BSP_EnPeriph (void)
000000  b510              PUSH     {r4,lr}
;;;284    {
;;;285        /// Enable peripheral clocks
;;;286        RCC_AHBPeriphClockCmd( RCC_AHBPeriph_DMA1
000002  2101              MOVS     r1,#1
000004  2043              MOVS     r0,#0x43
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;287                             | RCC_AHBPeriph_DMA2                   /// 目前没有使用
;;;288                             | RCC_AHBPeriph_CRC,
;;;289                             ENABLE);
;;;290        
;;;291        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2
00000a  2101              MOVS     r1,#1
00000c  48f9              LDR      r0,|L1.1012|
00000e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;292                             | RCC_APB1Periph_TIM3
;;;293                             | RCC_APB1Periph_TIM4
;;;294                             | RCC_APB1Periph_USART3                /// 目前没有使用
;;;295                             | RCC_APB1Periph_CAN1,                 /// 目前没有使用
;;;296                             ENABLE);
;;;297        
;;;298        RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO
000012  2101              MOVS     r1,#1
000014  f64c607d          MOV      r0,#0xce7d
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;299                             | RCC_APB2Periph_GPIOA
;;;300                             | RCC_APB2Periph_GPIOB
;;;301                             | RCC_APB2Periph_GPIOC
;;;302                             | RCC_APB2Periph_GPIOD
;;;303                             | RCC_APB2Periph_GPIOE
;;;304                             | RCC_APB2Periph_ADC1
;;;305                             | RCC_APB2Periph_ADC2
;;;306                             | RCC_APB2Periph_TIM1
;;;307                             | RCC_APB2Periph_USART1
;;;308                             | RCC_APB2Periph_ADC3,                 /// V8 和 VB 无 ADC3
;;;309                             ENABLE);
;;;310    }
00001c  bd10              POP      {r4,pc}
;;;311    
                          ENDP

                  BSP_NVIC_Cfg PROC
;;;317    /// -----------------------------------------------------------------------------------------------------
;;;318    static  void  BSP_NVIC_Cfg (void)
00001e  b508              PUSH     {r3,lr}
;;;319    {
;;;320        NVIC_InitTypeDef    sNVICInit;
;;;321        
;;;322        
;;;323        /// Configure the NVIC Preemption Priority Bits. 暂时设置不可占先
;;;324        NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000020  f44f60e0          MOV      r0,#0x700
000024  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;325        
;;;326        /// Enable the BSP_USART_491 Interrupt
;;;327        sNVICInit.NVIC_IRQChannel               =   USART1_IRQn;
000028  2025              MOVS     r0,#0x25
00002a  f88d0000          STRB     r0,[sp,#0]
;;;328        sNVICInit.NVIC_IRQChannelSubPriority    =   8;
00002e  2008              MOVS     r0,#8
000030  f88d0002          STRB     r0,[sp,#2]
;;;329        sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
000034  2001              MOVS     r0,#1
000036  f88d0003          STRB     r0,[sp,#3]
;;;330        NVIC_Init(&sNVICInit);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       NVIC_Init
;;;331        
;;;332        /// 定时
;;;333        sNVICInit.NVIC_IRQChannel               =   TIM1_CC_IRQn;
000040  201b              MOVS     r0,#0x1b
000042  f88d0000          STRB     r0,[sp,#0]
;;;334        sNVICInit.NVIC_IRQChannelSubPriority    =   4;
000046  2004              MOVS     r0,#4
000048  f88d0002          STRB     r0,[sp,#2]
;;;335        sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
00004c  2001              MOVS     r0,#1
00004e  f88d0003          STRB     r0,[sp,#3]
;;;336        NVIC_Init(&sNVICInit);
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       NVIC_Init
;;;337        
;;;338    /// 如果不是924, 不必打开下列中断, 以免误入
;;;339    #ifdef  PC924                               
;;;340        /// 模拟计数
;;;341        sNVICInit.NVIC_IRQChannel               =   TIM3_IRQn;
;;;342        sNVICInit.NVIC_IRQChannelSubPriority    =   2;
;;;343        sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
;;;344        NVIC_Init(&sNVICInit);
;;;345        
;;;346        /// the irq of encoder index gpio
;;;347        sNVICInit.NVIC_IRQChannel               =   EXTI2_IRQn;
;;;348        sNVICInit.NVIC_IRQChannelSubPriority    =   1;
;;;349        sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
;;;350        NVIC_Init(&sNVICInit);
;;;351        sNVICInit.NVIC_IRQChannel               =   EXTI9_5_IRQn;
;;;352        sNVICInit.NVIC_IRQChannelSubPriority    =   1;
;;;353        sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
;;;354        NVIC_Init(&sNVICInit);
;;;355        
;;;356    //    /// the timer of encoder
;;;357    //    sNVICInit.NVIC_IRQChannel               =   TIM2_IRQn;
;;;358    //    sNVICInit.NVIC_IRQChannelSubPriority    =   0;
;;;359    //    sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
;;;360    //    NVIC_Init(&sNVICInit);
;;;361    //    sNVICInit.NVIC_IRQChannel               =   TIM4_IRQn;
;;;362    //    sNVICInit.NVIC_IRQChannelSubPriority    =   0;
;;;363    //    sNVICInit.NVIC_IRQChannelCmd            =   ENABLE;
;;;364    //    NVIC_Init(&sNVICInit);
;;;365    #endif
;;;366    
;;;367    }
000058  bd08              POP      {r3,pc}
;;;368    
                          ENDP

                  BSP_TM8M_Init PROC
;;;370    //static  void  BSP_US_Init (void)
;;;371    static  void  BSP_TM8M_Init (void)
00005a  b50e              PUSH     {r1-r3,lr}
;;;372    {
;;;373        TIM_TimeBaseInitTypeDef     sTimeBaseInit;
;;;374        
;;;375        
;;;376        /// Time Base configuration
;;;377        sTimeBaseInit.TIM_Prescaler         =   SystemFrequency / BSP_TMR_8M_CLK - 1;   /// clock = 8MHz
00005c  48e6              LDR      r0,|L1.1016|
00005e  6800              LDR      r0,[r0,#0]  ; SystemFrequency
000060  49e6              LDR      r1,|L1.1020|
000062  fbb0f0f1          UDIV     r0,r0,r1
000066  1e40              SUBS     r0,r0,#1
000068  b280              UXTH     r0,r0
00006a  f8ad0000          STRH     r0,[sp,#0]
;;;378        sTimeBaseInit.TIM_CounterMode       =   TIM_CounterMode_Up;
00006e  2000              MOVS     r0,#0
000070  f8ad0002          STRH     r0,[sp,#2]
;;;379        sTimeBaseInit.TIM_Period            =   (u16)(-1);                              /// MAX_U16
000074  f64f70ff          MOV      r0,#0xffff
000078  f8ad0004          STRH     r0,[sp,#4]
;;;380        sTimeBaseInit.TIM_ClockDivision     =   TIM_CKD_DIV1;
00007c  2000              MOVS     r0,#0
00007e  f8ad0006          STRH     r0,[sp,#6]
;;;381        sTimeBaseInit.TIM_RepetitionCounter =   0;
000082  f88d0008          STRB     r0,[sp,#8]
;;;382        TIM_TimeBaseInit(BSP_TMR_8M, &sTimeBaseInit);
000086  4669              MOV      r1,sp
000088  48dd              LDR      r0,|L1.1024|
00008a  f7fffffe          BL       TIM_TimeBaseInit
;;;383    
;;;384        /// TIM1 counter enable
;;;385        TIM_Cmd(BSP_TMR_8M, ENABLE);
00008e  2101              MOVS     r1,#1
000090  48db              LDR      r0,|L1.1024|
000092  f7fffffe          BL       TIM_Cmd
;;;386    }
000096  bd0e              POP      {r1-r3,pc}
;;;387    
                          ENDP

                  BSP_TM8M_Get PROC
;;;388    //u16  BSP_US_Get (void)
;;;389    u16  BSP_TM8M_Get (void)
000098  48da              LDR      r0,|L1.1028|
;;;390    {
;;;391        return  BSP_TMR_8M->CNT;
00009a  8800              LDRH     r0,[r0,#0]
;;;392    }
00009c  4770              BX       lr
;;;393    
                          ENDP

                  BSP_TM8M_Delay PROC
;;;420    
;;;421    void  BSP_TM8M_Delay (u16 time)
00009e  b510              PUSH     {r4,lr}
;;;422    {
0000a0  4603              MOV      r3,r0
;;;423        u16     start;
;;;424        u16     aim;
;;;425        u16     cnt;
;;;426        
;;;427        
;;;428        start   =   BSP_TMR_8M->CNT;
0000a2  4cd8              LDR      r4,|L1.1028|
0000a4  8821              LDRH     r1,[r4,#0]
;;;429        if (time < 2) {
0000a6  2b02              CMP      r3,#2
0000a8  da00              BGE      |L1.172|
;;;430            time = 2;
0000aa  2302              MOVS     r3,#2
                  |L1.172|
;;;431        }
;;;432        aim     =   start + time;
0000ac  18cc              ADDS     r4,r1,r3
0000ae  b2a2              UXTH     r2,r4
;;;433        
;;;434        if (aim > start) {
0000b0  428a              CMP      r2,r1
0000b2  dd07              BLE      |L1.196|
;;;435            do {
0000b4  bf00              NOP      
                  |L1.182|
;;;436                cnt =   BSP_TMR_8M->CNT;
0000b6  4cd3              LDR      r4,|L1.1028|
0000b8  8820              LDRH     r0,[r4,#0]
;;;437            } while ((cnt >= start) && (cnt < aim));
0000ba  4288              CMP      r0,r1
0000bc  db09              BLT      |L1.210|
0000be  4290              CMP      r0,r2
0000c0  dbf9              BLT      |L1.182|
0000c2  e006              B        |L1.210|
                  |L1.196|
;;;438        } else {                                        /// 不可能相等, 只可能 aim < start
;;;439            do {
0000c4  bf00              NOP      
                  |L1.198|
;;;440                cnt =   BSP_TMR_8M->CNT;
0000c6  4ccf              LDR      r4,|L1.1028|
0000c8  8820              LDRH     r0,[r4,#0]
;;;441            } while ((cnt < aim) || (cnt >= start));
0000ca  4290              CMP      r0,r2
0000cc  dbfb              BLT      |L1.198|
0000ce  4288              CMP      r0,r1
0000d0  daf9              BGE      |L1.198|
                  |L1.210|
;;;442        }
;;;443    }
0000d2  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  BSP_TM_CNT_Init PROC
;;;445    
;;;446    static  void  BSP_TM_CNT_Init (void)
0000d4  b5fe              PUSH     {r1-r7,lr}
;;;447    {
;;;448        u32                         i;
;;;449        u32                         m_d10;
;;;450        u16                         spd_d10;
;;;451        TIM_TimeBaseInitTypeDef     sTimeBaseInit;
;;;452        
;;;453        
;;;454        for (i = 0; i < BSP_SPD_NUM; i++) {
0000d6  2400              MOVS     r4,#0
0000d8  e018              B        |L1.268|
                  |L1.218|
;;;455            m_d10                       =   SystemFrequency / BSP_COUNTER_PR * 60 / 10;
0000da  48c7              LDR      r0,|L1.1016|
0000dc  6800              LDR      r0,[r0,#0]  ; SystemFrequency
0000de  f44f51fa          MOV      r1,#0x1f40
0000e2  fbb0f0f1          UDIV     r0,r0,r1
0000e6  ebc01000          RSB      r0,r0,r0,LSL #4
0000ea  0080              LSLS     r0,r0,#2
0000ec  210a              MOVS     r1,#0xa
0000ee  fbb0f6f1          UDIV     r6,r0,r1
;;;456            spd_d10                     =   i + BSP_SPD_D10_MIN;
0000f2  f1040008          ADD      r0,r4,#8
0000f6  b285              UXTH     r5,r0
;;;457            BSP_TMR_CNT_PRESCALER[i]    =   (m_d10 * 2 + spd_d10) / (spd_d10 * 2) - 1;
0000f8  eb050046          ADD      r0,r5,r6,LSL #1
0000fc  0069              LSLS     r1,r5,#1
0000fe  fbb0f0f1          UDIV     r0,r0,r1
000102  1e40              SUBS     r0,r0,#1
000104  49c0              LDR      r1,|L1.1032|
000106  f8210014          STRH     r0,[r1,r4,LSL #1]
00010a  1c64              ADDS     r4,r4,#1              ;454
                  |L1.268|
00010c  2c5d              CMP      r4,#0x5d              ;454
00010e  d3e4              BCC      |L1.218|
;;;458        }
;;;459        
;;;460        /// Time Base configuration
;;;461        sTimeBaseInit.TIM_Prescaler         =   BSP_TMR_CNT_PRESCALER[0];               /// clock = SystemFrequency
000110  48bd              LDR      r0,|L1.1032|
000112  8800              LDRH     r0,[r0,#0]  ; BSP_TMR_CNT_PRESCALER
000114  f8ad0000          STRH     r0,[sp,#0]
;;;462        sTimeBaseInit.TIM_CounterMode       =   TIM_CounterMode_Up;
000118  2000              MOVS     r0,#0
00011a  f8ad0002          STRH     r0,[sp,#2]
;;;463        sTimeBaseInit.TIM_Period            =   (u16)(-1);                              /// MAX_U16
00011e  f64f70ff          MOV      r0,#0xffff
000122  f8ad0004          STRH     r0,[sp,#4]
;;;464        sTimeBaseInit.TIM_ClockDivision     =   TIM_CKD_DIV1;
000126  2000              MOVS     r0,#0
000128  f8ad0006          STRH     r0,[sp,#6]
;;;465        sTimeBaseInit.TIM_RepetitionCounter =   0;
00012c  f88d0008          STRB     r0,[sp,#8]
;;;466        TIM_TimeBaseInit(BSP_TMR_CNT, &sTimeBaseInit);
000130  4669              MOV      r1,sp
000132  48b6              LDR      r0,|L1.1036|
000134  f7fffffe          BL       TIM_TimeBaseInit
;;;467        
;;;468        /// TIM3 counter enable
;;;469        TIM_Cmd(BSP_TMR_CNT, ENABLE);
000138  2101              MOVS     r1,#1
00013a  48b4              LDR      r0,|L1.1036|
00013c  f7fffffe          BL       TIM_Cmd
;;;470    }
000140  bdfe              POP      {r1-r7,pc}
;;;471    
                          ENDP

                  BSP_TM_CNT_SpdSet PROC
;;;472    void  BSP_TM_CNT_SpdSet (u16 spd_d10)
000142  b510              PUSH     {r4,lr}
;;;473    {
000144  4604              MOV      r4,r0
;;;474        if ((BSP_SPD_D10_MIN <= spd_d10) && (spd_d10 <= BSP_SPD_D10_MAX)) {
000146  2c08              CMP      r4,#8
000148  db0a              BLT      |L1.352|
00014a  2c64              CMP      r4,#0x64
00014c  dc08              BGT      |L1.352|
;;;475            TIM_PrescalerConfig(BSP_TMR_CNT,
00014e  f1a40008          SUB      r0,r4,#8
000152  4aad              LDR      r2,|L1.1032|
000154  f8321010          LDRH     r1,[r2,r0,LSL #1]
000158  2201              MOVS     r2,#1
00015a  48ac              LDR      r0,|L1.1036|
00015c  f7fffffe          BL       TIM_PrescalerConfig
                  |L1.352|
;;;476                                BSP_TMR_CNT_PRESCALER[spd_d10 - BSP_SPD_D10_MIN],
;;;477                                TIM_PSCReloadMode_Immediate);
;;;478        }
;;;479    }
000160  bd10              POP      {r4,pc}
;;;480    
                          ENDP

                  BSP_TM_CNT_Get PROC
;;;481    u16  BSP_TM_CNT_Get (void)
000162  48ab              LDR      r0,|L1.1040|
;;;482    {
;;;483        return  BSP_TMR_CNT->CNT;
000164  8800              LDRH     r0,[r0,#0]
;;;484    }
000166  4770              BX       lr
;;;485    
                          ENDP

                  BSP_Judge924 PROC
;;;563    /// -----------------------------------------------------------------------------------------------------
;;;564    static  void  BSP_Judge924 (void)
000168  2000              MOVS     r0,#0
;;;565    {
;;;566    #ifdef  PC924
;;;567        u32     i;
;;;568    #endif
;;;569        
;;;570        
;;;571        BSP_Is924   =   FALSE;
00016a  49aa              LDR      r1,|L1.1044|
00016c  7008              STRB     r0,[r1,#0]
;;;572        
;;;573    #ifdef  PC924
;;;574        for (i = 0; i < BSP_DEVICE_ID_N; i++) {
;;;575            IO_Init(io_id_pro_c[i], GPIO_Mode_IPD);
;;;576            if (IO_InGet(io_id_pro_c[i]) != 0) {
;;;577                BSP_Is924   =   TRUE;
;;;578            }
;;;579            IO_Init(io_id_pro_c[i], GPIO_Mode_IPU);
;;;580        }
;;;581    #endif
;;;582    }
00016e  4770              BX       lr
;;;583    
                          ENDP

                  BSP_SQN_EmbStSend PROC
;;;1988   
;;;1989   void  BSP_SQN_EmbStSend (BSP_ID_TypeDef id, BSP_EMB_ST_TypeDef st)
000170  b570              PUSH     {r4-r6,lr}
;;;1990   {
000172  4604              MOV      r4,r0
000174  460d              MOV      r5,r1
;;;1991       IO_MultiOutSet(io_id_sqn[id], 2, (u32)st);
000176  49a8              LDR      r1,|L1.1048|
000178  5d08              LDRB     r0,[r1,r4]
00017a  462a              MOV      r2,r5
00017c  2102              MOVS     r1,#2
00017e  f7fffffe          BL       IO_MultiOutSet
;;;1992   }
000182  bd70              POP      {r4-r6,pc}
;;;1993   
                          ENDP

                  BSP_SQN_Init PROC
;;;1953   /// -----------------------------------------------------------------------------------------------------
;;;1954   static  void  BSP_SQN_Init (void)
000184  b510              PUSH     {r4,lr}
;;;1955   {
;;;1956   //    IO_Init(PD02_SQN_G_ODD , GPIO_Mode_Out_PP);
;;;1957   //    IO_Init(PD03_SQN_R_ODD , GPIO_Mode_Out_PP);
;;;1958   //    IO_Init(PD04_SQN_G_EVEN, GPIO_Mode_Out_PP);
;;;1959   //    IO_Init(PD05_SQN_R_EVEN, GPIO_Mode_Out_PP);
;;;1960       u32     i;
;;;1961       
;;;1962       
;;;1963       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
000186  2400              MOVS     r4,#0
000188  e00a              B        |L1.416|
                  |L1.394|
;;;1964           IO_MultiInit(io_id_sqn[i], 2, GPIO_Mode_Out_PP);
00018a  49a3              LDR      r1,|L1.1048|
00018c  5d08              LDRB     r0,[r1,r4]
00018e  2210              MOVS     r2,#0x10
000190  2102              MOVS     r1,#2
000192  f7fffffe          BL       IO_MultiInit
;;;1965           BSP_SQN_EmbStSend((BSP_ID_TypeDef)i, BSP_EMB_ST_NORMAL);
000196  2101              MOVS     r1,#1
000198  b2e0              UXTB     r0,r4
00019a  f7fffffe          BL       BSP_SQN_EmbStSend
00019e  1c64              ADDS     r4,r4,#1              ;1963
                  |L1.416|
0001a0  2c02              CMP      r4,#2                 ;1963
0001a2  d3f2              BCC      |L1.394|
;;;1966       }
;;;1967   }
0001a4  bd10              POP      {r4,pc}
;;;1968   
                          ENDP

                  BSP_POT_Init PROC
;;;1593   /// -----------------------------------------------------------------------------------------------------
;;;1594   static  void  BSP_POT_Init (void)
0001a6  b500              PUSH     {lr}
;;;1595   {
0001a8  b091              SUB      sp,sp,#0x44
;;;1596       ADC_InitTypeDef             sADCInit;
;;;1597       DMA_InitTypeDef             sDMAInit;
;;;1598       
;;;1599       
;;;1600   //      /* DMA1 channel1 configuration ----------------------------------------------*/
;;;1601   //  DMA_DeInit(DMA1_Channel1);
;;;1602   //  DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR_Address;
;;;1603   //  DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)ADC_DualConvertedValueTab;
;;;1604   //  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
;;;1605   //  DMA_InitStructure.DMA_BufferSize = 16;
;;;1606   //  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;1607   //  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
;;;1608   //  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
;;;1609   //  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
;;;1610   //  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
;;;1611   //  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
;;;1612   //  DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;1613   //  DMA_Init(DMA1_Channel1, &DMA_InitStructure);
;;;1614   //  /* Enable DMA1 Channel1 */
;;;1615   //  DMA_Cmd(DMA1_Channel1, ENABLE);
;;;1616       
;;;1617       /// DMA configuration
;;;1618       sDMAInit.DMA_PeripheralBaseAddr =   (u32)BSP_DMA_CPA_POT;
0001aa  489c              LDR      r0,|L1.1052|
0001ac  9001              STR      r0,[sp,#4]
;;;1619       sDMAInit.DMA_MemoryBaseAddr     =   (u32)BSP_POTValue;
0001ae  489c              LDR      r0,|L1.1056|
0001b0  9002              STR      r0,[sp,#8]
;;;1620       sDMAInit.DMA_DIR                =   DMA_DIR_PeripheralSRC;
0001b2  2000              MOVS     r0,#0
0001b4  9003              STR      r0,[sp,#0xc]
;;;1621       sDMAInit.DMA_BufferSize         =   BSP_ADC_VAL_NUM;
0001b6  2008              MOVS     r0,#8
0001b8  9004              STR      r0,[sp,#0x10]
;;;1622       sDMAInit.DMA_PeripheralInc      =   DMA_PeripheralInc_Disable;
0001ba  2000              MOVS     r0,#0
0001bc  9005              STR      r0,[sp,#0x14]
;;;1623       sDMAInit.DMA_MemoryInc          =   DMA_MemoryInc_Enable;
0001be  2080              MOVS     r0,#0x80
0001c0  9006              STR      r0,[sp,#0x18]
;;;1624       sDMAInit.DMA_PeripheralDataSize =   DMA_PeripheralDataSize_Word;
0001c2  0080              LSLS     r0,r0,#2
0001c4  9007              STR      r0,[sp,#0x1c]
;;;1625       sDMAInit.DMA_MemoryDataSize     =   DMA_MemoryDataSize_Word;
0001c6  0080              LSLS     r0,r0,#2
0001c8  9008              STR      r0,[sp,#0x20]
;;;1626       sDMAInit.DMA_Mode               =   DMA_Mode_Circular;
0001ca  2020              MOVS     r0,#0x20
0001cc  9009              STR      r0,[sp,#0x24]
;;;1627       sDMAInit.DMA_Priority           =   DMA_Priority_Low;
0001ce  2000              MOVS     r0,#0
0001d0  900a              STR      r0,[sp,#0x28]
;;;1628       sDMAInit.DMA_M2M                =   DMA_M2M_Disable;
0001d2  900b              STR      r0,[sp,#0x2c]
;;;1629       DMA_Init(BSP_DMA_CHN_POT, &sDMAInit);
0001d4  a901              ADD      r1,sp,#4
0001d6  4893              LDR      r0,|L1.1060|
0001d8  f7fffffe          BL       DMA_Init
;;;1630       
;;;1631       DMA_Cmd(BSP_DMA_CHN_POT, ENABLE);
0001dc  2101              MOVS     r1,#1
0001de  4891              LDR      r0,|L1.1060|
0001e0  f7fffffe          BL       DMA_Cmd
;;;1632       
;;;1633       
;;;1634   //  /* ADC1 configuration ------------------------------------------------------*/
;;;1635   //  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
;;;1636   //  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
;;;1637   //  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;1638   //  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
;;;1639   //  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;1640   //  ADC_InitStructure.ADC_NbrOfChannel = 2;
;;;1641   //  ADC_Init(ADC1, &ADC_InitStructure);
;;;1642   //  /* ADC1 regular channels configuration */ 
;;;1643   //  ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 1, ADC_SampleTime_239Cycles5);    
;;;1644   //  ADC_RegularChannelConfig(ADC1, ADC_Channel_17, 2, ADC_SampleTime_239Cycles5);
;;;1645   //  /* Enable ADC1 DMA */
;;;1646   //  ADC_DMACmd(ADC1, ENABLE);
;;;1647   //
;;;1648   //  /* ADC2 configuration ------------------------------------------------------*/
;;;1649   //  ADC_InitStructure.ADC_Mode = ADC_Mode_RegSimult;
;;;1650   //  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
;;;1651   //  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;1652   //  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
;;;1653   //  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;1654   //  ADC_InitStructure.ADC_NbrOfChannel = 2;
;;;1655   //  ADC_Init(ADC2, &ADC_InitStructure);
;;;1656   //  /* ADC2 regular channels configuration */ 
;;;1657   //  ADC_RegularChannelConfig(ADC2, ADC_Channel_11, 1, ADC_SampleTime_239Cycles5);
;;;1658   //  ADC_RegularChannelConfig(ADC2, ADC_Channel_12, 2, ADC_SampleTime_239Cycles5);
;;;1659   //  /* Enable ADC2 external trigger conversion */
;;;1660   //  ADC_ExternalTrigConvCmd(ADC2, ENABLE);
;;;1661   
;;;1662       /// ADCCLK = PCLK2 / 8, 最慢
;;;1663       RCC_ADCCLKConfig(BSP_ADC_CLK);
0001e4  f44f4040          MOV      r0,#0xc000
0001e8  f7fffffe          BL       RCC_ADCCLKConfig
;;;1664   
;;;1665       /// ADC configuration
;;;1666       sADCInit.ADC_Mode               =   BSP_ADC_MODE;
0001ec  f44f20c0          MOV      r0,#0x60000
0001f0  900c              STR      r0,[sp,#0x30]
;;;1667       sADCInit.ADC_ScanConvMode       =   DISABLE;
0001f2  2000              MOVS     r0,#0
0001f4  f88d0034          STRB     r0,[sp,#0x34]
;;;1668       sADCInit.ADC_ContinuousConvMode =   ENABLE;
0001f8  2001              MOVS     r0,#1
0001fa  f88d0035          STRB     r0,[sp,#0x35]
;;;1669       sADCInit.ADC_ExternalTrigConv   =   ADC_ExternalTrigConv_None;
0001fe  f44f2060          MOV      r0,#0xe0000
000202  900e              STR      r0,[sp,#0x38]
;;;1670       sADCInit.ADC_DataAlign          =   ADC_DataAlign_Right;
000204  2000              MOVS     r0,#0
000206  900f              STR      r0,[sp,#0x3c]
;;;1671       sADCInit.ADC_NbrOfChannel       =   1;
000208  2001              MOVS     r0,#1
00020a  f88d0040          STRB     r0,[sp,#0x40]
;;;1672       ADC_Init(BSP_ADC_POT_ODD , &sADCInit);
00020e  a90c              ADD      r1,sp,#0x30
000210  4882              LDR      r0,|L1.1052|
000212  384c              SUBS     r0,r0,#0x4c
000214  f7fffffe          BL       ADC_Init
;;;1673       ADC_Init(BSP_ADC_POT_EVEN, &sADCInit);
000218  a90c              ADD      r1,sp,#0x30
00021a  4883              LDR      r0,|L1.1064|
00021c  f7fffffe          BL       ADC_Init
;;;1674       
;;;1675       /// ADC regular channels configuration
;;;1676       ADC_RegularChannelConfig(BSP_ADC_POT_ODD , BSP_ADC_CH_POT_ODD , 1, BSP_ADC_SAMPLETIME);
000220  2306              MOVS     r3,#6
000222  2201              MOVS     r2,#1
000224  2108              MOVS     r1,#8
000226  487d              LDR      r0,|L1.1052|
000228  384c              SUBS     r0,r0,#0x4c
00022a  f7fffffe          BL       ADC_RegularChannelConfig
;;;1677       ADC_RegularChannelConfig(BSP_ADC_POT_EVEN, BSP_ADC_CH_POT_EVEN, 1, BSP_ADC_SAMPLETIME);
00022e  2306              MOVS     r3,#6
000230  2201              MOVS     r2,#1
000232  2109              MOVS     r1,#9
000234  487c              LDR      r0,|L1.1064|
000236  f7fffffe          BL       ADC_RegularChannelConfig
;;;1678       
;;;1679       /// Enable ADC1 DMA
;;;1680       ADC_DMACmd(ADC1, ENABLE);
00023a  2101              MOVS     r1,#1
00023c  4877              LDR      r0,|L1.1052|
00023e  384c              SUBS     r0,r0,#0x4c
000240  f7fffffe          BL       ADC_DMACmd
;;;1681       /// Enable ADC2 external trigger conversion
;;;1682       ADC_ExternalTrigConvCmd(ADC2, ENABLE);
000244  2101              MOVS     r1,#1
000246  4878              LDR      r0,|L1.1064|
000248  f7fffffe          BL       ADC_ExternalTrigConvCmd
;;;1683       
;;;1684       
;;;1685       /// Enable ADC
;;;1686       ADC_Cmd(BSP_ADC_POT_ODD , ENABLE);
00024c  2101              MOVS     r1,#1
00024e  4873              LDR      r0,|L1.1052|
000250  384c              SUBS     r0,r0,#0x4c
000252  f7fffffe          BL       ADC_Cmd
;;;1687       ADC_Cmd(BSP_ADC_POT_EVEN, ENABLE);
000256  2101              MOVS     r1,#1
000258  4873              LDR      r0,|L1.1064|
00025a  f7fffffe          BL       ADC_Cmd
;;;1688       
;;;1689       /// Enable ADC reset calibaration register
;;;1690       ADC_ResetCalibration(BSP_ADC_POT_ODD);
00025e  486f              LDR      r0,|L1.1052|
000260  384c              SUBS     r0,r0,#0x4c
000262  f7fffffe          BL       ADC_ResetCalibration
;;;1691       ADC_ResetCalibration(BSP_ADC_POT_EVEN);
000266  4870              LDR      r0,|L1.1064|
000268  f7fffffe          BL       ADC_ResetCalibration
;;;1692       /// Check the end of ADC reset calibration register
;;;1693       while(ADC_GetResetCalibrationStatus(BSP_ADC_POT_ODD));
00026c  bf00              NOP      
                  |L1.622|
00026e  486b              LDR      r0,|L1.1052|
000270  384c              SUBS     r0,r0,#0x4c
000272  f7fffffe          BL       ADC_GetResetCalibrationStatus
000276  2800              CMP      r0,#0
000278  d1f9              BNE      |L1.622|
;;;1694       while(ADC_GetResetCalibrationStatus(BSP_ADC_POT_EVEN));
00027a  bf00              NOP      
                  |L1.636|
00027c  486a              LDR      r0,|L1.1064|
00027e  f7fffffe          BL       ADC_GetResetCalibrationStatus
000282  2800              CMP      r0,#0
000284  d1fa              BNE      |L1.636|
;;;1695       /// Start ADC calibaration */
;;;1696       ADC_StartCalibration(BSP_ADC_POT_ODD);
000286  4865              LDR      r0,|L1.1052|
000288  384c              SUBS     r0,r0,#0x4c
00028a  f7fffffe          BL       ADC_StartCalibration
;;;1697       ADC_StartCalibration(BSP_ADC_POT_EVEN);
00028e  4866              LDR      r0,|L1.1064|
000290  f7fffffe          BL       ADC_StartCalibration
;;;1698       /// Check the end of ADC calibration */
;;;1699       while(ADC_GetCalibrationStatus(BSP_ADC_POT_ODD));
000294  bf00              NOP      
                  |L1.662|
000296  4861              LDR      r0,|L1.1052|
000298  384c              SUBS     r0,r0,#0x4c
00029a  f7fffffe          BL       ADC_GetCalibrationStatus
00029e  2800              CMP      r0,#0
0002a0  d1f9              BNE      |L1.662|
;;;1700       while(ADC_GetCalibrationStatus(BSP_ADC_POT_EVEN));
0002a2  bf00              NOP      
                  |L1.676|
0002a4  4860              LDR      r0,|L1.1064|
0002a6  f7fffffe          BL       ADC_GetCalibrationStatus
0002aa  2800              CMP      r0,#0
0002ac  d1fa              BNE      |L1.676|
;;;1701       
;;;1702       IO_Init(PB00_POT_ODD , GPIO_Mode_AIN);
0002ae  2100              MOVS     r1,#0
0002b0  2010              MOVS     r0,#0x10
0002b2  f7fffffe          BL       IO_Init
;;;1703       IO_Init(PB01_POT_EVEN, GPIO_Mode_AIN);
0002b6  2100              MOVS     r1,#0
0002b8  2011              MOVS     r0,#0x11
0002ba  f7fffffe          BL       IO_Init
;;;1704       
;;;1705       /// Start ADC1 Software Conversion
;;;1706       ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0002be  2101              MOVS     r1,#1
0002c0  4856              LDR      r0,|L1.1052|
0002c2  384c              SUBS     r0,r0,#0x4c
0002c4  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;1707   }
0002c8  b011              ADD      sp,sp,#0x44
0002ca  bd00              POP      {pc}
;;;1708   
                          ENDP

                  BSP_SWI_Init PROC
;;;1531   /// -----------------------------------------------------------------------------------------------------
;;;1532   static  void  BSP_SWI_Init (void)
0002cc  b510              PUSH     {r4,lr}
;;;1533   {
;;;1534   //    /// 断线检测或剪线到位(第一检测)
;;;1535   //    IO_Init(PE07_DJ_CUT_ODD , GPIO_Mode_IPD);
;;;1536   //    IO_Init(PD01_DJ_CUT_EVEN, GPIO_Mode_IPD);
;;;1537   //    /// 下断检(第二检测)
;;;1538   //    IO_Init(PD06_XDJ_ODD , GPIO_Mode_IPD);
;;;1539   //    IO_Init(PD07_XDJ_EVEN, GPIO_Mode_IPD);
;;;1540       u32     i;
;;;1541       
;;;1542       
;;;1543       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
0002ce  2400              MOVS     r4,#0
0002d0  e00a              B        |L1.744|
                  |L1.722|
;;;1544           IO_Init(io_id_swi_fi[i], GPIO_Mode_IPD);        /// 断线检测或剪线到位(第一检测)
0002d2  4956              LDR      r1,|L1.1068|
0002d4  5d08              LDRB     r0,[r1,r4]
0002d6  2128              MOVS     r1,#0x28
0002d8  f7fffffe          BL       IO_Init
;;;1545           IO_Init(io_id_swi_se[i], GPIO_Mode_IPD);        /// 下断检(第二检测)
0002dc  4954              LDR      r1,|L1.1072|
0002de  5d08              LDRB     r0,[r1,r4]
0002e0  2128              MOVS     r1,#0x28
0002e2  f7fffffe          BL       IO_Init
0002e6  1c64              ADDS     r4,r4,#1              ;1543
                  |L1.744|
0002e8  2c02              CMP      r4,#2                 ;1543
0002ea  d3f2              BCC      |L1.722|
;;;1546       }
;;;1547   }
0002ec  bd10              POP      {r4,pc}
;;;1548   
                          ENDP

                  BSP_MOTO_MSet PROC
;;;1186   }
;;;1187   void  BSP_MOTO_MSet (BSP_ID_TypeDef id, BSP_MOT_M123_TypeDef tq)
0002ee  b570              PUSH     {r4-r6,lr}
;;;1188   {
0002f0  4604              MOV      r4,r0
0002f2  460d              MOV      r5,r1
;;;1189   
;;;1190       IO_MultiOutSet(io_id_m1_o[id], 3, (u32)tq);
0002f4  494f              LDR      r1,|L1.1076|
0002f6  5d08              LDRB     r0,[r1,r4]
0002f8  462a              MOV      r2,r5
0002fa  2103              MOVS     r1,#3
0002fc  f7fffffe          BL       IO_MultiOutSet
;;;1191   }
000300  bd70              POP      {r4-r6,pc}
;;;1192   
                          ENDP

                  BSP_MOTO_TQSet PROC
;;;1165   /// -----------------------------------------------------------------------------------------------------
;;;1166   void  BSP_MOTO_TQSet (BSP_ID_TypeDef id, BSP_MOT_TQ_TypeDef tq)
000302  b570              PUSH     {r4-r6,lr}
;;;1167   {
000304  4604              MOV      r4,r0
000306  460d              MOV      r5,r1
;;;1168   //    switch (id) {        
;;;1169   ////    case BSP_ID_ALL:
;;;1170   ////        BSP_MOTO_TQSet(BSP_ID_ODD,  tq);
;;;1171   ////        BSP_MOTO_TQSet(BSP_ID_EVEN, tq);
;;;1172   ////        break;
;;;1173   //        
;;;1174   //    case BSP_ID_ODD:
;;;1175   //        IO_MultiOutSet(PB12_TQ1_O_ODD , 2, (u32)tq);
;;;1176   //        break;
;;;1177   //        
;;;1178   //    case BSP_ID_EVEN:
;;;1179   //        IO_MultiOutSet(PE01_TQ1_O_EVEN, 2, (u32)tq);
;;;1180   //        break;
;;;1181   //
;;;1182   //    default:
;;;1183   //        break;
;;;1184   //    }
;;;1185       IO_MultiOutSet(io_id_tq1_o[id], 2, (u32)tq);
000308  494b              LDR      r1,|L1.1080|
00030a  5d08              LDRB     r0,[r1,r4]
00030c  462a              MOV      r2,r5
00030e  2102              MOVS     r1,#2
000310  f7fffffe          BL       IO_MultiOutSet
;;;1186   }
000314  bd70              POP      {r4-r6,pc}
;;;1187   void  BSP_MOTO_MSet (BSP_ID_TypeDef id, BSP_MOT_M123_TypeDef tq)
                          ENDP

                  BSP_MOTO_ClkSet PROC
;;;1109   /// -----------------------------------------------------------------------------------------------------
;;;1110   void  BSP_MOTO_ClkSet (BSP_ID_TypeDef id, BitAction bit)
000316  b570              PUSH     {r4-r6,lr}
;;;1111   {
000318  4604              MOV      r4,r0
00031a  460d              MOV      r5,r1
;;;1112   //    switch (id) {
;;;1113   ////    case BSP_ID_ALL:
;;;1114   ////        BSP_MOTO_ClkSet(BSP_ID_ODD,  bit);
;;;1115   ////        BSP_MOTO_ClkSet(BSP_ID_EVEN, bit);
;;;1116   ////        break;
;;;1117   //        
;;;1118   //    case BSP_ID_ODD:
;;;1119   //        IO_OutSet(PE15_CLK_O_ODD , (u32)bit);
;;;1120   //        break;
;;;1121   //        
;;;1122   //    case BSP_ID_EVEN:
;;;1123   //        IO_OutSet(PE03_CLK_O_EVEN, (u32)bit);
;;;1124   //        break;
;;;1125   //        
;;;1126   //    default:
;;;1127   //        break;
;;;1128   //    }
;;;1129       IO_OutSet(io_id_clk_o[id], (u32)bit);
00031c  4947              LDR      r1,|L1.1084|
00031e  5d08              LDRB     r0,[r1,r4]
000320  4629              MOV      r1,r5
000322  f7fffffe          BL       IO_OutSet
;;;1130   }
000326  bd70              POP      {r4-r6,pc}
;;;1131   
                          ENDP

                  BSP_MOTO_Init PROC
;;;1004   /// -----------------------------------------------------------------------------------------------------
;;;1005   static  void  BSP_MOTO_Init (void)
000328  b510              PUSH     {r4,lr}
;;;1006   {
;;;1007   //    /// 报错
;;;1008   //    IO_Init(PE13_PRO_O_ODD , GPIO_Mode_IPU);
;;;1009   //    IO_Init(PE05_PRO_O_EVEN, GPIO_Mode_IPU);
;;;1010   //    /// 脉冲
;;;1011   //    IO_Init(PE15_CLK_O_ODD , GPIO_Mode_Out_PP);
;;;1012   //    IO_Init(PE03_CLK_O_EVEN, GPIO_Mode_Out_PP);
;;;1013   //    /// 方向
;;;1014   //    IO_Init(PE12_DIR_O_ODD , GPIO_Mode_Out_PP);
;;;1015   //    IO_Init(PE04_DIR_O_EVEN, GPIO_Mode_Out_PP);
;;;1016   //    /// 电流
;;;1017   //    IO_MultiInit(PB12_TQ1_O_ODD , 2, GPIO_Mode_Out_PP);
;;;1018   //    IO_MultiInit(PE01_TQ1_O_EVEN, 2, GPIO_Mode_Out_PP);
;;;1019       u32     i;
;;;1020       
;;;1021       
;;;1022   #if HARDWARE_VER == 1
;;;1023      // IO_Init(PD08_RESET_O , GPIO_Mode_Out_PP);
;;;1024       IO_Init(PE14_ENABLE_O, GPIO_Mode_Out_PP);
00032a  2110              MOVS     r1,#0x10
00032c  204e              MOVS     r0,#0x4e
00032e  f7fffffe          BL       IO_Init
;;;1025     //  IO_OutSet(PD08_RESET_O, 1);
;;;1026   #endif
;;;1027       
;;;1028       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
000332  2400              MOVS     r4,#0
000334  e027              B        |L1.902|
                  |L1.822|
;;;1029           IO_Init(io_id_pro_o[i], GPIO_Mode_IPU);
000336  4942              LDR      r1,|L1.1088|
000338  5d08              LDRB     r0,[r1,r4]
00033a  2148              MOVS     r1,#0x48
00033c  f7fffffe          BL       IO_Init
;;;1030           IO_Init(io_id_clk_o[i], GPIO_Mode_Out_PP);
000340  493e              LDR      r1,|L1.1084|
000342  5d08              LDRB     r0,[r1,r4]
000344  2110              MOVS     r1,#0x10
000346  f7fffffe          BL       IO_Init
;;;1031           BSP_MOTO_ClkSet((BSP_ID_TypeDef)i, Bit_RESET);
00034a  2100              MOVS     r1,#0
00034c  b2e0              UXTB     r0,r4
00034e  f7fffffe          BL       BSP_MOTO_ClkSet
;;;1032           IO_Init(io_id_dir_o[i], GPIO_Mode_Out_PP);
000352  493c              LDR      r1,|L1.1092|
000354  5d08              LDRB     r0,[r1,r4]
000356  2110              MOVS     r1,#0x10
000358  f7fffffe          BL       IO_Init
;;;1033   
;;;1034   	    IO_MultiInit(io_id_tq1_o[i], 2, GPIO_Mode_Out_PP);
00035c  4936              LDR      r1,|L1.1080|
00035e  5d08              LDRB     r0,[r1,r4]
000360  2210              MOVS     r2,#0x10
000362  2102              MOVS     r1,#2
000364  f7fffffe          BL       IO_MultiInit
;;;1035   		BSP_MOTO_TQSet((BSP_ID_TypeDef)i, BSP_MOT_TQ_50);
000368  2102              MOVS     r1,#2
00036a  b2e0              UXTB     r0,r4
00036c  f7fffffe          BL       BSP_MOTO_TQSet
;;;1036   		IO_MultiInit(io_id_m1_o[i], 3, GPIO_Mode_Out_PP);
000370  4930              LDR      r1,|L1.1076|
000372  5d08              LDRB     r0,[r1,r4]
000374  2210              MOVS     r2,#0x10
000376  2103              MOVS     r1,#3
000378  f7fffffe          BL       IO_MultiInit
;;;1037   		BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_5);
00037c  2105              MOVS     r1,#5
00037e  b2e0              UXTB     r0,r4
000380  f7fffffe          BL       BSP_MOTO_MSet
000384  1c64              ADDS     r4,r4,#1              ;1028
                  |L1.902|
000386  2c02              CMP      r4,#2                 ;1028
000388  d3d5              BCC      |L1.822|
;;;1038   
;;;1039   
;;;1040   
;;;1041       }
;;;1042       
;;;1043   #if HARDWARE_VER == 1
;;;1044       BSP_TM8M_Delay(BSP_TMR_8M_CLK * 1 / 1000000);       /// delay 2/1000000S (2us)
00038a  2008              MOVS     r0,#8
00038c  f7fffffe          BL       BSP_TM8M_Delay
;;;1045       IO_OutSet(PE14_ENABLE_O, 1);
000390  2101              MOVS     r1,#1
000392  204e              MOVS     r0,#0x4e
000394  f7fffffe          BL       IO_OutSet
;;;1046   #endif
;;;1047   }
000398  bd10              POP      {r4,pc}
;;;1048   static  void  BSP_MOTO_Sitch_Init (void)
                          ENDP

                  BSP_SOL_Set PROC
;;;2230   /// tmr ?????????, 0 ???????    ???18.2??
;;;2231   void  BSP_SOL_Set (BSP_ID_TypeDef id, BSP_SOL_TypeDef st, u16 tmr)
00039a  b570              PUSH     {r4-r6,lr}
;;;2232   {
00039c  4604              MOV      r4,r0
00039e  460e              MOV      r6,r1
0003a0  4615              MOV      r5,r2
;;;2233   	Tick_cnt=OS_TICKS_PER_SEC/2;
0003a2  f44f70fa          MOV      r0,#0x1f4
0003a6  4928              LDR      r1,|L1.1096|
0003a8  6008              STR      r0,[r1,#0]  ; Tick_cnt
;;;2234       IO_OutSet(io_id_sol[id], (u32)st);
0003aa  4928              LDR      r1,|L1.1100|
0003ac  5d08              LDRB     r0,[r1,r4]
0003ae  4631              MOV      r1,r6
0003b0  f7fffffe          BL       IO_OutSet
;;;2235       BSP_TimerSol[id]    =   tmr;
0003b4  4826              LDR      r0,|L1.1104|
0003b6  f8205014          STRH     r5,[r0,r4,LSL #1]
;;;2236   }
0003ba  bd70              POP      {r4-r6,pc}
;;;2237   
                          ENDP

                  BSP_SOL_Init PROC
;;;2216   
;;;2217   static  void  BSP_SOL_Init (void)
0003bc  b510              PUSH     {r4,lr}
;;;2218   {
;;;2219       u32     i;
;;;2220       
;;;2221       
;;;2222       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
0003be  2400              MOVS     r4,#0
0003c0  e00a              B        |L1.984|
                  |L1.962|
;;;2223           IO_Init(io_id_sol[i], GPIO_Mode_Out_PP);
0003c2  4922              LDR      r1,|L1.1100|
0003c4  5d08              LDRB     r0,[r1,r4]
0003c6  2110              MOVS     r1,#0x10
0003c8  f7fffffe          BL       IO_Init
;;;2224           BSP_SOL_Set((BSP_ID_TypeDef)i, BSP_SOL_OFF, 0);
0003cc  2200              MOVS     r2,#0
0003ce  4611              MOV      r1,r2
0003d0  b2e0              UXTB     r0,r4
0003d2  f7fffffe          BL       BSP_SOL_Set
0003d6  1c64              ADDS     r4,r4,#1              ;2222
                  |L1.984|
0003d8  2c02              CMP      r4,#2                 ;2222
0003da  d3f2              BCC      |L1.962|
;;;2225       }
;;;2226   	IO_Init(io_id_qf[0], GPIO_Mode_Out_PP);
0003dc  491d              LDR      r1,|L1.1108|
0003de  7808              LDRB     r0,[r1,#0]  ; io_id_qf
0003e0  2110              MOVS     r1,#0x10
0003e2  f7fffffe          BL       IO_Init
;;;2227       BSP_SOL_Set((BSP_ID_TypeDef)0, BSP_SOL_OFF, 0);
0003e6  2200              MOVS     r2,#0
0003e8  4611              MOV      r1,r2
0003ea  4610              MOV      r0,r2
0003ec  f7fffffe          BL       BSP_SOL_Set
;;;2228   }
0003f0  bd10              POP      {r4,pc}
0003f2  0000              DCW      0x0000
                  |L1.1012|
                          DCD      0x02040007
                  |L1.1016|
                          DCD      SystemFrequency
                  |L1.1020|
                          DCD      0x007a1200
                  |L1.1024|
                          DCD      0x40012c00
                  |L1.1028|
                          DCD      0x40012c24
                  |L1.1032|
                          DCD      BSP_TMR_CNT_PRESCALER
                  |L1.1036|
                          DCD      0x40000400
                  |L1.1040|
                          DCD      0x40000424
                  |L1.1044|
                          DCD      BSP_Is924
                  |L1.1048|
                          DCD      io_id_sqn
                  |L1.1052|
                          DCD      0x4001244c
                  |L1.1056|
                          DCD      BSP_POTValue
                  |L1.1060|
                          DCD      0x40020008
                  |L1.1064|
                          DCD      0x40012800
                  |L1.1068|
                          DCD      io_id_swi_fi
                  |L1.1072|
                          DCD      io_id_swi_se
                  |L1.1076|
                          DCD      io_id_m1_o
                  |L1.1080|
                          DCD      io_id_tq1_o
                  |L1.1084|
                          DCD      io_id_clk_o
                  |L1.1088|
                          DCD      io_id_pro_o
                  |L1.1092|
                          DCD      io_id_dir_o
                  |L1.1096|
                          DCD      Tick_cnt
                  |L1.1100|
                          DCD      io_id_sol
                  |L1.1104|
                          DCD      BSP_TimerSol
                  |L1.1108|
                          DCD      io_id_qf
                          ENDP

                  BSP_HD_LedSet PROC
;;;786    /// -----------------------------------------------------------------------------------------------------
;;;787    void  BSP_HD_LedSet (BSP_ID_TypeDef id, BSP_LED_TypeDef red, BSP_LED_TypeDef green)
000458  b570              PUSH     {r4-r6,lr}
;;;788    {
00045a  4604              MOV      r4,r0
00045c  460e              MOV      r6,r1
00045e  4615              MOV      r5,r2
;;;789    //    switch (id) {
;;;790    ////    case BSP_ID_ALL:
;;;791    ////        BSP_HD_LedSet(BSP_ID_ODD,  red, green);
;;;792    ////        BSP_HD_LedSet(BSP_ID_EVEN, red, green);
;;;793    ////        break;
;;;794    //        
;;;795    //    case BSP_ID_ODD:
;;;796    //        IO_OutSet(PE09_HD_R_ODD, (u32)red);
;;;797    //        IO_OutSet(PE11_HD_G_ODD, (u32)green);
;;;798    //        break;
;;;799    //        
;;;800    //    case BSP_ID_EVEN:
;;;801    //        IO_OutSet(PC11_HD_R_EVEN, (u32)red);
;;;802    //        IO_OutSet(PC12_HD_G_EVEN, (u32)green);
;;;803    //        break;
;;;804    //        
;;;805    //    default:
;;;806    //        break;
;;;807    //    }
;;;808        IO_OutSet(io_id_hd_r[id], (u32)red);
000460  49f8              LDR      r1,|L1.2116|
000462  5d08              LDRB     r0,[r1,r4]
000464  4631              MOV      r1,r6
000466  f7fffffe          BL       IO_OutSet
;;;809        IO_OutSet(io_id_hd_g[id], (u32)green);
00046a  49f7              LDR      r1,|L1.2120|
00046c  5d08              LDRB     r0,[r1,r4]
00046e  4629              MOV      r1,r5
000470  f7fffffe          BL       IO_OutSet
;;;810    }
000474  bd70              POP      {r4-r6,pc}
;;;811    
                          ENDP

                  BSP_HD_Init PROC
;;;727    /// -----------------------------------------------------------------------------------------------------
;;;728    static  void  BSP_HD_Init (void)
000476  b510              PUSH     {r4,lr}
;;;729    {    
;;;730    //    /// 奇偶头开关IO初始化
;;;731    //    IO_Init(PE08_HD_UP_ODD   , GPIO_Mode_IPU);
;;;732    //    IO_Init(PE10_HD_DOWN_ODD , GPIO_Mode_IPU);
;;;733    //    IO_Init(PC10_HD_UP_EVEN  , GPIO_Mode_IPU);
;;;734    //    IO_Init(PD00_HD_DOWN_EVEN, GPIO_Mode_IPU);
;;;735    //    
;;;736    //    /// 奇偶头红绿灯IO初始化
;;;737    //    IO_Init(PE09_HD_R_ODD , GPIO_Mode_Out_PP);
;;;738    //    IO_Init(PE11_HD_G_ODD , GPIO_Mode_Out_PP);
;;;739    //    IO_Init(PC11_HD_R_EVEN, GPIO_Mode_Out_PP);
;;;740    //    IO_Init(PC12_HD_G_EVEN, GPIO_Mode_Out_PP);
;;;741        u32     i;
;;;742        
;;;743        
;;;744        for (i = 0; i < BSP_DEVICE_ID_N; i++) {
000478  2400              MOVS     r4,#0
00047a  e019              B        |L1.1200|
                  |L1.1148|
;;;745            /// 开关IO初始化
;;;746            IO_Init(io_id_hd_up[i], GPIO_Mode_IPU);
00047c  49f3              LDR      r1,|L1.2124|
00047e  5d08              LDRB     r0,[r1,r4]
000480  2148              MOVS     r1,#0x48
000482  f7fffffe          BL       IO_Init
;;;747            IO_Init(io_id_hd_dn[i], GPIO_Mode_IPU);
000486  49f2              LDR      r1,|L1.2128|
000488  5d08              LDRB     r0,[r1,r4]
00048a  2148              MOVS     r1,#0x48
00048c  f7fffffe          BL       IO_Init
;;;748            /// 红绿灯IO初始化
;;;749            IO_Init(io_id_hd_r[i], GPIO_Mode_Out_PP);
000490  49ec              LDR      r1,|L1.2116|
000492  5d08              LDRB     r0,[r1,r4]
000494  2110              MOVS     r1,#0x10
000496  f7fffffe          BL       IO_Init
;;;750            IO_Init(io_id_hd_g[i], GPIO_Mode_Out_PP);
00049a  49eb              LDR      r1,|L1.2120|
00049c  5d08              LDRB     r0,[r1,r4]
00049e  2110              MOVS     r1,#0x10
0004a0  f7fffffe          BL       IO_Init
;;;751            BSP_HD_LedSet((BSP_ID_TypeDef)i, BSP_LED_OFF, BSP_LED_OFF);
0004a4  2201              MOVS     r2,#1
0004a6  4611              MOV      r1,r2
0004a8  b2e0              UXTB     r0,r4
0004aa  f7fffffe          BL       BSP_HD_LedSet
0004ae  1c64              ADDS     r4,r4,#1              ;744
                  |L1.1200|
0004b0  2c02              CMP      r4,#2                 ;744
0004b2  d3e3              BCC      |L1.1148|
;;;752        }
;;;753    }
0004b4  bd10              POP      {r4,pc}
;;;754    
                          ENDP

                  BSP_LED_Set PROC
;;;663    /// -----------------------------------------------------------------------------------------------------
;;;664    void  BSP_LED_Set (u8 led, BSP_LED_TypeDef st)
0004b6  b570              PUSH     {r4-r6,lr}
;;;665    {
0004b8  4604              MOV      r4,r0
0004ba  460e              MOV      r6,r1
;;;666    //    switch (led) {
;;;667    //    case 0:
;;;668    //        BSP_LED_Set(1, st);
;;;669    //        BSP_LED_Set(2, st);
;;;670    //        break;
;;;671    //        
;;;672    //    case 1:
;;;673    //        IO_OutSet(PB05_LED1, (u32)st);
;;;674    //        break;
;;;675    //        
;;;676    //    case 2:
;;;677    //        IO_OutSet(PB09_LED2, (u32)st);
;;;678    //        break;
;;;679    //        
;;;680    //    default:
;;;681    //        break;
;;;682    //    }
;;;683        IO_OutSet(io_id_led[led % BSP_LED_ID_N],(u32)st);
0004bc  4625              MOV      r5,r4
0004be  eb0471d4          ADD      r1,r4,r4,LSR #31
0004c2  1049              ASRS     r1,r1,#1
0004c4  eba40141          SUB      r1,r4,r1,LSL #1
0004c8  4ae2              LDR      r2,|L1.2132|
0004ca  5c50              LDRB     r0,[r2,r1]
0004cc  4631              MOV      r1,r6
0004ce  f7fffffe          BL       IO_OutSet
;;;684    }
0004d2  bd70              POP      {r4-r6,pc}
;;;685    
                          ENDP

                  BSP_LED_Init PROC
;;;644    /// -----------------------------------------------------------------------------------------------------
;;;645    static  void  BSP_LED_Init (void)
0004d4  b510              PUSH     {r4,lr}
;;;646    {
;;;647        u32     i;
;;;648        
;;;649        
;;;650        for (i = 0; i < BSP_LED_ID_N; i++) {
0004d6  2400              MOVS     r4,#0
0004d8  e009              B        |L1.1262|
                  |L1.1242|
;;;651            IO_Init(io_id_led[i], GPIO_Mode_Out_OD);
0004da  49de              LDR      r1,|L1.2132|
0004dc  5d08              LDRB     r0,[r1,r4]
0004de  2114              MOVS     r1,#0x14
0004e0  f7fffffe          BL       IO_Init
;;;652            BSP_LED_Set(i, BSP_LED_OFF);
0004e4  2101              MOVS     r1,#1
0004e6  b2e0              UXTB     r0,r4
0004e8  f7fffffe          BL       BSP_LED_Set
0004ec  1c64              ADDS     r4,r4,#1              ;650
                  |L1.1262|
0004ee  2c02              CMP      r4,#2                 ;650
0004f0  d3f3              BCC      |L1.1242|
;;;653        }
;;;654    }
0004f2  bd10              POP      {r4,pc}
;;;655    
                          ENDP

                  BSP_ENC_IndexEn PROC
;;;1459   
;;;1460   static  void  BSP_ENC_IndexEn (void)
0004f4  b51c              PUSH     {r2-r4,lr}
;;;1461   {
;;;1462       EXTI_InitTypeDef    sEXTIInit;
;;;1463       
;;;1464       
;;;1465       GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource2);
0004f6  2102              MOVS     r1,#2
0004f8  2000              MOVS     r0,#0
0004fa  f7fffffe          BL       GPIO_EXTILineConfig
;;;1466       GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource8);
0004fe  2108              MOVS     r1,#8
000500  2001              MOVS     r0,#1
000502  f7fffffe          BL       GPIO_EXTILineConfig
;;;1467       
;;;1468       sEXTIInit.EXTI_Line     =   BSP_EXIT_LINE_I_E_ODD;
000506  2004              MOVS     r0,#4
000508  9000              STR      r0,[sp,#0]
;;;1469       sEXTIInit.EXTI_Mode     =   EXTI_Mode_Interrupt;
00050a  2000              MOVS     r0,#0
00050c  f88d0004          STRB     r0,[sp,#4]
;;;1470       sEXTIInit.EXTI_Trigger  =   EXTI_Trigger_Falling;
000510  200c              MOVS     r0,#0xc
000512  f88d0005          STRB     r0,[sp,#5]
;;;1471       sEXTIInit.EXTI_LineCmd  =   ENABLE;
000516  2001              MOVS     r0,#1
000518  f88d0006          STRB     r0,[sp,#6]
;;;1472       EXTI_Init(&sEXTIInit);
00051c  4668              MOV      r0,sp
00051e  f7fffffe          BL       EXTI_Init
;;;1473       sEXTIInit.EXTI_Line     =   BSP_EXIT_LINE_I_E_EVEN;
000522  f44f7080          MOV      r0,#0x100
000526  9000              STR      r0,[sp,#0]
;;;1474       sEXTIInit.EXTI_Mode     =   EXTI_Mode_Interrupt;
000528  2000              MOVS     r0,#0
00052a  f88d0004          STRB     r0,[sp,#4]
;;;1475       sEXTIInit.EXTI_Trigger  =   EXTI_Trigger_Falling;
00052e  200c              MOVS     r0,#0xc
000530  f88d0005          STRB     r0,[sp,#5]
;;;1476       sEXTIInit.EXTI_LineCmd  =   ENABLE;
000534  2001              MOVS     r0,#1
000536  f88d0006          STRB     r0,[sp,#6]
;;;1477       EXTI_Init(&sEXTIInit);
00053a  4668              MOV      r0,sp
00053c  f7fffffe          BL       EXTI_Init
;;;1478   }
000540  bd1c              POP      {r2-r4,pc}
;;;1479   
                          ENDP

                  BSP_ENC_Init PROC
;;;1395   /// -----------------------------------------------------------------------------------------------------
;;;1396   static  void  BSP_ENC_Init (void)
000542  b510              PUSH     {r4,lr}
;;;1397   {
000544  b086              SUB      sp,sp,#0x18
;;;1398       TIM_TimeBaseInitTypeDef     sTimeBaseInit;
;;;1399       TIM_ICInitTypeDef           sTimeICInit;
;;;1400       u32                         i;
;;;1401       
;;;1402       static  const  IO_ID_TypeDef  io_id_enc_a[BSP_DEVICE_ID_N]  =   {PA00_ENC_A_ODD, PB06_ENC_A_EVEN};
;;;1403       static  const  IO_ID_TypeDef  io_id_enc_i[BSP_DEVICE_ID_N]  =   {PA02_ENC_I_ODD, PB08_ENC_I_EVEN};
;;;1404       
;;;1405       
;;;1406       /// Timer configuration in Encoder mode
;;;1407       /// Time Base configuration
;;;1408       sTimeBaseInit.TIM_Prescaler     =   0;                      /// No prescaling
000546  2000              MOVS     r0,#0
000548  f8ad000c          STRH     r0,[sp,#0xc]
;;;1409       sTimeBaseInit.TIM_CounterMode   =   TIM_CounterMode_Up;
00054c  f8ad000e          STRH     r0,[sp,#0xe]
;;;1410       sTimeBaseInit.TIM_Period        =   BSP_ENC_N_T_PR - 1;
000550  f240603f          MOV      r0,#0x63f
000554  f8ad0010          STRH     r0,[sp,#0x10]
;;;1411       sTimeBaseInit.TIM_ClockDivision =   TIM_CKD_DIV1;
000558  2000              MOVS     r0,#0
00055a  f8ad0012          STRH     r0,[sp,#0x12]
;;;1412   //    TIM_TimeBaseInit(BSP_TMR_E_ODD , &sTimeBaseInit);
;;;1413   //    TIM_TimeBaseInit(BSP_TMR_E_EVEN, &sTimeBaseInit);
;;;1414       
;;;1415   //    TIM_EncoderInterfaceConfig(BSP_TMR_E_ODD , TIM_EncoderMode_TI12,
;;;1416   //                               TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;1417   //    TIM_EncoderInterfaceConfig(BSP_TMR_E_EVEN, TIM_EncoderMode_TI12,
;;;1418   //                               TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;1419       
;;;1420       TIM_ICStructInit(&sTimeICInit);
00055e  4668              MOV      r0,sp
000560  f7fffffe          BL       TIM_ICStructInit
;;;1421       /// 按步距电机最快速度为1200rpm, 则4倍频脉冲翻转时间为60*1000*1000/1200/1600=31.25us
;;;1422       /// 6 表示: 4 * 6 / 72  =   0.33us滤波 @72M & TIM_CKD_DIV1
;;;1423       /// 9 表示: 8 * 8 / 72  =   0.88us滤波 @72M & TIM_CKD_DIV1
;;;1424       sTimeICInit.TIM_ICFilter        =   6;
000564  2006              MOVS     r0,#6
000566  f8ad0008          STRH     r0,[sp,#8]
;;;1425   //    TIM_ICInit(BSP_TMR_E_ODD , &sTimeICInit);
;;;1426   //    TIM_ICInit(BSP_TMR_E_EVEN, &sTimeICInit);
;;;1427       
;;;1428       /// 定时器IO初始化 (不用重映射)
;;;1429   //    IO_MultiInit(PA00_ENC_A_ODD , 2, GPIO_Mode_IN_FLOATING);
;;;1430   //    IO_MultiInit(PB06_ENC_A_EVEN, 2, GPIO_Mode_IN_FLOATING);
;;;1431   //    
;;;1432   //    IO_Init(PA02_ENC_I_ODD , GPIO_Mode_IN_FLOATING);
;;;1433   //    IO_Init(PB08_ENC_I_EVEN, GPIO_Mode_IN_FLOATING);
;;;1434       
;;;1435   //    TIM_Cmd(BSP_TMR_E_ODD , ENABLE);
;;;1436   //    TIM_Cmd(BSP_TMR_E_EVEN, ENABLE);
;;;1437       
;;;1438       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
00056a  2400              MOVS     r4,#0
00056c  e02c              B        |L1.1480|
                  |L1.1390|
;;;1439           TIM_TimeBaseInit(tim_id_encoder[i], &sTimeBaseInit);
00056e  49ba              LDR      r1,|L1.2136|
000570  f8510024          LDR      r0,[r1,r4,LSL #2]
000574  a903              ADD      r1,sp,#0xc
000576  f7fffffe          BL       TIM_TimeBaseInit
;;;1440           
;;;1441   /// 使编码器方向与数据方向定义一致. 环轴与钩针顺时针转动(从上向下看)为数据增加方向, 
;;;1442   /// 由于齿轮传动, 电机轴逆时针转动(从轴端看)为数据增加方向, 此方向旋转应使编码器数值增大
;;;1443   /// 该设置与接线方式, 电路等硬件情况相关. 如果反向, 可调整一个信号的极性.
;;;1444           TIM_EncoderInterfaceConfig(tim_id_encoder[i], TIM_EncoderMode_TI12,
00057a  49b7              LDR      r1,|L1.2136|
00057c  f8510024          LDR      r0,[r1,r4,LSL #2]
000580  2302              MOVS     r3,#2
000582  2200              MOVS     r2,#0
000584  2103              MOVS     r1,#3
000586  f7fffffe          BL       TIM_EncoderInterfaceConfig
;;;1445   /// 一般的, AB任意一项电平反相, 即可改变计数方向.
;;;1446   /// 实际上, A反相(函数参数3修改), 计数方向没有变化, 而B(参数4)反相可改变计数方向.
;;;1447   /// !!! 芯片可能有bug, 或文档没有更新 !!!
;;;1448   //                                   TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;1449                                      TIM_ICPolarity_Rising, TIM_ICPolarity_Falling);      /// 按目前情况设置
;;;1450           TIM_ICInit(tim_id_encoder[i], &sTimeICInit);
00058a  49b3              LDR      r1,|L1.2136|
00058c  f8510024          LDR      r0,[r1,r4,LSL #2]
000590  4669              MOV      r1,sp
000592  f7fffffe          BL       TIM_ICInit
;;;1451           IO_MultiInit(io_id_enc_a[i], 2, GPIO_Mode_IN_FLOATING);
000596  49b1              LDR      r1,|L1.2140|
000598  5d08              LDRB     r0,[r1,r4]
00059a  2204              MOVS     r2,#4
00059c  2102              MOVS     r1,#2
00059e  f7fffffe          BL       IO_MultiInit
;;;1452           IO_Init(io_id_enc_i[i], GPIO_Mode_IN_FLOATING);
0005a2  49af              LDR      r1,|L1.2144|
0005a4  5d08              LDRB     r0,[r1,r4]
0005a6  2104              MOVS     r1,#4
0005a8  f7fffffe          BL       IO_Init
;;;1453           
;;;1454           TIM_ITConfig(tim_id_encoder[i], TIM_IT_Update, ENABLE);         /// 打开更新中断
0005ac  49aa              LDR      r1,|L1.2136|
0005ae  f8510024          LDR      r0,[r1,r4,LSL #2]
0005b2  2201              MOVS     r2,#1
0005b4  4611              MOV      r1,r2
0005b6  f7fffffe          BL       TIM_ITConfig
;;;1455           
;;;1456           TIM_Cmd(tim_id_encoder[i], ENABLE);
0005ba  49a7              LDR      r1,|L1.2136|
0005bc  f8510024          LDR      r0,[r1,r4,LSL #2]
0005c0  2101              MOVS     r1,#1
0005c2  f7fffffe          BL       TIM_Cmd
0005c6  1c64              ADDS     r4,r4,#1              ;1438
                  |L1.1480|
0005c8  2c02              CMP      r4,#2                 ;1438
0005ca  d3d0              BCC      |L1.1390|
;;;1457       }
;;;1458   }
0005cc  b006              ADD      sp,sp,#0x18
0005ce  bd10              POP      {r4,pc}
;;;1459   
                          ENDP

                  BSP_DIP_Get PROC
;;;938    /// -----------------------------------------------------------------------------------------------------
;;;939    u32  BSP_DIP_Get (void)
0005d0  b510              PUSH     {r4,lr}
;;;940    {
;;;941        u32     tmp;
;;;942        
;;;943        
;;;944        tmp     =   IO_MultiInGet(PC00_DIP1, 4);
0005d2  2104              MOVS     r1,#4
0005d4  2020              MOVS     r0,#0x20
0005d6  f7fffffe          BL       IO_MultiInGet
0005da  4604              MOV      r4,r0
;;;945        tmp    |=   IO_MultiInGet(PA04_DIP5, 4) << 4;
0005dc  2104              MOVS     r1,#4
0005de  4608              MOV      r0,r1
0005e0  f7fffffe          BL       IO_MultiInGet
0005e4  ea441400          ORR      r4,r4,r0,LSL #4
;;;946        tmp    |=   IO_MultiInGet(PC04_DIP9, 2) << 8;
0005e8  2102              MOVS     r1,#2
0005ea  2024              MOVS     r0,#0x24
0005ec  f7fffffe          BL       IO_MultiInGet
0005f0  ea442400          ORR      r4,r4,r0,LSL #8
;;;947        
;;;948        return  tmp & ((1 << BSP_DIP_N_BITS) - 1);
0005f4  f3c40009          UBFX     r0,r4,#0,#10
;;;949    }
0005f8  bd10              POP      {r4,pc}
;;;950    
                          ENDP

                  BSP_DIP_Init PROC
;;;819    /// -----------------------------------------------------------------------------------------------------
;;;820    static  void  BSP_DIP_Init (void)
0005fa  e92d41f0          PUSH     {r4-r8,lr}
;;;821    {
;;;822        u32     i;
;;;823        u32     dip;
;;;824        u8     Addr_Tmp,Addr_Tmp2;
;;;825        
;;;826        IO_MultiInit(PC00_DIP1, 6, GPIO_Mode_IPU);          /// DIP1~4, DIP9~10
0005fe  2248              MOVS     r2,#0x48
000600  2106              MOVS     r1,#6
000602  2020              MOVS     r0,#0x20
000604  f7fffffe          BL       IO_MultiInit
;;;827        IO_MultiInit(PA04_DIP5, 4, GPIO_Mode_IPU);          /// DIP5~8
000608  2248              MOVS     r2,#0x48
00060a  2104              MOVS     r1,#4
00060c  4608              MOV      r0,r1
00060e  f7fffffe          BL       IO_MultiInit
;;;828        
;;;829        for (i = 100; i != 0; i--) {                        /// max scan times is 100
000612  2664              MOVS     r6,#0x64
000614  e07b              B        |L1.1806|
                  |L1.1558|
;;;830            dip                 =   BSP_DIP_Get();
000616  f7fffffe          BL       BSP_DIP_Get
00061a  4604              MOV      r4,r0
;;;831            if ((dip >> 3) & 0x01) 
00061c  f3c400c0          UBFX     r0,r4,#3,#1
000620  b118              CBZ      r0,|L1.1578|
;;;832    		{
;;;833                BSP_DIP_RedIsSpkl   =   FALSE;
000622  2000              MOVS     r0,#0
000624  498f              LDR      r1,|L1.2148|
000626  7008              STRB     r0,[r1,#0]
000628  e002              B        |L1.1584|
                  |L1.1578|
;;;834            } 
;;;835    		else 
;;;836    		{
;;;837                BSP_DIP_RedIsSpkl   =   TRUE;
00062a  2001              MOVS     r0,#1
00062c  498d              LDR      r1,|L1.2148|
00062e  7008              STRB     r0,[r1,#0]
                  |L1.1584|
;;;838            } 
;;;839            BSP_DIP_TQ          =   (BSP_MOT_TQ_TypeDef)(dip & 0x03);
000630  f0040003          AND      r0,r4,#3
000634  498c              LDR      r1,|L1.2152|
000636  7008              STRB     r0,[r1,#0]
;;;840            BSP_DIP_BDFunc      =   (BSP_DIP_BD_FUNC_TypeDef)((dip >> 4) & 0x01);
000638  f3c41000          UBFX     r0,r4,#4,#1
00063c  498b              LDR      r1,|L1.2156|
00063e  7008              STRB     r0,[r1,#0]
;;;841            Addr_Tmp			=   (dip >> 5) & 0x1;//保留6、7、8、9、10，这里6是最低位，应该变成最高位
000640  f3c41540          UBFX     r5,r4,#5,#1
;;;842    		if(Addr_Tmp==1)
000644  2d01              CMP      r5,#1
000646  d154              BNE      |L1.1778|
;;;843    		{
;;;844    			Addr_Tmp2=Addr_Tmp<<4;
000648  0728              LSLS     r0,r5,#28
00064a  0e07              LSRS     r7,r0,#24
;;;845    			Addr_Tmp=Addr_Tmp2+((dip >> 6) & 0x0F);
00064c  f3c41083          UBFX     r0,r4,#6,#4
000650  4438              ADD      r0,r0,r7
000652  b2c5              UXTB     r5,r0
;;;846    		switch(Addr_Tmp)
000654  f1a50010          SUB      r0,r5,#0x10
000658  280f              CMP      r0,#0xf
00065a  d245              BCS      |L1.1768|
00065c  e8dff000          TBB      [pc,r0]
000660  080c1014          DCB      0x08,0x0c,0x10,0x14
000664  181c2024          DCB      0x18,0x1c,0x20,0x24
000668  282c3034          DCB      0x28,0x2c,0x30,0x34
00066c  383c4000          DCB      0x38,0x3c,0x40,0x00
;;;847    		{
;;;848    		/*	case 0x00:
;;;849    				 BSP_DIP_9511Addr =  0x4F;
;;;850    			break; */
;;;851    			case 0x10:
;;;852    				BSP_DIP_9511Addr =   0x71;
000670  2071              MOVS     r0,#0x71
000672  497f              LDR      r1,|L1.2160|
000674  7008              STRB     r0,[r1,#0]
;;;853    			break;
000676  e03b              B        |L1.1776|
;;;854    			case 0x11:
;;;855    				 BSP_DIP_9511Addr =   0x72;
000678  2072              MOVS     r0,#0x72
00067a  497d              LDR      r1,|L1.2160|
00067c  7008              STRB     r0,[r1,#0]
;;;856    			break;
00067e  e037              B        |L1.1776|
;;;857    			case 0x12:
;;;858    				BSP_DIP_9511Addr =   0x73;
000680  2073              MOVS     r0,#0x73
000682  497b              LDR      r1,|L1.2160|
000684  7008              STRB     r0,[r1,#0]
;;;859    			break;
000686  e033              B        |L1.1776|
;;;860    			case 0x13:
;;;861    				BSP_DIP_9511Addr =   0x74;
000688  2074              MOVS     r0,#0x74
00068a  4979              LDR      r1,|L1.2160|
00068c  7008              STRB     r0,[r1,#0]
;;;862    			break;
00068e  e02f              B        |L1.1776|
;;;863    			case 0x14:
;;;864    				 BSP_DIP_9511Addr =   0x75;
000690  2075              MOVS     r0,#0x75
000692  4977              LDR      r1,|L1.2160|
000694  7008              STRB     r0,[r1,#0]
;;;865    			break;
000696  e02b              B        |L1.1776|
;;;866    			case 0x15:
;;;867    				BSP_DIP_9511Addr =   0x76;
000698  2076              MOVS     r0,#0x76
00069a  4975              LDR      r1,|L1.2160|
00069c  7008              STRB     r0,[r1,#0]
;;;868    			break;
00069e  e027              B        |L1.1776|
;;;869    			case 0x16:
;;;870    				BSP_DIP_9511Addr =   0x77;
0006a0  2077              MOVS     r0,#0x77
0006a2  4973              LDR      r1,|L1.2160|
0006a4  7008              STRB     r0,[r1,#0]
;;;871    			break;
0006a6  e023              B        |L1.1776|
;;;872    			case 0x17:
;;;873    				 BSP_DIP_9511Addr =   0x78;
0006a8  2078              MOVS     r0,#0x78
0006aa  4971              LDR      r1,|L1.2160|
0006ac  7008              STRB     r0,[r1,#0]
;;;874    			break;
0006ae  e01f              B        |L1.1776|
;;;875    			case 0x18:
;;;876    				BSP_DIP_9511Addr =   0x79;
0006b0  2079              MOVS     r0,#0x79
0006b2  496f              LDR      r1,|L1.2160|
0006b4  7008              STRB     r0,[r1,#0]
;;;877    			break;
0006b6  e01b              B        |L1.1776|
;;;878    			case 0x19:
;;;879    				BSP_DIP_9511Addr =   0x7A;
0006b8  207a              MOVS     r0,#0x7a
0006ba  496d              LDR      r1,|L1.2160|
0006bc  7008              STRB     r0,[r1,#0]
;;;880    			break;
0006be  e017              B        |L1.1776|
;;;881    			case 0x1A:
;;;882    				 BSP_DIP_9511Addr =   0x7B;
0006c0  207b              MOVS     r0,#0x7b
0006c2  496b              LDR      r1,|L1.2160|
0006c4  7008              STRB     r0,[r1,#0]
;;;883    			break;
0006c6  e013              B        |L1.1776|
;;;884    			case 0x1B:
;;;885    				BSP_DIP_9511Addr =   0x7C;
0006c8  207c              MOVS     r0,#0x7c
0006ca  4969              LDR      r1,|L1.2160|
0006cc  7008              STRB     r0,[r1,#0]
;;;886    			break;
0006ce  e00f              B        |L1.1776|
;;;887    			case 0x1C:
;;;888    				BSP_DIP_9511Addr =   0x7D;
0006d0  207d              MOVS     r0,#0x7d
0006d2  4967              LDR      r1,|L1.2160|
0006d4  7008              STRB     r0,[r1,#0]
;;;889    			break;
0006d6  e00b              B        |L1.1776|
;;;890    			case 0x1D:
;;;891    				 BSP_DIP_9511Addr =   0x7E;
0006d8  207e              MOVS     r0,#0x7e
0006da  4965              LDR      r1,|L1.2160|
0006dc  7008              STRB     r0,[r1,#0]
;;;892    			break;
0006de  e007              B        |L1.1776|
;;;893    			case 0x1E:
;;;894    				BSP_DIP_9511Addr =   0x7F;
0006e0  207f              MOVS     r0,#0x7f
0006e2  4963              LDR      r1,|L1.2160|
0006e4  7008              STRB     r0,[r1,#0]
;;;895    			break;
0006e6  e003              B        |L1.1776|
                  |L1.1768|
;;;896    		/*	case 0x1F:
;;;897    			case 0:
;;;898    				while(1);
;;;899    			break; */
;;;900               	default:
;;;901    		       BSP_DIP_9511Addr	 =0x2F;//	 Addr_Tmp;
0006e8  202f              MOVS     r0,#0x2f
0006ea  4961              LDR      r1,|L1.2160|
0006ec  7008              STRB     r0,[r1,#0]
;;;902    			break;
0006ee  bf00              NOP      
                  |L1.1776|
0006f0  e003              B        |L1.1786|
                  |L1.1778|
;;;903    		}
;;;904    		}
;;;905    		else
;;;906    		{
;;;907    			BSP_DIP_9511Addr    =   (dip >> 6) & 0x0F;
0006f2  f3c41083          UBFX     r0,r4,#6,#4
0006f6  495e              LDR      r1,|L1.2160|
0006f8  7008              STRB     r0,[r1,#0]
                  |L1.1786|
;;;908    		}
;;;909    
;;;910            BSP_TM8M_Delay(BSP_TMR_8M_CLK / 1000);          /// delay 1/1000S
0006fa  f44f50fa          MOV      r0,#0x1f40
0006fe  f7fffffe          BL       BSP_TM8M_Delay
;;;911            if (dip == BSP_DIP_Get()) {
000702  f7fffffe          BL       BSP_DIP_Get
000706  42a0              CMP      r0,r4
000708  d100              BNE      |L1.1804|
;;;912                break;
00070a  e002              B        |L1.1810|
                  |L1.1804|
00070c  1e76              SUBS     r6,r6,#1              ;829
                  |L1.1806|
00070e  2e00              CMP      r6,#0                 ;829
000710  d181              BNE      |L1.1558|
                  |L1.1810|
000712  bf00              NOP      
;;;913            }
;;;914        }
;;;915    }
000714  e8bd81f0          POP      {r4-r8,pc}
;;;916    
                          ENDP

                  BSP_Init PROC
;;;601    /// -----------------------------------------------------------------------------------------------------
;;;602    void  BSP_Init (void)
000718  b510              PUSH     {r4,lr}
;;;603    {
;;;604        /// !!! 以下顺序不要随意改变 !!!
;;;605        BSP_EnPeriph();
00071a  f7fffffe          BL       BSP_EnPeriph
;;;606        BSP_NVIC_Cfg();
00071e  f7fffffe          BL       BSP_NVIC_Cfg
;;;607        
;;;608        BSP_TM8M_Init();
000722  f7fffffe          BL       BSP_TM8M_Init
;;;609        BSP_Judge924();
000726  f7fffffe          BL       BSP_Judge924
;;;610        BSP_DIP_Init();
00072a  f7fffffe          BL       BSP_DIP_Init
;;;611        /// !!! 以上顺序不要随意改变 !!!
;;;612        
;;;613        if (BSP_Is924) {
00072e  4851              LDR      r0,|L1.2164|
000730  7800              LDRB     r0,[r0,#0]  ; BSP_Is924
000732  b128              CBZ      r0,|L1.1856|
;;;614            BSP_TM_CNT_Init();
000734  f7fffffe          BL       BSP_TM_CNT_Init
;;;615            BSP_ENC_Init();
000738  f7fffffe          BL       BSP_ENC_Init
;;;616            BSP_ENC_IndexEn();
00073c  f7fffffe          BL       BSP_ENC_IndexEn
                  |L1.1856|
;;;617    #ifdef  PC924
;;;618            BSP_MOTC_Init();
;;;619    #endif
;;;620        }
;;;621        
;;;622        BSP_LED_Init();
000740  f7fffffe          BL       BSP_LED_Init
;;;623        BSP_HD_Init();
000744  f7fffffe          BL       BSP_HD_Init
;;;624    	BSP_SOL_Init();
000748  f7fffffe          BL       BSP_SOL_Init
;;;625        BSP_MOTO_Init();
00074c  f7fffffe          BL       BSP_MOTO_Init
;;;626    
;;;627        BSP_SWI_Init();
000750  f7fffffe          BL       BSP_SWI_Init
;;;628        BSP_POT_Init();
000754  f7fffffe          BL       BSP_POT_Init
;;;629    //    BSP_491_Init();
;;;630        BSP_SQN_Init();
000758  f7fffffe          BL       BSP_SQN_Init
;;;631    }
00075c  bd10              POP      {r4,pc}
;;;632    
                          ENDP

                  BSP_LED_Toggle PROC
;;;692    /// -----------------------------------------------------------------------------------------------------
;;;693    void  BSP_LED_Toggle (u8 led)
00075e  b570              PUSH     {r4-r6,lr}
;;;694    {
000760  4604              MOV      r4,r0
;;;695    //    switch (led) {
;;;696    //    case 0:
;;;697    //        BSP_LED_Toggle(1);
;;;698    //        BSP_LED_Toggle(2);
;;;699    //        break;
;;;700    //        
;;;701    //    case 1:
;;;702    //        IO_OutToggle(PB05_LED1);
;;;703    //        break;
;;;704    //        
;;;705    //    case 2:
;;;706    //        IO_OutToggle(PB09_LED2);
;;;707    //        break;
;;;708    //        
;;;709    //    default:
;;;710    //        break;
;;;711    //    }
;;;712        IO_OutToggle(io_id_led[led % BSP_LED_ID_N]);
000762  4625              MOV      r5,r4
000764  eb0471d4          ADD      r1,r4,r4,LSR #31
000768  1049              ASRS     r1,r1,#1
00076a  eba40141          SUB      r1,r4,r1,LSL #1
00076e  4a39              LDR      r2,|L1.2132|
000770  5c50              LDRB     r0,[r2,r1]
000772  f7fffffe          BL       IO_OutToggle
;;;713    }
000776  bd70              POP      {r4-r6,pc}
;;;714    
                          ENDP

                  BSP_HD_KeyGet PROC
;;;761    /// -----------------------------------------------------------------------------------------------------
;;;762    void  BSP_HD_KeyGet (BSP_ID_TypeDef id, BSP_HD_KEY_TypeDef *up, BSP_HD_KEY_TypeDef *down)
000778  b570              PUSH     {r4-r6,lr}
;;;763    {
00077a  4604              MOV      r4,r0
00077c  460d              MOV      r5,r1
00077e  4616              MOV      r6,r2
;;;764    //    switch (id) {
;;;765    //    case BSP_ID_ODD:
;;;766    //        *up     =   (BSP_HD_KEY_TypeDef)IO_InGet(PE08_HD_UP_ODD  );
;;;767    //        *down   =   (BSP_HD_KEY_TypeDef)IO_InGet(PE10_HD_DOWN_ODD);
;;;768    //        break;
;;;769    //        
;;;770    //    case BSP_ID_EVEN:
;;;771    //    default:                /// continue
;;;772    //        *up     =   (BSP_HD_KEY_TypeDef)IO_InGet(PC10_HD_UP_EVEN  );
;;;773    //        *down   =   (BSP_HD_KEY_TypeDef)IO_InGet(PD00_HD_DOWN_EVEN);
;;;774    //        break;
;;;775    //    }
;;;776        *up     =   (BSP_HD_KEY_TypeDef)IO_InGet(io_id_hd_up[id]);
000780  4932              LDR      r1,|L1.2124|
000782  5d08              LDRB     r0,[r1,r4]
000784  f7fffffe          BL       IO_InGet
000788  7028              STRB     r0,[r5,#0]
;;;777        *down   =   (BSP_HD_KEY_TypeDef)IO_InGet(io_id_hd_dn[id]);
00078a  4931              LDR      r1,|L1.2128|
00078c  5d08              LDRB     r0,[r1,r4]
00078e  f7fffffe          BL       IO_InGet
000792  7030              STRB     r0,[r6,#0]
;;;778    }
000794  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP

                  BSP_MOTO_Sitch_Init PROC
;;;1047   }
;;;1048   static  void  BSP_MOTO_Sitch_Init (void)
000796  b510              PUSH     {r4,lr}
;;;1049   {
;;;1050      u32     i;
;;;1051      for (i = 0; i < BSP_DEVICE_ID_N; i++) {
000798  2400              MOVS     r4,#0
00079a  e00a              B        |L1.1970|
                  |L1.1948|
;;;1052           IO_MultiInit(io_id_tq1_o[i], 2, GPIO_Mode_Out_PP);
00079c  4936              LDR      r1,|L1.2168|
00079e  5d08              LDRB     r0,[r1,r4]
0007a0  2210              MOVS     r2,#0x10
0007a2  2102              MOVS     r1,#2
0007a4  f7fffffe          BL       IO_MultiInit
;;;1053          // BSP_MOTO_TQSet((BSP_ID_TypeDef)i, BSP_MOT_TQ_20);//100
;;;1054   		BSP_MOTO_TQSet((BSP_ID_TypeDef)i, BSP_MOT_TQ_50);//120
0007a8  2102              MOVS     r1,#2
0007aa  b2e0              UXTB     r0,r4
0007ac  f7fffffe          BL       BSP_MOTO_TQSet
0007b0  1c64              ADDS     r4,r4,#1              ;1051
                  |L1.1970|
0007b2  2c02              CMP      r4,#2                 ;1051
0007b4  d3f2              BCC      |L1.1948|
;;;1055   	//	BSP_MOTO_TQSet((BSP_ID_TypeDef)i, BSP_MOT_TQ_75);//330
;;;1056   	//	BSP_MOTO_TQSet((BSP_ID_TypeDef)i, BSP_MOT_TQ_100); //3300
;;;1057       }
;;;1058   }
0007b6  bd10              POP      {r4,pc}
;;;1059   
                          ENDP

                  BSP_MOTO_Step_Init PROC
;;;1060   static  void  BSP_MOTO_Step_Init (void)
0007b8  b510              PUSH     {r4,lr}
;;;1061   {
;;;1062      u32     i;
;;;1063      for (i = 0; i < BSP_DEVICE_ID_N; i++) {
0007ba  2400              MOVS     r4,#0
0007bc  e00a              B        |L1.2004|
                  |L1.1982|
;;;1064           IO_MultiInit(io_id_m1_o[i], 3, GPIO_Mode_Out_PP);
0007be  492f              LDR      r1,|L1.2172|
0007c0  5d08              LDRB     r0,[r1,r4]
0007c2  2210              MOVS     r2,#0x10
0007c4  2103              MOVS     r1,#3
0007c6  f7fffffe          BL       IO_MultiInit
;;;1065        //  BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_0);
;;;1066   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_1);
;;;1067   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_2);
;;;1068   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_3);
;;;1069   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_4);
;;;1070   		BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_5);
0007ca  2105              MOVS     r1,#5
0007cc  b2e0              UXTB     r0,r4
0007ce  f7fffffe          BL       BSP_MOTO_MSet
0007d2  1c64              ADDS     r4,r4,#1              ;1063
                  |L1.2004|
0007d4  2c02              CMP      r4,#2                 ;1063
0007d6  d3f2              BCC      |L1.1982|
;;;1071   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_6);
;;;1072   	//	BSP_MOTO_MSet((BSP_ID_TypeDef)i, BSP_MOT_M_7);	
;;;1073       }
;;;1074   }
0007d8  bd10              POP      {r4,pc}
;;;1075   /// -----------------------------------------------------------------------------------------------------
                          ENDP

                  BSP_MOTO_StatusGet PROC
;;;1079   /// -----------------------------------------------------------------------------------------------------
;;;1080   BSP_MOT_ST_TypeDef  BSP_MOTO_StatusGet (BSP_ID_TypeDef id)
0007da  b510              PUSH     {r4,lr}
;;;1081   {
0007dc  4604              MOV      r4,r0
;;;1082   //    switch (id) {
;;;1083   //    case BSP_ID_ODD:
;;;1084   //        return  (BSP_MOT_ST_TypeDef)IO_InGet(PE13_PRO_O_ODD);
;;;1085   //        
;;;1086   //    case BSP_ID_EVEN:
;;;1087   //    default:                /// continue
;;;1088   //        return  (BSP_MOT_ST_TypeDef)IO_InGet(PE05_PRO_O_EVEN);
;;;1089   //    }
;;;1090       return  (BSP_MOT_ST_TypeDef)IO_InGet(io_id_pro_o[id]);
0007de  4928              LDR      r1,|L1.2176|
0007e0  5d08              LDRB     r0,[r1,r4]
0007e2  f7fffffe          BL       IO_InGet
0007e6  b2c0              UXTB     r0,r0
;;;1091   }
0007e8  bd10              POP      {r4,pc}
;;;1092   
                          ENDP

                  BSP_MOTO_ClkGet PROC
;;;1098   /// -----------------------------------------------------------------------------------------------------
;;;1099   BitAction  BSP_MOTO_ClkGet (BSP_ID_TypeDef id)
0007ea  b510              PUSH     {r4,lr}
;;;1100   {
0007ec  4604              MOV      r4,r0
;;;1101       return  (BitAction)IO_OutGet(io_id_clk_o[id]);
0007ee  4925              LDR      r1,|L1.2180|
0007f0  5d08              LDRB     r0,[r1,r4]
0007f2  f7fffffe          BL       IO_OutGet
0007f6  b2c0              UXTB     r0,r0
;;;1102   }
0007f8  bd10              POP      {r4,pc}
;;;1103   
                          ENDP

                  BSP_MOTO_DirSet PROC
;;;1137   /// -----------------------------------------------------------------------------------------------------
;;;1138   void  BSP_MOTO_DirSet (BSP_ID_TypeDef id, BSP_MOT_DIR_TypeDef dir)
0007fa  b570              PUSH     {r4-r6,lr}
;;;1139   {
0007fc  4604              MOV      r4,r0
0007fe  460d              MOV      r5,r1
;;;1140   //    switch (id) {        
;;;1141   ////    case BSP_ID_ALL:
;;;1142   ////        BSP_MOTO_DirSet(BSP_ID_ODD,  dir);
;;;1143   ////        BSP_MOTO_DirSet(BSP_ID_EVEN, dir);
;;;1144   ////        break;
;;;1145   //        
;;;1146   //    case BSP_ID_ODD:
;;;1147   //        IO_OutSet(PE12_DIR_O_ODD , (u32)dir);
;;;1148   //        break;
;;;1149   //        
;;;1150   //    case BSP_ID_EVEN:
;;;1151   //        IO_OutSet(PE04_DIR_O_EVEN, (u32)dir);
;;;1152   //        break;
;;;1153   //
;;;1154   //    default:
;;;1155   //        break;
;;;1156   //    }
;;;1157       IO_OutSet(io_id_dir_o[id], (u32)dir);
000800  4921              LDR      r1,|L1.2184|
000802  5d08              LDRB     r0,[r1,r4]
000804  4629              MOV      r1,r5
000806  f7fffffe          BL       IO_OutSet
;;;1158   }
00080a  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP

                  BSP_ENC_CntSet PROC
;;;1485   /// -----------------------------------------------------------------------------------------------------
;;;1486   void  BSP_ENC_CntSet (BSP_ID_TypeDef id, u16 cnt)
00080c  4a12              LDR      r2,|L1.2136|
;;;1487   {
;;;1488   //    switch (id) {
;;;1489   ////    case BSP_ID_ALL:
;;;1490   //////        BSP_TMR_E_ODD->CNT  =   cnt;
;;;1491   //////        BSP_TMR_E_EVEN->CNT =   cnt;
;;;1492   ////        BSP_ENC_CntSet(BSP_ID_ODD , cnt);
;;;1493   ////        BSP_ENC_CntSet(BSP_ID_EVEN, cnt);
;;;1494   ////        break;
;;;1495   //        
;;;1496   //    case BSP_ID_ODD:
;;;1497   //        BSP_TMR_E_ODD->CNT  =   cnt;
;;;1498   //        break;
;;;1499   //        
;;;1500   //    case BSP_ID_EVEN:
;;;1501   //        BSP_TMR_E_EVEN->CNT =   cnt;
;;;1502   //        break;
;;;1503   //
;;;1504   //    default:
;;;1505   //        break;
;;;1506   //    }
;;;1507       tim_id_encoder[id]->CNT =   cnt;
00080e  f8522020          LDR      r2,[r2,r0,LSL #2]
000812  8491              STRH     r1,[r2,#0x24]
;;;1508   }
000814  4770              BX       lr
;;;1509   
                          ENDP

                  BSP_ENC_CntGet PROC
;;;1510   u16  BSP_ENC_CntGet (BSP_ID_TypeDef id)
000816  4601              MOV      r1,r0
;;;1511   {
;;;1512       return (tim_id_encoder[id]->CNT);
000818  480f              LDR      r0,|L1.2136|
00081a  f8500021          LDR      r0,[r0,r1,LSL #2]
00081e  8c80              LDRH     r0,[r0,#0x24]
;;;1513   }
000820  4770              BX       lr
;;;1514   
                          ENDP

                  BSP_SWI_FiGet PROC
;;;1553   /// -----------------------------------------------------------------------------------------------------
;;;1554   BSP_SWITCH_TypeDef  BSP_SWI_FiGet (BSP_ID_TypeDef id)
000822  b510              PUSH     {r4,lr}
;;;1555   {
000824  4604              MOV      r4,r0
;;;1556   //    switch (id) {
;;;1557   //    case BSP_ID_ODD:
;;;1558   //        return  (BSP_SWITCH_TypeDef)IO_InGet(PE07_DJ_CUT_ODD);
;;;1559   //        
;;;1560   //    case BSP_ID_EVEN:
;;;1561   //    default:                /// continue
;;;1562   //        return  (BSP_SWITCH_TypeDef)IO_InGet(PD01_DJ_CUT_EVEN);
;;;1563   //    }
;;;1564       return  (BSP_SWITCH_TypeDef)IO_InGet(io_id_swi_fi[id]);
000826  4919              LDR      r1,|L1.2188|
000828  5d08              LDRB     r0,[r1,r4]
00082a  f7fffffe          BL       IO_InGet
00082e  b2c0              UXTB     r0,r0
;;;1565   }
000830  bd10              POP      {r4,pc}
;;;1566   
                          ENDP

                  BSP_SWI_SeGet PROC
;;;1571   /// -----------------------------------------------------------------------------------------------------
;;;1572   BSP_SWITCH_TypeDef  BSP_SWI_SeGet (BSP_ID_TypeDef id)
000832  b510              PUSH     {r4,lr}
;;;1573   {
000834  4604              MOV      r4,r0
;;;1574   //    switch (id) {
;;;1575   //    case BSP_ID_ODD:
;;;1576   //        return  (BSP_SWITCH_TypeDef)IO_InGet(PD06_XDJ_ODD);
;;;1577   //        
;;;1578   //    case BSP_ID_EVEN:
;;;1579   //    default:                /// continue
;;;1580   //        return  (BSP_SWITCH_TypeDef)IO_InGet(PD07_XDJ_EVEN);
;;;1581   //    }
;;;1582       return  (BSP_SWITCH_TypeDef)IO_InGet(io_id_swi_se[id]);
000836  4916              LDR      r1,|L1.2192|
000838  5d08              LDRB     r0,[r1,r4]
00083a  f7fffffe          BL       IO_InGet
00083e  b2c0              UXTB     r0,r0
;;;1583   }
000840  bd10              POP      {r4,pc}
000842  0000              DCW      0x0000
                  |L1.2116|
                          DCD      io_id_hd_r
                  |L1.2120|
                          DCD      io_id_hd_g
                  |L1.2124|
                          DCD      io_id_hd_up
                  |L1.2128|
                          DCD      io_id_hd_dn
                  |L1.2132|
                          DCD      io_id_led
                  |L1.2136|
                          DCD      tim_id_encoder
                  |L1.2140|
                          DCD      io_id_enc_a
                  |L1.2144|
                          DCD      io_id_enc_i
                  |L1.2148|
                          DCD      BSP_DIP_RedIsSpkl
                  |L1.2152|
                          DCD      BSP_DIP_TQ
                  |L1.2156|
                          DCD      BSP_DIP_BDFunc
                  |L1.2160|
                          DCD      BSP_DIP_9511Addr
                  |L1.2164|
                          DCD      BSP_Is924
                  |L1.2168|
                          DCD      io_id_tq1_o
                  |L1.2172|
                          DCD      io_id_m1_o
                  |L1.2176|
                          DCD      io_id_pro_o
                  |L1.2180|
                          DCD      io_id_clk_o
                  |L1.2184|
                          DCD      io_id_dir_o
                  |L1.2188|
                          DCD      io_id_swi_fi
                  |L1.2192|
                          DCD      io_id_swi_se
                          ENDP

                  BSP_POT_GetOne PROC
;;;1738   
;;;1739   u16  BSP_POT_GetOne (BSP_ID_TypeDef id)
000894  b510              PUSH     {r4,lr}
;;;1740   {
000896  4602              MOV      r2,r0
;;;1741       static  u8      i_odd   =   0;
;;;1742       static  u8      i_even  =   0;
;;;1743               u16     tmp;
;;;1744       
;;;1745       
;;;1746       switch (id) {
000898  b112              CBZ      r2,|L1.2208|
00089a  2a01              CMP      r2,#1
00089c  d127              BNE      |L1.2286|
00089e  e012              B        |L1.2246|
                  |L1.2208|
;;;1747       case BSP_ID_ODD:
;;;1748           tmp     =   BSP_POTValue[i_odd++].odd;
0008a0  48ff              LDR      r0,|L1.3232|
0008a2  7803              LDRB     r3,[r0,#0]  ; i_odd
0008a4  7800              LDRB     r0,[r0,#0]  ; i_odd
0008a6  1c40              ADDS     r0,r0,#1
0008a8  4cfd              LDR      r4,|L1.3232|
0008aa  7020              STRB     r0,[r4,#0]
0008ac  48fd              LDR      r0,|L1.3236|
0008ae  f8301023          LDRH     r1,[r0,r3,LSL #2]
;;;1749           i_odd  %=   BSP_ADC_VAL_NUM;
0008b2  4623              MOV      r3,r4
0008b4  7818              LDRB     r0,[r3,#0]  ; i_odd
0008b6  17c3              ASRS     r3,r0,#31
0008b8  eb007353          ADD      r3,r0,r3,LSR #29
0008bc  10db              ASRS     r3,r3,#3
0008be  eba003c3          SUB      r3,r0,r3,LSL #3
0008c2  7023              STRB     r3,[r4,#0]
;;;1750           break;
0008c4  e015              B        |L1.2290|
                  |L1.2246|
;;;1751           
;;;1752       case BSP_ID_EVEN:
;;;1753           tmp     =   BSP_POTValue[i_even++].even;
0008c6  48f8              LDR      r0,|L1.3240|
0008c8  7803              LDRB     r3,[r0,#0]  ; i_even
0008ca  7800              LDRB     r0,[r0,#0]  ; i_even
0008cc  1c40              ADDS     r0,r0,#1
0008ce  4cf6              LDR      r4,|L1.3240|
0008d0  7020              STRB     r0,[r4,#0]
0008d2  48f4              LDR      r0,|L1.3236|
0008d4  eb000083          ADD      r0,r0,r3,LSL #2
0008d8  8841              LDRH     r1,[r0,#2]
;;;1754           i_even %=   BSP_ADC_VAL_NUM;
0008da  4623              MOV      r3,r4
0008dc  7818              LDRB     r0,[r3,#0]  ; i_even
0008de  17c3              ASRS     r3,r0,#31
0008e0  eb007353          ADD      r3,r0,r3,LSR #29
0008e4  10db              ASRS     r3,r3,#3
0008e6  eba003c3          SUB      r3,r0,r3,LSL #3
0008ea  7023              STRB     r3,[r4,#0]
;;;1755           break;
0008ec  e001              B        |L1.2290|
                  |L1.2286|
;;;1756       
;;;1757       default:
;;;1758           tmp     =   0;
0008ee  2100              MOVS     r1,#0
;;;1759           break;
0008f0  bf00              NOP      
                  |L1.2290|
0008f2  bf00              NOP                            ;1750
;;;1760       }
;;;1761       
;;;1762       return  (tmp << (16 - 12));
0008f4  0508              LSLS     r0,r1,#20
0008f6  0c00              LSRS     r0,r0,#16
;;;1763   }
0008f8  bd10              POP      {r4,pc}
;;;1764   
                          ENDP

                  BSP_POT_GetAve PROC
;;;1765   u16  BSP_POT_GetAve (BSP_ID_TypeDef id)
0008fa  4603              MOV      r3,r0
;;;1766   {
;;;1767       u32     i;
;;;1768       u16     tmp =   0;
0008fc  2200              MOVS     r2,#0
;;;1769       
;;;1770       
;;;1771       switch (id) {
0008fe  b113              CBZ      r3,|L1.2310|
000900  2b01              CMP      r3,#1
000902  d117              BNE      |L1.2356|
000904  e00a              B        |L1.2332|
                  |L1.2310|
;;;1772       case BSP_ID_ODD:
;;;1773           for (i = 0; i < BSP_ADC_VAL_NUM; i++) {
000906  2100              MOVS     r1,#0
000908  e005              B        |L1.2326|
                  |L1.2314|
;;;1774               tmp    +=   BSP_POTValue[i].odd; 
00090a  48e6              LDR      r0,|L1.3236|
00090c  f8300021          LDRH     r0,[r0,r1,LSL #2]
000910  4410              ADD      r0,r0,r2
000912  b282              UXTH     r2,r0
000914  1c49              ADDS     r1,r1,#1              ;1773
                  |L1.2326|
000916  2908              CMP      r1,#8                 ;1773
000918  d3f7              BCC      |L1.2314|
;;;1775           }
;;;1776           break;
00091a  e00c              B        |L1.2358|
                  |L1.2332|
;;;1777           
;;;1778       case BSP_ID_EVEN:
;;;1779           for (i = 0; i < BSP_ADC_VAL_NUM; i++) {
00091c  2100              MOVS     r1,#0
00091e  e006              B        |L1.2350|
                  |L1.2336|
;;;1780               tmp    +=   BSP_POTValue[i].even; 
000920  48e0              LDR      r0,|L1.3236|
000922  eb000081          ADD      r0,r0,r1,LSL #2
000926  8840              LDRH     r0,[r0,#2]
000928  4410              ADD      r0,r0,r2
00092a  b282              UXTH     r2,r0
00092c  1c49              ADDS     r1,r1,#1              ;1779
                  |L1.2350|
00092e  2908              CMP      r1,#8                 ;1779
000930  d3f6              BCC      |L1.2336|
;;;1781           }
;;;1782           break;
000932  e000              B        |L1.2358|
                  |L1.2356|
;;;1783           
;;;1784       default:
;;;1785           break;
000934  bf00              NOP      
                  |L1.2358|
000936  bf00              NOP                            ;1776
;;;1786       }
;;;1787       
;;;1788   #if ((16 - 12) >= BSP_ADC_VAL_N_POWER)
;;;1789       return  (tmp << ((16 - 12) - BSP_ADC_VAL_N_POWER));
000938  0450              LSLS     r0,r2,#17
00093a  0c00              LSRS     r0,r0,#16
;;;1790   #else
;;;1791       return  (tmp >> (BSP_ADC_VAL_N_POWER - (16 - 12)));
;;;1792   #endif
;;;1793   
;;;1794   }
00093c  4770              BX       lr
;;;1795   
                          ENDP

                  BSP_491_DeSet PROC
;;;1934   /// -----------------------------------------------------------------------------------------------------
;;;1935   void  BSP_491_DeSet (FunctionalState NewState)
00093e  b510              PUSH     {r4,lr}
;;;1936   {
000940  4604              MOV      r4,r0
;;;1937       if (NewState != DISABLE) {
000942  b124              CBZ      r4,|L1.2382|
;;;1938           IO_OutSet(PC13_491_DE, 1);
000944  2101              MOVS     r1,#1
000946  202d              MOVS     r0,#0x2d
000948  f7fffffe          BL       IO_OutSet
00094c  e003              B        |L1.2390|
                  |L1.2382|
;;;1939       } else {
;;;1940           IO_OutSet(PC13_491_DE, 0);
00094e  2100              MOVS     r1,#0
000950  202d              MOVS     r0,#0x2d
000952  f7fffffe          BL       IO_OutSet
                  |L1.2390|
;;;1941       }
;;;1942   }
000956  bd10              POP      {r4,pc}
;;;1943   
                          ENDP

                  BSP_491_Init PROC
;;;1831   /// -----------------------------------------------------------------------------------------------------
;;;1832   void  BSP_491_Init (void)
000958  b51f              PUSH     {r0-r4,lr}
;;;1833   {
;;;1834   //    DMA_InitTypeDef             sDMAInit;
;;;1835       USART_InitTypeDef           sUSARTInit;
;;;1836       
;;;1837       
;;;1838   //    BSP_491_RxBufInit();
;;;1839   //    
;;;1840   //    /// DMA configuration (triggered by USART_491 Rx event)
;;;1841   //    sDMAInit.DMA_PeripheralBaseAddr =   (u32)BSP_DMA_CPA_491RX;
;;;1842   //    sDMAInit.DMA_MemoryBaseAddr     =   (u32)BSP_491_RxBuf;
;;;1843   //    sDMAInit.DMA_DIR                =   DMA_DIR_PeripheralSRC;
;;;1844   //    sDMAInit.DMA_BufferSize         =   1 << BSP_491_RXBUF_N_POWER;
;;;1845   //    sDMAInit.DMA_PeripheralInc      =   DMA_PeripheralInc_Disable;
;;;1846   //    sDMAInit.DMA_MemoryInc          =   DMA_MemoryInc_Enable;
;;;1847   //    sDMAInit.DMA_PeripheralDataSize =   DMA_PeripheralDataSize_HalfWord;
;;;1848   //    sDMAInit.DMA_MemoryDataSize     =   DMA_MemoryDataSize_HalfWord;
;;;1849   //    sDMAInit.DMA_Mode               =   DMA_Mode_Circular;
;;;1850   //    sDMAInit.DMA_Priority           =   DMA_Priority_High;
;;;1851   //    sDMAInit.DMA_M2M                =   DMA_M2M_Disable;
;;;1852   //    DMA_Init(BSP_DMA_CHN_491RX, &sDMAInit);
;;;1853   //    
;;;1854   //    DMA_Cmd(BSP_DMA_CHN_491RX, ENABLE);
;;;1855       
;;;1856       
;;;1857       /// Configure USART_491
;;;1858       sUSARTInit.USART_BaudRate               =   BSP_491_BAUD_RATE;
00095a  48d4              LDR      r0,|L1.3244|
00095c  9000              STR      r0,[sp,#0]
;;;1859       if (BSP_Is924) {
00095e  48d4              LDR      r0,|L1.3248|
000960  7800              LDRB     r0,[r0,#0]  ; BSP_Is924
000962  b120              CBZ      r0,|L1.2414|
;;;1860           sUSARTInit.USART_WordLength         =   USART_WordLength_9b;
000964  f44f5080          MOV      r0,#0x1000
000968  f8ad0004          STRH     r0,[sp,#4]
00096c  e002              B        |L1.2420|
                  |L1.2414|
;;;1861       } else {
;;;1862           sUSARTInit.USART_WordLength         =   USART_WordLength_8b;
00096e  2000              MOVS     r0,#0
000970  f8ad0004          STRH     r0,[sp,#4]
                  |L1.2420|
;;;1863       }
;;;1864       sUSARTInit.USART_StopBits               =   BSP_491_STOP_BITS;
000974  f44f5000          MOV      r0,#0x2000
000978  f8ad0006          STRH     r0,[sp,#6]
;;;1865       sUSARTInit.USART_Parity                 =   USART_Parity_No;
00097c  2000              MOVS     r0,#0
00097e  f8ad0008          STRH     r0,[sp,#8]
;;;1866       sUSARTInit.USART_HardwareFlowControl    =   USART_HardwareFlowControl_None;     /// no RTS and CTS
000982  f8ad000c          STRH     r0,[sp,#0xc]
;;;1867       sUSARTInit.USART_Mode                   =   USART_Mode_Rx | USART_Mode_Tx;      /// Rx and Tx enabled
000986  200c              MOVS     r0,#0xc
000988  f8ad000a          STRH     r0,[sp,#0xa]
;;;1868       
;;;1869       USART_Init(BSP_USART_491, &sUSARTInit);
00098c  4669              MOV      r1,sp
00098e  48c9              LDR      r0,|L1.3252|
000990  f7fffffe          BL       USART_Init
;;;1870       
;;;1871   //    /// Enable USART_491 DMA Rx request
;;;1872   //    USART_DMACmd(BSP_USART_491, USART_DMAReq_Rx, ENABLE);
;;;1873       
;;;1874       /// Enable BSP_USART_491 Receive and Transmit interrupts
;;;1875       USART_ITConfig(BSP_USART_491, USART_IT_RXNE, ENABLE);
000994  2201              MOVS     r2,#1
000996  f2405125          MOV      r1,#0x525
00099a  48c6              LDR      r0,|L1.3252|
00099c  f7fffffe          BL       USART_ITConfig
;;;1876       USART_ITConfig(BSP_USART_491, USART_IT_TC  , DISABLE);
0009a0  2200              MOVS     r2,#0
0009a2  f2406126          MOV      r1,#0x626
0009a6  48c3              LDR      r0,|L1.3252|
0009a8  f7fffffe          BL       USART_ITConfig
;;;1877   //    USART_ITConfig(BSP_USART_491, USART_IT_TXE , ENABLE);
;;;1878   //    USART_ITConfig(BSP_USART_491, USART_IT_TC  , ENABLE);
;;;1879       
;;;1880       /// Configure the GPIO ports
;;;1881       IO_Init(PC13_491_DE, GPIO_Mode_Out_PP);
0009ac  2110              MOVS     r1,#0x10
0009ae  202d              MOVS     r0,#0x2d
0009b0  f7fffffe          BL       IO_Init
;;;1882       IO_Init(PA09_491_TX, GPIO_Mode_AF_PP);
0009b4  2118              MOVS     r1,#0x18
0009b6  2009              MOVS     r0,#9
0009b8  f7fffffe          BL       IO_Init
;;;1883       IO_Init(PA10_491_RX, GPIO_Mode_IN_FLOATING);
0009bc  2104              MOVS     r1,#4
0009be  200a              MOVS     r0,#0xa
0009c0  f7fffffe          BL       IO_Init
;;;1884       BSP_491_DeSet(DISABLE);                         /// 释放发送总线
0009c4  2000              MOVS     r0,#0
0009c6  f7fffffe          BL       BSP_491_DeSet
;;;1885       
;;;1886       /// Enable the USART_491
;;;1887       USART_Cmd(BSP_USART_491, ENABLE);
0009ca  2101              MOVS     r1,#1
0009cc  48b9              LDR      r0,|L1.3252|
0009ce  f7fffffe          BL       USART_Cmd
;;;1888   }
0009d2  bd1f              POP      {r0-r4,pc}
;;;1889   
                          ENDP

                  UID_Change2_D PROC
;;;1999   ********************************************************************/
;;;2000   void UID_Change2_D(u8 * dst,u8 * shunxu)
0009d4  b510              PUSH     {r4,lr}
;;;2001   {
0009d6  4602              MOV      r2,r0
;;;2002   	u8 i;
;;;2003   	for(i=0;i<12;i++)
0009d8  2000              MOVS     r0,#0
0009da  e007              B        |L1.2540|
                  |L1.2524|
;;;2004   	{
;;;2005   		dst[i]=*(u8 *)(CONFIRM_STM32_ID_ADDR+shunxu[i]);
0009dc  5c0b              LDRB     r3,[r1,r0]
0009de  4cb6              LDR      r4,|L1.3256|
0009e0  4423              ADD      r3,r3,r4
0009e2  f89337e8          LDRB     r3,[r3,#0x7e8]
0009e6  5413              STRB     r3,[r2,r0]
0009e8  1c43              ADDS     r3,r0,#1              ;2003
0009ea  b2d8              UXTB     r0,r3                 ;2003
                  |L1.2540|
0009ec  280c              CMP      r0,#0xc               ;2003
0009ee  dbf5              BLT      |L1.2524|
;;;2006   	} 
;;;2007   }
0009f0  bd10              POP      {r4,pc}
;;;2008   void  	Get_9511_ID(void)//获得烧录器写入的4字节数据
                          ENDP

                  Get_9511_ID PROC
0009f2  2000              MOVS     r0,#0
;;;2009   {
;;;2010   	u8 i;
;;;2011   	for(i=0;i<4;i++)
0009f4  e007              B        |L1.2566|
                  |L1.2550|
;;;2012   	 {
;;;2013   	 	PRO_9511_ID[i]=*(u8 *)(CONFIRM_9511_ID_ADDR+i);
0009f6  49b1              LDR      r1,|L1.3260|
0009f8  4401              ADD      r1,r1,r0
0009fa  f8911c00          LDRB     r1,[r1,#0xc00]
0009fe  4ab0              LDR      r2,|L1.3264|
000a00  5411              STRB     r1,[r2,r0]
000a02  1c41              ADDS     r1,r0,#1              ;2011
000a04  b2c8              UXTB     r0,r1                 ;2011
                  |L1.2566|
000a06  2804              CMP      r0,#4                 ;2011
000a08  dbf5              BLT      |L1.2550|
;;;2014   	 }
;;;2015   }
000a0a  4770              BX       lr
;;;2016   extern void PRO_MainSetPssW(u16 buf[], u8 len,u32 Addr);
                          ENDP

                  Get_Main_ID_Status PROC
;;;2020   
;;;2021   static u8 Get_Main_ID_Status(u32 Addr,u8 len)
000a0c  b5f0              PUSH     {r4-r7,lr}
;;;2022   {
000a0e  b085              SUB      sp,sp,#0x14
000a10  4604              MOV      r4,r0
000a12  460b              MOV      r3,r1
;;;2023   	u8 status=1,i;
000a14  2001              MOVS     r0,#1
;;;2024   	u8 tmp_read_buf[20],com_tmp,len_tmp;
;;;2025   	for(i=0;i<len;i++)
000a16  2100              MOVS     r1,#0
000a18  e004              B        |L1.2596|
                  |L1.2586|
;;;2026   	{
;;;2027   		tmp_read_buf[i]=*(u8*)(Addr+i);
000a1a  5c66              LDRB     r6,[r4,r1]
000a1c  f80d6001          STRB     r6,[sp,r1]
000a20  1c4e              ADDS     r6,r1,#1              ;2025
000a22  b2f1              UXTB     r1,r6                 ;2025
                  |L1.2596|
000a24  4299              CMP      r1,r3                 ;2025
000a26  dbf8              BLT      |L1.2586|
;;;2028   	}
;;;2029   	len_tmp=len>>1;
000a28  105a              ASRS     r2,r3,#1
;;;2030   	for(i=0;i<len_tmp;i++)
000a2a  2100              MOVS     r1,#0
000a2c  e00c              B        |L1.2632|
                  |L1.2606|
;;;2031   	{
;;;2032   		com_tmp=(~tmp_read_buf[i+len_tmp]);
000a2e  188e              ADDS     r6,r1,r2
000a30  f81d6006          LDRB     r6,[sp,r6]
000a34  43f6              MVNS     r6,r6
000a36  b2f5              UXTB     r5,r6
;;;2033   		if(tmp_read_buf[i]!=com_tmp)
000a38  f81d6001          LDRB     r6,[sp,r1]
000a3c  42ae              CMP      r6,r5
000a3e  d001              BEQ      |L1.2628|
;;;2034   		{
;;;2035   			status=0;	//有数但是异常
000a40  2000              MOVS     r0,#0
;;;2036   			break;
000a42  e003              B        |L1.2636|
                  |L1.2628|
000a44  1c4e              ADDS     r6,r1,#1              ;2030
000a46  b2f1              UXTB     r1,r6                 ;2030
                  |L1.2632|
000a48  4291              CMP      r1,r2                 ;2030
000a4a  dbf0              BLT      |L1.2606|
                  |L1.2636|
000a4c  bf00              NOP      
;;;2037   		}
;;;2038   	}
;;;2039   	return status;	
;;;2040   }
000a4e  b005              ADD      sp,sp,#0x14
000a50  bdf0              POP      {r4-r7,pc}
;;;2041   extern u8 Confirm_status;
                          ENDP

                  Get_Main_ID PROC
;;;2044   extern u8 thir_status;
;;;2045   void  	Get_Main_ID(void)//获得主控加密时候写入的4字节数据
000a52  e92d4ff8          PUSH     {r3-r11,lr}
;;;2046   {
;;;2047   	u8 i,first_status=0,second_status=0,status=0,tmp_u8;
000a56  f04f0900          MOV      r9,#0
000a5a  46ca              MOV      r10,r9
000a5c  46c8              MOV      r8,r9
;;;2048   	u16 tmp1=0,tmp2=0;
000a5e  2500              MOVS     r5,#0
000a60  2600              MOVS     r6,#0
;;;2049   	u32 Addr1,Addr2;
;;;2050   	Addr1=CONFIRM_MAINCONTRAL_ADDR1;
000a62  f8dfb260          LDR      r11,|L1.3268|
;;;2051   	Addr2=CONFIRM_MAINCONTRAL_ADDR2;
000a66  4898              LDR      r0,|L1.3272|
000a68  9000              STR      r0,[sp,#0]
;;;2052   	tmp1=*(u16*)(Addr1+16);
000a6a  f8bb5010          LDRH     r5,[r11,#0x10]
;;;2053   	tmp2=*(u16*)(Addr2+16);
000a6e  9800              LDR      r0,[sp,#0]
000a70  8a06              LDRH     r6,[r0,#0x10]
;;;2054   	if((tmp1==0xFFFF)&&(tmp2==0xFFFF))//9511不加密
000a72  f5a5407f          SUB      r0,r5,#0xff00
000a76  38ff              SUBS     r0,r0,#0xff
000a78  d106              BNE      |L1.2696|
000a7a  f5a6407f          SUB      r0,r6,#0xff00
000a7e  38ff              SUBS     r0,r0,#0xff
000a80  d102              BNE      |L1.2696|
;;;2055   		thir_status=0;
000a82  4992              LDR      r1,|L1.3276|
000a84  7008              STRB     r0,[r1,#0]
000a86  e07a              B        |L1.2942|
                  |L1.2696|
;;;2056   	else if((tmp1!=0xFFFF)&&(tmp2==0xFFFF))//第一块加密有数
000a88  f5a5407f          SUB      r0,r5,#0xff00
000a8c  38ff              SUBS     r0,r0,#0xff
000a8e  d013              BEQ      |L1.2744|
000a90  f5a6407f          SUB      r0,r6,#0xff00
000a94  38ff              SUBS     r0,r0,#0xff
000a96  d10f              BNE      |L1.2744|
;;;2057   	{
;;;2058   		status=Get_Main_ID_Status(Addr1,16);//返回1，表示第一块加密有效，返回0，无效，不加密
000a98  2110              MOVS     r1,#0x10
000a9a  4658              MOV      r0,r11
000a9c  f7fffffe          BL       Get_Main_ID_Status
000aa0  4680              MOV      r8,r0
;;;2059   		if(status==1)
000aa2  f1b80f01          CMP      r8,#1
000aa6  d103              BNE      |L1.2736|
;;;2060   			thir_status=1;
000aa8  2001              MOVS     r0,#1
000aaa  4988              LDR      r1,|L1.3276|
000aac  7008              STRB     r0,[r1,#0]
000aae  e066              B        |L1.2942|
                  |L1.2736|
;;;2061   		else
;;;2062   			thir_status=3;//第一块加密无效，第二块不加密	
000ab0  2003              MOVS     r0,#3
000ab2  4986              LDR      r1,|L1.3276|
000ab4  7008              STRB     r0,[r1,#0]
000ab6  e062              B        |L1.2942|
                  |L1.2744|
;;;2063   	}
;;;2064   	else if((tmp1==0xFFFF)&&(tmp2!=0xFFFF))//第二块加密有数
000ab8  f5a5407f          SUB      r0,r5,#0xff00
000abc  38ff              SUBS     r0,r0,#0xff
000abe  d113              BNE      |L1.2792|
000ac0  f5a6407f          SUB      r0,r6,#0xff00
000ac4  38ff              SUBS     r0,r0,#0xff
000ac6  d00f              BEQ      |L1.2792|
;;;2065   	{
;;;2066   		status=Get_Main_ID_Status(Addr2,16);//返回1，表示第二块加密有效，返回0，无效，不加密
000ac8  2110              MOVS     r1,#0x10
000aca  9800              LDR      r0,[sp,#0]
000acc  f7fffffe          BL       Get_Main_ID_Status
000ad0  4680              MOV      r8,r0
;;;2067   		if(status==1)
000ad2  f1b80f01          CMP      r8,#1
000ad6  d103              BNE      |L1.2784|
;;;2068   			thir_status=2;
000ad8  2002              MOVS     r0,#2
000ada  497c              LDR      r1,|L1.3276|
000adc  7008              STRB     r0,[r1,#0]
000ade  e04e              B        |L1.2942|
                  |L1.2784|
;;;2069   		else
;;;2070   			thir_status=4;//第二块加密无效，第一块不加密	
000ae0  2004              MOVS     r0,#4
000ae2  497a              LDR      r1,|L1.3276|
000ae4  7008              STRB     r0,[r1,#0]
000ae6  e04a              B        |L1.2942|
                  |L1.2792|
;;;2071   	}
;;;2072   	else //两块加密区都有数
;;;2073   	{
;;;2074   	
;;;2075   		status=Get_Main_ID_Status(Addr1,16);//返回1，表示第一块加密有效，返回0，无效
000ae8  2110              MOVS     r1,#0x10
000aea  4658              MOV      r0,r11
000aec  f7fffffe          BL       Get_Main_ID_Status
000af0  4680              MOV      r8,r0
;;;2076   		if(status==1)
000af2  f1b80f01          CMP      r8,#1
000af6  d102              BNE      |L1.2814|
;;;2077   			first_status=1;	//有效
000af8  f04f0901          MOV      r9,#1
000afc  e001              B        |L1.2818|
                  |L1.2814|
;;;2078   		else
;;;2079   			first_status=0;	//无效
000afe  f04f0900          MOV      r9,#0
                  |L1.2818|
;;;2080   		status=Get_Main_ID_Status(Addr2,16);//返回1，表示第二块加密有效，返回0，无效
000b02  2110              MOVS     r1,#0x10
000b04  9800              LDR      r0,[sp,#0]
000b06  f7fffffe          BL       Get_Main_ID_Status
000b0a  4680              MOV      r8,r0
;;;2081   		if(status==1)
000b0c  f1b80f01          CMP      r8,#1
000b10  d102              BNE      |L1.2840|
;;;2082   			second_status=1;	//有效
000b12  f04f0a01          MOV      r10,#1
000b16  e001              B        |L1.2844|
                  |L1.2840|
;;;2083   		else
;;;2084   			second_status=0;	//无效
000b18  f04f0a00          MOV      r10,#0
                  |L1.2844|
;;;2085   		if((tmp1>=tmp2)&&(first_status==1))//第一个最新，而且有效
000b1c  42b5              CMP      r5,r6
000b1e  db06              BLT      |L1.2862|
000b20  f1b90f01          CMP      r9,#1
000b24  d103              BNE      |L1.2862|
;;;2086   			thir_status=1;
000b26  2001              MOVS     r0,#1
000b28  4968              LDR      r1,|L1.3276|
000b2a  7008              STRB     r0,[r1,#0]
000b2c  e027              B        |L1.2942|
                  |L1.2862|
;;;2087   		else if((tmp1>=tmp2)&&(first_status==0))//第一个最新，但是无效
000b2e  42b5              CMP      r5,r6
000b30  db0d              BLT      |L1.2894|
000b32  f1b90f00          CMP      r9,#0
000b36  d10a              BNE      |L1.2894|
;;;2088   		{
;;;2089   			if(second_status==1)//第二个有效，以第二个为准
000b38  f1ba0f01          CMP      r10,#1
000b3c  d103              BNE      |L1.2886|
;;;2090   				thir_status=2;
000b3e  2002              MOVS     r0,#2
000b40  4962              LDR      r1,|L1.3276|
000b42  7008              STRB     r0,[r1,#0]
000b44  e01b              B        |L1.2942|
                  |L1.2886|
;;;2091   			else
;;;2092   				thir_status=5;//两个都无效，不加密	
000b46  2005              MOVS     r0,#5
000b48  4960              LDR      r1,|L1.3276|
000b4a  7008              STRB     r0,[r1,#0]
000b4c  e017              B        |L1.2942|
                  |L1.2894|
;;;2093   		}
;;;2094   		else if((tmp2>tmp1)&&(second_status==1))//第er个最新，而且有效
000b4e  42ae              CMP      r6,r5
000b50  dd06              BLE      |L1.2912|
000b52  f1ba0f01          CMP      r10,#1
000b56  d103              BNE      |L1.2912|
;;;2095   			  thir_status=2;
000b58  2002              MOVS     r0,#2
000b5a  495c              LDR      r1,|L1.3276|
000b5c  7008              STRB     r0,[r1,#0]
000b5e  e00e              B        |L1.2942|
                  |L1.2912|
;;;2096   		else if((tmp2>tmp1)&&(second_status==1))//第er个最新，但是无效
000b60  42ae              CMP      r6,r5
000b62  dd0c              BLE      |L1.2942|
000b64  f1ba0f01          CMP      r10,#1
000b68  d109              BNE      |L1.2942|
;;;2097   		{
;;;2098   			if(first_status==1)//第一个有效，以第一个为准
000b6a  f1b90f01          CMP      r9,#1
000b6e  d103              BNE      |L1.2936|
;;;2099   				thir_status=1;
000b70  2001              MOVS     r0,#1
000b72  4956              LDR      r1,|L1.3276|
000b74  7008              STRB     r0,[r1,#0]
000b76  e002              B        |L1.2942|
                  |L1.2936|
;;;2100   			else
;;;2101   				thir_status=5;//两个都无效，不加密	
000b78  2005              MOVS     r0,#5
000b7a  4954              LDR      r1,|L1.3276|
000b7c  7008              STRB     r0,[r1,#0]
                  |L1.2942|
;;;2102   		}
;;;2103   	}	
;;;2104   	switch(thir_status)
000b7e  4853              LDR      r0,|L1.3276|
000b80  7800              LDRB     r0,[r0,#0]  ; thir_status
000b82  2806              CMP      r0,#6
000b84  d27e              BCS      |L1.3204|
000b86  e8dff000          TBB      [pc,r0]
000b8a  0312              DCB      0x03,0x12
000b8c  55c3daf2          DCB      0x55,0xc3,0xda,0xf2
;;;2105   	{	
;;;2106   		case 0://两个都不加密
;;;2107   			for(i=0;i<4;i++)//将上传密码设置为0xFF。
000b90  2400              MOVS     r4,#0
000b92  e004              B        |L1.2974|
                  |L1.2964|
;;;2108   			{
;;;2109   				MAIN_Sec_ID[i]=0xFF;
000b94  20ff              MOVS     r0,#0xff
000b96  494e              LDR      r1,|L1.3280|
000b98  5508              STRB     r0,[r1,r4]
000b9a  1c60              ADDS     r0,r4,#1              ;2107
000b9c  b2c4              UXTB     r4,r0                 ;2107
                  |L1.2974|
000b9e  2c04              CMP      r4,#4                 ;2107
000ba0  dbf8              BLT      |L1.2964|
;;;2110   			}
;;;2111   			Sec_Number=0;
000ba2  2000              MOVS     r0,#0
000ba4  494b              LDR      r1,|L1.3284|
000ba6  8008              STRH     r0,[r1,#0]
;;;2112   			SECURITY_9511_STAT=FALSE;
000ba8  494b              LDR      r1,|L1.3288|
000baa  7008              STRB     r0,[r1,#0]
;;;2113   		 break;
000bac  e0fa              B        |L1.3492|
;;;2114   		 case 1: //第一个是有效密码
;;;2115   		 	for(i=0;i<8;i++)
000bae  2400              MOVS     r4,#0
000bb0  e005              B        |L1.3006|
                  |L1.2994|
;;;2116   				 ds3_src[i]=*(u8*)(Addr1+i);
000bb2  f81b0004          LDRB     r0,[r11,r4]
000bb6  4949              LDR      r1,|L1.3292|
000bb8  5508              STRB     r0,[r1,r4]
000bba  1c60              ADDS     r0,r4,#1              ;2115
000bbc  b2c4              UXTB     r4,r0                 ;2115
                  |L1.3006|
000bbe  2c08              CMP      r4,#8                 ;2115
000bc0  dbf7              BLT      |L1.2994|
;;;2117   			crypto_des3_decrypt(&ds3_crypto_des3_ctx_t,
000bc2  4a46              LDR      r2,|L1.3292|
000bc4  4946              LDR      r1,|L1.3296|
000bc6  4847              LDR      r0,|L1.3300|
000bc8  f7fffffe          BL       crypto_des3_decrypt
;;;2118                       ds3_dst,
;;;2119                       ds3_src);//解密
;;;2120   			Sec_Number=tmp1;
000bcc  4841              LDR      r0,|L1.3284|
000bce  8005              STRH     r5,[r0,#0]
;;;2121   			for(i=0;i<4;i++)//将密码保存，为通讯中上传。
000bd0  2400              MOVS     r4,#0
000bd2  e006              B        |L1.3042|
                  |L1.3028|
;;;2122   			{
;;;2123   				MAIN_Sec_ID[i]=ds3_dst[i+4];
000bd4  4942              LDR      r1,|L1.3296|
000bd6  1d20              ADDS     r0,r4,#4
000bd8  5c08              LDRB     r0,[r1,r0]
000bda  493d              LDR      r1,|L1.3280|
000bdc  5508              STRB     r0,[r1,r4]
000bde  1c60              ADDS     r0,r4,#1              ;2121
000be0  b2c4              UXTB     r4,r0                 ;2121
                  |L1.3042|
000be2  2c04              CMP      r4,#4                 ;2121
000be4  dbf6              BLT      |L1.3028|
;;;2124   			}
;;;2125   			if(Confirm_status==0)//如果没有认证过，发当前加密顺序
000be6  4840              LDR      r0,|L1.3304|
000be8  7800              LDRB     r0,[r0,#0]  ; Confirm_status
000bea  b978              CBNZ     r0,|L1.3084|
;;;2126   				//for(i=0;i<4;i++)//将密码保存，为通讯中上传。
;;;2127   				{
;;;2128   					tmp1=~tmp1;
000bec  43e8              MVNS     r0,r5
000bee  b285              UXTH     r5,r0
;;;2129   					tmp_u8=Sec_Number&0xFF;
000bf0  4838              LDR      r0,|L1.3284|
000bf2  8800              LDRH     r0,[r0,#0]  ; Sec_Number
000bf4  b2c7              UXTB     r7,r0
;;;2130   					ds3_src_tmp[0]=tmp_u8;
000bf6  483d              LDR      r0,|L1.3308|
000bf8  7007              STRB     r7,[r0,#0]
;;;2131   					tmp_u8=(Sec_Number&0xFF00)>>8;
000bfa  4836              LDR      r0,|L1.3284|
000bfc  8800              LDRH     r0,[r0,#0]  ; Sec_Number
000bfe  0a07              LSRS     r7,r0,#8
;;;2132   					ds3_src_tmp[1]=tmp_u8;
000c00  483a              LDR      r0,|L1.3308|
000c02  7047              STRB     r7,[r0,#1]
;;;2133   					tmp_u8=tmp1&0xFF;
000c04  b2ef              UXTB     r7,r5
;;;2134   					ds3_src_tmp[2]=tmp_u8;
000c06  7087              STRB     r7,[r0,#2]
;;;2135   					tmp_u8=(tmp1&0xFF00)>>8;
000c08  0a2f              LSRS     r7,r5,#8
;;;2136   					ds3_src_tmp[3]=tmp_u8;
000c0a  70c7              STRB     r7,[r0,#3]
                  |L1.3084|
;;;2137   				}
;;;2138   			if((MAIN_Sec_ID[0]!=0xff)||(MAIN_Sec_ID[1]!=0xff)||(MAIN_Sec_ID[2]!=0xff)||(MAIN_Sec_ID[3]!=0xff))//是加密主板
000c0c  4830              LDR      r0,|L1.3280|
000c0e  7800              LDRB     r0,[r0,#0]  ; MAIN_Sec_ID
000c10  28ff              CMP      r0,#0xff
000c12  d10b              BNE      |L1.3116|
000c14  482e              LDR      r0,|L1.3280|
000c16  7840              LDRB     r0,[r0,#1]  ; MAIN_Sec_ID
000c18  28ff              CMP      r0,#0xff
000c1a  d107              BNE      |L1.3116|
000c1c  482c              LDR      r0,|L1.3280|
000c1e  7880              LDRB     r0,[r0,#2]  ; MAIN_Sec_ID
000c20  28ff              CMP      r0,#0xff
000c22  d103              BNE      |L1.3116|
000c24  482a              LDR      r0,|L1.3280|
000c26  78c0              LDRB     r0,[r0,#3]  ; MAIN_Sec_ID
000c28  28ff              CMP      r0,#0xff
000c2a  d002              BEQ      |L1.3122|
                  |L1.3116|
;;;2139   		 	{
;;;2140   			 	//从倒数第二个页取数据，如果9511已经加密了，判断密码是否一致,不一致设置禁止变量
;;;2141   				//9511没有加密，直接退出
;;;2142   				SECURITY_9511_STAT=TRUE;
000c2c  2001              MOVS     r0,#1
000c2e  492a              LDR      r1,|L1.3288|
000c30  7008              STRB     r0,[r1,#0]
                  |L1.3122|
;;;2143   		 	}
;;;2144   
;;;2145   		 break;
000c32  e0b7              B        |L1.3492|
;;;2146   		 case 2: //第二个是有效密码
;;;2147   		 	for(i=0;i<8;i++)
000c34  2400              MOVS     r4,#0
000c36  e005              B        |L1.3140|
                  |L1.3128|
;;;2148   				 ds3_src[i]=*(u8*)(Addr2+i);
000c38  9800              LDR      r0,[sp,#0]
000c3a  5d00              LDRB     r0,[r0,r4]
000c3c  4927              LDR      r1,|L1.3292|
000c3e  5508              STRB     r0,[r1,r4]
000c40  1c60              ADDS     r0,r4,#1              ;2147
000c42  b2c4              UXTB     r4,r0                 ;2147
                  |L1.3140|
000c44  2c08              CMP      r4,#8                 ;2147
000c46  dbf7              BLT      |L1.3128|
;;;2149   			crypto_des3_decrypt(&ds3_crypto_des3_ctx_t,
000c48  4a24              LDR      r2,|L1.3292|
000c4a  4925              LDR      r1,|L1.3296|
000c4c  4825              LDR      r0,|L1.3300|
000c4e  f7fffffe          BL       crypto_des3_decrypt
;;;2150                       ds3_dst,
;;;2151                       ds3_src);//解密
;;;2152   			Sec_Number=tmp2;
000c52  4820              LDR      r0,|L1.3284|
000c54  8006              STRH     r6,[r0,#0]
;;;2153   			for(i=0;i<4;i++)//将密码保存，为通讯中上传。
000c56  2400              MOVS     r4,#0
000c58  e006              B        |L1.3176|
                  |L1.3162|
;;;2154   			{
;;;2155   				MAIN_Sec_ID[i]=ds3_dst[i+4];
000c5a  4921              LDR      r1,|L1.3296|
000c5c  1d20              ADDS     r0,r4,#4
000c5e  5c08              LDRB     r0,[r1,r0]
000c60  491b              LDR      r1,|L1.3280|
000c62  5508              STRB     r0,[r1,r4]
000c64  1c60              ADDS     r0,r4,#1              ;2153
000c66  b2c4              UXTB     r4,r0                 ;2153
                  |L1.3176|
000c68  2c04              CMP      r4,#4                 ;2153
000c6a  dbf6              BLT      |L1.3162|
;;;2156   			}
;;;2157   			if(Confirm_status==0)
000c6c  481e              LDR      r0,|L1.3304|
000c6e  7800              LDRB     r0,[r0,#0]  ; Confirm_status
000c70  b988              CBNZ     r0,|L1.3222|
;;;2158   			//for(i=0;i<4;i++)//将密码保存，为通讯中上传。
;;;2159   				{
;;;2160   					tmp2=~tmp2;
000c72  43f0              MVNS     r0,r6
000c74  b286              UXTH     r6,r0
;;;2161   					tmp_u8=Sec_Number&0xFF;
000c76  4817              LDR      r0,|L1.3284|
000c78  8800              LDRH     r0,[r0,#0]  ; Sec_Number
000c7a  b2c7              UXTB     r7,r0
;;;2162   					ds3_src_tmp[0]=tmp_u8;
000c7c  481b              LDR      r0,|L1.3308|
000c7e  7007              STRB     r7,[r0,#0]
;;;2163   					tmp_u8=(Sec_Number&0xFF00)>>8;
000c80  4814              LDR      r0,|L1.3284|
000c82  e000              B        |L1.3206|
                  |L1.3204|
000c84  e08d              B        |L1.3490|
                  |L1.3206|
000c86  8800              LDRH     r0,[r0,#0]  ; Sec_Number
000c88  0a07              LSRS     r7,r0,#8
;;;2164   					ds3_src_tmp[1]=tmp_u8;
000c8a  4818              LDR      r0,|L1.3308|
000c8c  7047              STRB     r7,[r0,#1]
;;;2165   					tmp_u8=tmp2&0xFF;
000c8e  b2f7              UXTB     r7,r6
;;;2166   					ds3_src_tmp[2]=tmp_u8;
000c90  7087              STRB     r7,[r0,#2]
;;;2167   					tmp_u8=(tmp2&0xFF00)>>8;
000c92  0a37              LSRS     r7,r6,#8
;;;2168   					ds3_src_tmp[3]=tmp_u8;
000c94  70c7              STRB     r7,[r0,#3]
                  |L1.3222|
;;;2169   				}
;;;2170   			if((MAIN_Sec_ID[0]!=0xff)||(MAIN_Sec_ID[1]!=0xff)||(MAIN_Sec_ID[2]!=0xff)||(MAIN_Sec_ID[3]!=0xff))//是加密主板
000c96  480e              LDR      r0,|L1.3280|
000c98  7800              LDRB     r0,[r0,#0]  ; MAIN_Sec_ID
000c9a  28ff              CMP      r0,#0xff
000c9c  d134              BNE      |L1.3336|
000c9e  e027              B        |L1.3312|
                  |L1.3232|
                          DCD      i_odd
                  |L1.3236|
                          DCD      BSP_POTValue
                  |L1.3240|
                          DCD      i_even
                  |L1.3244|
                          DCD      0x000186a0
                  |L1.3248|
                          DCD      BSP_Is924
                  |L1.3252|
                          DCD      0x40013800
                  |L1.3256|
                          DCD      0x1ffff000
                  |L1.3260|
                          DCD      0x0801f000
                  |L1.3264|
                          DCD      PRO_9511_ID
                  |L1.3268|
                          DCD      0x0801f800
                  |L1.3272|
                          DCD      0x0801f400
                  |L1.3276|
                          DCD      thir_status
                  |L1.3280|
                          DCD      MAIN_Sec_ID
                  |L1.3284|
                          DCD      Sec_Number
                  |L1.3288|
                          DCD      SECURITY_9511_STAT
                  |L1.3292|
                          DCD      ds3_src
                  |L1.3296|
                          DCD      ds3_dst
                  |L1.3300|
                          DCD      ds3_crypto_des3_ctx_t
                  |L1.3304|
                          DCD      Confirm_status
                  |L1.3308|
                          DCD      ds3_src_tmp
                  |L1.3312|
000cf0  483b              LDR      r0,|L1.3552|
000cf2  7840              LDRB     r0,[r0,#1]  ; MAIN_Sec_ID
000cf4  28ff              CMP      r0,#0xff
000cf6  d107              BNE      |L1.3336|
000cf8  4839              LDR      r0,|L1.3552|
000cfa  7880              LDRB     r0,[r0,#2]  ; MAIN_Sec_ID
000cfc  28ff              CMP      r0,#0xff
000cfe  d103              BNE      |L1.3336|
000d00  4837              LDR      r0,|L1.3552|
000d02  78c0              LDRB     r0,[r0,#3]  ; MAIN_Sec_ID
000d04  28ff              CMP      r0,#0xff
000d06  d002              BEQ      |L1.3342|
                  |L1.3336|
;;;2171   		 	{
;;;2172   			 	//从倒数第二个页取数据，如果9511已经加密了，判断密码是否一致,不一致设置禁止变量
;;;2173   				//9511没有加密，直接退出
;;;2174   				SECURITY_9511_STAT=TRUE;
000d08  2001              MOVS     r0,#1
000d0a  4936              LDR      r1,|L1.3556|
000d0c  7008              STRB     r0,[r1,#0]
                  |L1.3342|
;;;2175   		 	}
;;;2176   		 break;
000d0e  e049              B        |L1.3492|
;;;2177   		 case 3://第一块加密无效，第二块不加密
;;;2178   		  Sec_Number=0;
000d10  2000              MOVS     r0,#0
000d12  4935              LDR      r1,|L1.3560|
000d14  8008              STRH     r0,[r1,#0]
;;;2179   		 for(i=0;i<4;i++)//将密码设置为0xFF。
000d16  2400              MOVS     r4,#0
000d18  e004              B        |L1.3364|
                  |L1.3354|
;;;2180   		{
;;;2181   			MAIN_Sec_ID[i]=0xFF;
000d1a  20ff              MOVS     r0,#0xff
000d1c  4930              LDR      r1,|L1.3552|
000d1e  5508              STRB     r0,[r1,r4]
000d20  1c60              ADDS     r0,r4,#1              ;2179
000d22  b2c4              UXTB     r4,r0                 ;2179
                  |L1.3364|
000d24  2c04              CMP      r4,#4                 ;2179
000d26  dbf8              BLT      |L1.3354|
;;;2182   		}
;;;2183   		SECURITY_9511_STAT=FALSE;
000d28  2000              MOVS     r0,#0
000d2a  492e              LDR      r1,|L1.3556|
000d2c  7008              STRB     r0,[r1,#0]
;;;2184   		FLASH_Unlock();
000d2e  f7fffffe          BL       FLASH_Unlock
;;;2185   		FLASH_ErasePage(Addr1);
000d32  4658              MOV      r0,r11
000d34  f7fffffe          BL       FLASH_ErasePage
;;;2186   		FLASH_Lock();
000d38  f7fffffe          BL       FLASH_Lock
;;;2187   		 break;
000d3c  e032              B        |L1.3492|
;;;2188   		 case 4://第二块加密无效，第一块不加密
;;;2189   		 Sec_Number=0;
000d3e  2000              MOVS     r0,#0
000d40  4929              LDR      r1,|L1.3560|
000d42  8008              STRH     r0,[r1,#0]
;;;2190   		 for(i=0;i<4;i++)//将密码设置为0xFF。
000d44  2400              MOVS     r4,#0
000d46  e004              B        |L1.3410|
                  |L1.3400|
;;;2191   		{
;;;2192   			MAIN_Sec_ID[i]=0xFF;
000d48  20ff              MOVS     r0,#0xff
000d4a  4925              LDR      r1,|L1.3552|
000d4c  5508              STRB     r0,[r1,r4]
000d4e  1c60              ADDS     r0,r4,#1              ;2190
000d50  b2c4              UXTB     r4,r0                 ;2190
                  |L1.3410|
000d52  2c04              CMP      r4,#4                 ;2190
000d54  dbf8              BLT      |L1.3400|
;;;2193   		}
;;;2194   		SECURITY_9511_STAT=FALSE;
000d56  2000              MOVS     r0,#0
000d58  4922              LDR      r1,|L1.3556|
000d5a  7008              STRB     r0,[r1,#0]
;;;2195   		FLASH_Unlock();
000d5c  f7fffffe          BL       FLASH_Unlock
;;;2196   		FLASH_ErasePage(Addr2);
000d60  9800              LDR      r0,[sp,#0]
000d62  f7fffffe          BL       FLASH_ErasePage
;;;2197   		FLASH_Lock();
000d66  f7fffffe          BL       FLASH_Lock
;;;2198   		 break;
000d6a  e01b              B        |L1.3492|
000d6c  e7ff              B        |L1.3438|
                  |L1.3438|
;;;2199   		 case 5://两个都是无效密码
;;;2200   		 Sec_Number=0;
000d6e  2000              MOVS     r0,#0
000d70  491d              LDR      r1,|L1.3560|
000d72  8008              STRH     r0,[r1,#0]
;;;2201   		 for(i=0;i<4;i++)//将密码设置为0xFF。
000d74  2400              MOVS     r4,#0
000d76  e004              B        |L1.3458|
                  |L1.3448|
;;;2202   		{
;;;2203   			MAIN_Sec_ID[i]=0xFF;
000d78  20ff              MOVS     r0,#0xff
000d7a  4919              LDR      r1,|L1.3552|
000d7c  5508              STRB     r0,[r1,r4]
000d7e  1c60              ADDS     r0,r4,#1              ;2201
000d80  b2c4              UXTB     r4,r0                 ;2201
                  |L1.3458|
000d82  2c04              CMP      r4,#4                 ;2201
000d84  dbf8              BLT      |L1.3448|
;;;2204   		}
;;;2205   		SECURITY_9511_STAT=FALSE;
000d86  2000              MOVS     r0,#0
000d88  4916              LDR      r1,|L1.3556|
000d8a  7008              STRB     r0,[r1,#0]
;;;2206   		FLASH_Unlock();
000d8c  f7fffffe          BL       FLASH_Unlock
;;;2207   		FLASH_ErasePage(Addr1);
000d90  4658              MOV      r0,r11
000d92  f7fffffe          BL       FLASH_ErasePage
;;;2208   		FLASH_ErasePage(Addr2);
000d96  9800              LDR      r0,[sp,#0]
000d98  f7fffffe          BL       FLASH_ErasePage
;;;2209   		FLASH_Lock();
000d9c  f7fffffe          BL       FLASH_Lock
;;;2210   		 break;
000da0  e000              B        |L1.3492|
                  |L1.3490|
;;;2211   		 default :
;;;2212   		 break;
000da2  bf00              NOP      
                  |L1.3492|
000da4  bf00              NOP                            ;2113
;;;2213   	}
;;;2214   		
;;;2215   }
000da6  e8bd8ff8          POP      {r3-r11,pc}
;;;2216   
                          ENDP

                  BSP_SOL_TmrProc PROC
;;;2240   
;;;2241   void  BSP_SOL_TmrProc (void)
000daa  b510              PUSH     {r4,lr}
;;;2242   {
;;;2243       u32     i;
;;;2244       
;;;2245       
;;;2246       for (i = 0; i < BSP_DEVICE_ID_N; i++) {
000dac  2400              MOVS     r4,#0
000dae  e014              B        |L1.3546|
                  |L1.3504|
;;;2247           if (BSP_TimerSol[i] != 0) {
000db0  480e              LDR      r0,|L1.3564|
000db2  f8300014          LDRH     r0,[r0,r4,LSL #1]
000db6  b178              CBZ      r0,|L1.3544|
;;;2248               BSP_TimerSol[i]--;
000db8  480c              LDR      r0,|L1.3564|
000dba  f8300014          LDRH     r0,[r0,r4,LSL #1]
000dbe  1e40              SUBS     r0,r0,#1
000dc0  490a              LDR      r1,|L1.3564|
000dc2  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;2249               if (BSP_TimerSol[i] == 0) {
000dc6  4608              MOV      r0,r1
000dc8  f8300014          LDRH     r0,[r0,r4,LSL #1]
000dcc  b920              CBNZ     r0,|L1.3544|
;;;2250                   BSP_SOL_Set((BSP_ID_TypeDef)i, BSP_SOL_OFF, 0);
000dce  2200              MOVS     r2,#0
000dd0  4611              MOV      r1,r2
000dd2  b2e0              UXTB     r0,r4
000dd4  f7fffffe          BL       BSP_SOL_Set
                  |L1.3544|
000dd8  1c64              ADDS     r4,r4,#1              ;2246
                  |L1.3546|
000dda  2c02              CMP      r4,#2                 ;2246
000ddc  d3e8              BCC      |L1.3504|
;;;2251               }
;;;2252           }
;;;2253       }
;;;2254   }
000dde  bd10              POP      {r4,pc}
;;;2255   
                          ENDP

                  |L1.3552|
                          DCD      MAIN_Sec_ID
                  |L1.3556|
                          DCD      SECURITY_9511_STAT
                  |L1.3560|
                          DCD      Sec_Number
                  |L1.3564|
                          DCD      BSP_TimerSol

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  STM32_ID
                          %        12
                  BSP_POTValue
                          %        32
                  BSP_TMR_CNT_PRESCALER
                          %        186

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  io_id_pro_o
000000  4d45              DCB      0x4d,0x45
                  io_id_clk_o
000002  434f              DCB      0x43,0x4f
                  io_id_dir_o
000004  444c              DCB      0x44,0x4c
                  io_id_tq1_o
000006  411c              DCB      0x41,0x1c
                  io_id_m1_o
000008  3c38              DCB      0x3c,0x38
                  io_id_sol
00000a  2829              DCB      0x28,0x29
                  io_id_qf
00000c  08                DCB      0x08
                  io_id_led
00000d  1519              DCB      0x15,0x19
                  io_id_hd_up
00000f  48                DCB      0x48
000010  2a                DCB      0x2a
                  io_id_hd_dn
000011  4a30              DCB      0x4a,0x30
                  io_id_hd_r
000013  49                DCB      0x49
000014  2b                DCB      0x2b
                  io_id_hd_g
000015  4b2c              DCB      0x4b,0x2c
                  io_id_swi_fi
000017  47                DCB      0x47
000018  31                DCB      0x31
                  io_id_swi_se
000019  3637              DCB      0x36,0x37
                  io_id_sqn
00001b  32                DCB      0x32
00001c  34                DCB      0x34
                  io_id_enc_a
00001d  0016              DCB      0x00,0x16
                  io_id_enc_i
00001f  02                DCB      0x02
000020  18                DCB      0x18

                          AREA ||.data||, DATA, ALIGN=2

                  tim_id_encoder
                          DCD      0x40000000
                          DCD      0x40000800
                  i_odd
000008  00                DCB      0x00
                  i_even
000009  00                DCB      0x00
                  BSP_Is924
00000a  00                DCB      0x00
                  BSP_DIP_TQ
00000b  00                DCB      0x00
                  BSP_DIP_BDFunc
00000c  00                DCB      0x00
                  BSP_DIP_9511Addr
00000d  00                DCB      0x00
                  BSP_DIP_924Addr
00000e  00                DCB      0x00
                  SECURITY_9511_STAT
00000f  00                DCB      0x00
                  MAIN_SECURITY_STAT
000010  00                DCB      0x00
                  PRO_9511_ID
000011  000000            DCB      0x00,0x00,0x00
000014  00                DCB      0x00
                  MAIN_Sec_ID
000015  000000            DCB      0x00,0x00,0x00
000018  00                DCB      0x00
                  BSP_DIP_SpdIsSlow
000019  00                DCB      0x00
                  BSP_DIP_RedIsSpkl
00001a  0000              DCB      0x00,0x00
                  BSP_TimerSol
                          DCD      0x00000000
